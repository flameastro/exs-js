Imprima "Ol√°, mundo!" no console.
Declare duas vari√°veis `a` e `b` e imprima a soma.
Escreva uma fun√ß√£o `parOuImpar(n)` que retorna "par" ou "√≠mpar".
Crie uma fun√ß√£o `fatorial(n)` que retorna o fatorial de `n` (iterativo).
Encontre o maior entre tr√™s n√∫meros.
Converta uma string para mai√∫sculas e min√∫sculas.
Conte quantas vogais existem em uma string.
Inverta uma string.
Verifique se uma string √© pal√≠ndromo (ignorar espa√ßos e case).
Remova espa√ßos extras de uma string (trim e reduzir m√∫ltiplos espa√ßos).
Substitua todas as ocorr√™ncias de uma palavra por outra em uma string.
Concatene duas arrays e mostre o resultado.
Dado um array de n√∫meros, calcule a m√©dia.
Escreva uma fun√ß√£o que retorne o array sem duplicatas.
Ordene um array de n√∫meros em ordem crescente (use `sort` corretamente).
Fa√ßa um `map` que transforma um array de strings em comprimentos.
Filtre somente n√∫meros pares de um array.
Use `reduce` para somar todos os elementos de um array.
Crie uma fun√ß√£o que gera um array com os N primeiros n√∫meros pares.
Gere um n√∫mero aleat√≥rio entre 1 e 100.
Formate a data atual como `YYYY-MM-DD HH:mm:ss`.
Leia o `process.argv` e imprima-os um por linha.
Crie uma fun√ß√£o `clamp(x, min, max)` que limita `x` a `[min,max]`.
Conta quantas palavras tem uma string.
Modele um objeto `pessoa` com `{nome, idade}`, e imprima uma frase.
Fa√ßa uma c√≥pia rasa (`shallow copy`) de um objeto.
Mescle dois objetos em um novo objeto.
Verifique se um objeto est√° vazio.
Liste as chaves e valores de um objeto.
Construa uma fun√ß√£o que receba objetos e retorne apenas os pares chave-valor com valores string.
Crie uma fun√ß√£o `range(start, end)` que retorna um array com os n√∫meros nesse intervalo.
Implemente o operador tern√°rio em uma fun√ß√£o que retorna desconto dependendo da idade.
Use `setTimeout` para imprimir uma mensagem ap√≥s 2 segundos.
Use `setInterval` para imprimir um contador a cada segundo e pare ap√≥s 5 segundos.
Explique e demonstre `let`, `const` e `var` com exemplos.
Demonstre block scope com `let`.
Crie uma fun√ß√£o que retorna outra fun√ß√£o (closure) que soma um valor fixo.
Demonstre o uso de template literals para montar uma frase.
Crie um objeto com m√©todo que usa `this` para acessar propriedades.
Mostre exemplo de `.bind()` para fixar `this`.
Crie uma classe `Pessoa` com `constructor(nome, idade)` e m√©todo `aniversario()` que incrementa `idade`.
Heran√ßa: classe `Aluno` estende `Pessoa` e adiciona `curso`.
Crie um m√≥dulo simples (arquivo) que exporta uma fun√ß√£o e consuma-o em outro arquivo.
Use `try/catch` para tratar erro ao converter JSON inv√°lido.
Leia um arquivo `entrada.txt` sincronicamente e imprima seu conte√∫do (m√≥dulo `fs`).
Grave uma string num arquivo `saida.txt` sincronicamente.
Fa√ßa a mesma leitura/grava√ß√£o usando m√©todos ass√≠ncronos com callbacks.
Use `fs.promises` e `async/await` para ler um arquivo.
Crie um script que conte linhas de um arquivo passado por `argv`.
Crie um pequeno CLI que recebe `--nome` e `--idade` e imprime uma mensagem.
Parseie JSON de `process.stdin` e mostre uma propriedade espec√≠fica.
Crie uma fun√ß√£o `randomChoice(array)` que retorna item aleat√≥rio.
Fa√ßa um programa que inverte a ordem das linhas de um arquivo.
Use `path` para juntar diret√≥rios de forma cross-platform.
Explique e demonstre `typeof` e `instanceof`.
Implemente uma fun√ß√£o que valida se um valor √© n√∫mero finito.
Crie um programa que mede o tempo de execu√ß√£o de uma fun√ß√£o (usando `console.time`).
Fa√ßa um gerador de senha simples com letras e n√∫meros.
Conte caracteres √∫nicos em uma string.
Converta um n√∫mero decimal para bin√°rio (string).
Converta um n√∫mero bin√°rio (string) para decimal.
Implemente `isAnagram(a,b)` que verifica se duas strings s√£o anagramas.
Substitua vogais por `*` em uma string.
Crie `capitalizeWords(str)` que capitaliza cada palavra.
Crie um gerador de n√∫meros primos at√© N (crivo simples).
Implemente uma fun√ß√£o que calcula MDC (algoritmo de Euclides).
Implemente uma fun√ß√£o que calcula MMC.
Valide um CPF (apenas formato e d√≠gitos ‚Äî simplificado) ‚Äî ou substitua por outro documento local.
Gere a tabuada de um n√∫mero at√© 10 e imprima formatado.
Fa√ßa um script que substitui tabs por 4 espa√ßos em um arquivo.
Crie uma fun√ß√£o `flatten` que achata um array 2D em 1D.
Escreva `uniqueSorted` que retorna valores √∫nicos ordenados.
Crie fun√ß√£o `sleep(ms)` usando `Promise` e `setTimeout`.
Demonstre `Promise.resolve` e `Promise.reject` com exemplos.
Reescreva uma fun√ß√£o callback-based para `async/await`.
Crie um pequeno script que conta arquivos em uma pasta (fs.readdir).
Implemente `deepClone` simples (para objetos sem fun√ß√µes nem ciclos).

---

## Se√ß√£o B ‚Äî Intermedi√°rio (81‚Äì170)

81. (I) Escreva uma fun√ß√£o `debounce(fn, ms)` e explique seu uso.
82. (I) Escreva uma fun√ß√£o `throttle(fn, ms)`.
83. (I) Implemente `memoize(fn)` para fun√ß√µes puras.
84. (I) Fa√ßa uma fun√ß√£o `compose(f,g)` que comp√µe duas fun√ß√µes.
85. (I) Crie um pequeno REPL que aceita comandos e responde (use `readline`).
86. (I) Escreva um programa que busca por uma palavra em v√°rios arquivos (grep simples).
87. (I) Valide um e-mail com RegExp (b√°sico, n√£o perfeito).
88. (I) Valide um n√∫mero de telefone no formato internacional.
89. (I) Parseie CSV simples e converta para JSON (suportar aspas simples e v√≠rgulas).
90. (I) Converta JSON para CSV.
91. (I) Escreva um algoritmo de busca bin√°ria para arrays ordenados.
92. (I) Implemente ordena√ß√£o merge sort.
93. (I) Implemente quicksort (in-place ou n√£o).
94. (I) Encontre o k-√©simo menor elemento em um array.
95. (I) Resolva o problema da soma de dois n√∫meros que d√£o target (Hash map).
96. (I) Encontre o subarray de soma m√°xima (Kadane).
97. (I) Detecte ciclos em uma lista ligada (implementar lista ligada simples).
98. (I) Implemente pilha (`Stack`) e fila (`Queue`) e demonstre usos.
99. (I) Fa√ßa `LRU Cache` simples usando Map e lista duplamente ligada (simples).
100. (I) Crie um parser simples de express√µes aritm√©ticas (somar, subtrair, multiplicar, dividir).
101. (I) Interprete e execute express√µes com par√™nteses.
102. (I) Implemente um pequeno template engine que substitui `{{chave}}` em texto.
103. (I) Crie um programa que monitora mudan√ßas em um diret√≥rio (`fs.watch`) e loga eventos.
104. (I) Fa√ßa um script que compacta arquivos em `.zip` (usar `zlib` e `fs` ou biblioteca nativa se dispon√≠vel).
105. (I) Trabalhe com Buffers: concatene buffers e converta para string e vice-versa.
106. (I) Codifique/decodifique base64 manualmente (usar `Buffer` para checar).
107. (I) Crie um pequeno CLI que aceita comandos interativos e usa subcomandos (ex: `app add`, `app list`).
108. (I) Implemente leitura de um arquivo grande por streams e conte linhas sem carregar tudo na mem√≥ria.
109. (I) Fa√ßa escrita por stream para um arquivo grande.
110. (I) Use events: crie um `EventEmitter` customizado que emite eventos e listeners.
111. (I) Crie um script que faz requisi√ß√µes HTTP GET (use `https`/`http` do Node) e imprime status e headers.
112. (I) Fa√ßa requisi√ß√£o HTTPS e baixe um recurso para disco.
113. (I) Parseie query string (sem usar `querystring`), transforme em objeto.
114. (I) Crie um cliente TCP simples usando `net` que se conecta a um servidor de eco.
115. (I) Crie um servidor TCP de eco que devolve dados recebidos.
116. (I) Implemente uma fila de tarefas simples com concorr√™ncia limitada (pool de workers em JS).
117. (I) Fazer retry com backoff exponencial para uma fun√ß√£o ass√≠ncrona.
118. (I) Implemente `promisify` (converter fun√ß√£o callback style para Promise).
119. (I) Testes unit√°rios: escreva testes simples usando `assert` nativo (sem frameworks).
120. (I) Use `child_process.spawn` para executar `ls`/`dir` e leia `stdout`/`stderr`.
121. (I) Crie um script que zera/rota logs antigos (rota√ß√£o simples por tamanho).
122. (I) Serializa√ß√£o: converta objetos com refer√™ncias para JSON seguro (detectar ciclos).
123. (I) Escreva uma fun√ß√£o `groupBy(array, keyFn)`.
124. (I) Implemente `binaryTree` e percorra em ordem (in-order), pr√© e p√≥s.
125. (I) Resolva problema de permuta√ß√µes de uma string (todas as permuta√ß√µes).
126. (I) Gere combina√ß√µes (`n choose k`) e suas aplica√ß√µes.
127. (I) Resolva o problema das oito rainhas (backtracking).
128. (I) Fa√ßa um solver para Sudoku (backtracking).
129. (I) Implemente algoritmo para detec√ß√£o de anagramas em grande texto (stream).
130. (I) Crie uma CLI que exporta dados para `.json` e `.csv` conforme flag.
131. (I) Escreva uma implementa√ß√£o de `EventEmitter` m√≠nima do zero.
132. (I) Fa√ßa um profiler simples que mede tempo gasto por fun√ß√µes ass√≠ncronas (instrumenta√ß√£o).
133. (I) Implemente um sistema de logging com n√≠veis (info, warn, error) e rota√ß√£o.
134. (I) Crie um gerador de thumbnails para imagens usando `sharp` (opcional lib) ‚Äî alternativa: descrever o fluxo sem lib.
135. (I) Fa√ßa um script que assina dados com HMAC (m√≥dulo `crypto`).
136. (I) Verifique assinaturas HMAC e detecte altera√ß√µes.
137. (I) Gere e verifique UUIDs (use `crypto.randomUUID()` quando dispon√≠vel).
138. (I) Crie um script que calcula hash de arquivos (`sha256`) e compara.
139. (I) Escreva um conversor entre linhas CRLF e LF para arquivos.
140. (I) Fa√ßa um utilit√°rio que extrai metadados b√°sicos de imagens (dimensionamento) ‚Äî sem DOM: ler header do arquivo (ex.: PNG/JPEG).
141. (I) Simule um tr√¢nsito de mensagens com `setImmediate`, `process.nextTick` e `setTimeout` para demonstrar ordem de execu√ß√£o.
142. (I) Crie uma fun√ß√£o que valida um JSON contra um esquema simples (regras b√°sicas: required e tipo).
143. (I) Implemente `flattenDeep` para arrays com profundidade arbitr√°ria.
144. (I) Resolva o problema do anel Josephus.
145. (I) Implemente algoritmo de Dijkstra para grafos dirigidos (representa√ß√£o por lista de adjac√™ncia).
146. (I) Use `Map` e `Set` e explique diferen√ßas com objetos/arrays.
147. (I) Crie um visualizador de √°rvore de diret√≥rios em texto (como `tree`).
148. (I) Fa√ßa um conversor de unidades (km/miles, Celsius/Fahrenheit) com CLI e flags.
149. (I) Implemente um mini banco de dados em mem√≥ria com opera√ß√µes CRUD.
150. (I) Crie um script para detectar duplicatas em uma pasta por hash de arquivo.
151. (I) Implemente algoritmo Union-Find (disjoint set) com path compression.
152. (I) Resolva o problema do subset sum (backtracking/dp) e discuta complexidade.
153. (I) Implemente busca A* para um grid simples (heur√≠stica Manhattan).
154. (I) Escreva um cliente SMTP m√≠nimo para enviar um e-mail simples (usar `net` ou biblioteca).
155. (I) Implemente um sistema de cache em arquivo com TTL.
156. (I) Escreva um programa que gera dados falsos (fake data) para testes (nomes, emails).
157. (I) Fa√ßa uma CLI que gera senhas seguras com op√ß√µes (comprimento, incluir s√≠mbolos).
158. (I) Escreva um parser de logs (`access.log`) e compute estat√≠sticas (hits por IP, endpoints mais acessados).
159. (I) Implemente serializa√ß√£o bin√°ria simples para um objeto (definir estrutura e pack/unpack usando Buffer).
160. (I) Crie uma fun√ß√£o que calcula similaridade entre strings (Levenshtein distance).
161. (I) Implemente compress√£o RLE (run-length encoding) e descompress√£o.
162. (I) Fa√ßa um script que monitora uso de CPU/mem√≥ria (usar `os` module) e registra em arquivo.
## Continua√ß√£o ‚Äî exerc√≠cios 163‚Äì250

163. (I) Construa um CLI que consulta um servi√ßo online (usar https) e cacheie respostas por X minutos.
164. (I) Implemente um worker pool que processa arquivos em paralelo respeitando limite de concorr√™ncia.
165. (I) Crie um conversor de markdown para texto simples (strip tags markdown b√°sicas).
166. (I) Implemente throttle para leitura de stdin (limitando taxa de bytes processados).
167. (I) Escreva uma fun√ß√£o que agrupa palavras por raiz (stem) simples ‚Äî heur√≠stica.
168. (I) Implemente `peekable` iterator (able to peek next without consuming).
169. (I) Crie uma CLI para interagir com um JSON que atua como DB e permita opera√ß√µes (list, add, remove).
170. (I) Fa√ßa um script que sincroniza duas pastas (copia arquivos novos/atuais) ‚Äî vers√£o simples.

---

## Se√ß√£o C ‚Äî Avan√ßado (171‚Äì250)

171. (A) Implemente promessas cancel√°veis (patterns para cancelar opera√ß√µes ass√≠ncronas).
172. (A) Crie um mini task runner que executa tarefas com depend√™ncias (topological sort).
173. (A) Escreva um transpiler simples que converte `let/const` em `var` (exerc√≠cio te√≥rico ‚Äî manipula√ß√£o de strings/AST m√≠nima).
174. (A) Implemente um interpretador para uma linguagem simples (tiny-VM) com opera√ß√µes aritm√©ticas e vari√°veis.
175. (A) Construa um compilador que gera bytecode simples e um executor (simples VM stack-based).
176. (A) Implemente `WebSocket` server (usando `ws` lib) e cliente CLI que comunica mensagens (apenas Node).
177. (A) Crie um sistema de publish/subscribe distribu√≠do simples usando TCP/UDP (conceitual e implementa√ß√£o b√°sica).
178. (A) Implemente replica√ß√£o simples entre dois arquivos JSON (sincroniza√ß√£o de mudan√ßas, resolu√ß√£o b√°sica de conflitos).
179. (A) Escreva um gerenciador de depend√™ncias minimal (resolver vers√µes sem publicar) ‚Äî simular resolu√ß√£o sem rede.
180. (A) Construa um analisador est√°tico simples que detecta poss√≠veis vari√°veis n√£o usadas em um arquivo JS (heur√≠stico sem AST completo √© aceit√°vel).
181. (A) Implemente um coletor simples de m√©tricas que exp√µe um endpoint HTTP com estat√≠sticas em formato Prometheus.
182. (A) Fa√ßa um balanceador de carga simples que distribui requisi√ß√µes HTTP para m√∫ltiplos backends (round-robin) ‚Äî usando `http` e `http.request`.
183. (A) Implemente checkpoints e restaura√ß√£o para um processo que processa uma fila (persistir posi√ß√£o e retomar).
184. (A) Crie um sistema de autoriza√ß√£o simples baseado em tokens JWT (gera√ß√£o e verifica√ß√£o, sem usar bibliotecas externas para a parte did√°tica ‚Äî pode usar `crypto` para HMAC).
185. (A) Implemente um mini container runner: isolar execu√ß√£o de comandos em processo filho com limites de tempo e output (simples, sem namespaces).
186. (A) Desenvolva um analisador de depend√™ncias de um projeto Node (ler package.json e listar depend√™ncias recursivamente) ‚Äî sem instalar.
187. (A) Escreva um motor m√≠nimo de templates com suporte a loops e condicionais (ex.: `{{#each items}}...{{/each}}`).
188. (A) Implemente um indexador simples de arquivos que constr√≥i um √≠ndice invertido e permite busca por palavra (mini search).
189. (A) Crie uma CLI que executa migra√ß√µes em um arquivo JSON (migrar schema entre vers√µes com up/down).
190. (A) Implemente sincroniza√ß√£o de tempo via NTP simplificado (consultar servidor e ajustar offset ‚Äî apenas leitura/estimativa).
191. (A) Desenvolva um gerador de c√≥digo que cria stubs de fun√ß√µes a partir de uma interface JSON (nome, par√¢metros, docs).
192. (A) Implemente um sistema de plugins para uma CLI (descobrir e carregar m√≥dulos locais dinamicamente).
193. (A) Crie um parser de express√µes regulares simplificado (interprete `a|b`, concatena√ß√£o, `*`), construa NFA e teste.
194. (A) Implemente um servidor de arquivos P2P b√°sico usando `net` (peers que pedem/servem chunks de arquivos simples).
195. (A) Desenvolva um sistema de fila persistente com ack/nack (salvar mensagens em disco e reenfileirar quando necess√°rio).
196. (A) Implemente um algoritmo de compress√£o baseado em Huffman (encoding/decoding) e compare tamanhos.
197. (A) Crie um mini motor de regras (rule engine) que aplica regras declarativas sobre objetos JSON.
198. (A) Fa√ßa um compilador que transforma uma DSL de c√°lculos em JavaScript execut√°vel (ex.: `sum(a,b) -> a + b`).
199. (A) Implemente detec√ß√£o de pl√°gio simples entre textos (shingling + Jaccard similarity).
200. (A) Construa um micro servi√ßo que executa tarefas em background e fornece API para consulta de status (usar `child_process` ou `worker_threads`).
201. (A) Implemente `MapReduce` local: dividir dataset em peda√ßos, map, shuffle e reduce em paralelo (simular com processos/threads).
202. (A) Crie uma implementa√ß√£o do protocolo RAFT simplificada para elei√ß√£o de l√≠der entre inst√¢ncias (apenas simula√ß√£o local entre processos).
203. (A) Desenvolva um analisador de pacotes PCAP m√≠nimo (ler formato pcap e extrair cabe√ßalhos IP/TCP) ‚Äî leitura bin√°ria.
204. (A) Implemente um resolvedor DNS simples (consulta a servidores DNS via UDP e parse de resposta).
205. (A) Construa um motor de tarefas program√°veis (workflow) com passos dependentes e rollback b√°sico.
206. (A) Escreva um sistema de controle de vers√£o minimal (init, add, commit, log) para arquivos em uma pasta (armazenar metadados em .miniVC).
207. (A) Implemente um compilador que gera WebAssembly text (wat) a partir de express√µes aritm√©ticas simples (opcional ‚Äî teoria e gera√ß√£o de texto).
208. (A) Crie uma ferramenta de an√°lise de performance que injeta timers em fun√ß√µes de um m√≥dulo e gera relat√≥rio de hot-spots.
209. (A) Desenvolva um sistema de scripting embutido (embed a JS sandbox) para executar scripts de usu√°rio com limites (tempo e mem√≥ria estimada).
210. (A) Implemente um mecanismo de diff/patch textual e aplique patches entre duas vers√µes de arquivo.
211. (A) Construa uma aplica√ß√£o que resolve CAPTCHAs simples (teste educacional com imagens geradas internamente) ‚Äî focar reconhecimento b√°sico de padr√µes.
212. (A) Fa√ßa um analisador de depend√™ncias circulares em um projeto (detectar ciclos entre m√≥dulos require/import).
213. (A) Implemente um otimizador de pacotes est√°tico que identifica m√≥dulos n√£o utilizados para remo√ß√£o (tree shaking heur√≠stico).
214. (A) Crie um transpiler que converte uma subset de ES2020 para ES5 (por exemplo, transforma arrow functions e `const/let`).
215. (A) Construa um engine de regras para firewall simples (filtrar conex√µes por IP/porta e registrar eventos).
216. (A) Desenvolva um mini mecanismo de busca full-text com score TF-IDF b√°sico sobre um conjunto de documentos locais.
217. (A) Implemente um sistema de replicate-on-write para arquivos grandes (criar c√≥pias delta quando modificado).
218. (A) Crie um verificador de seguran√ßa de depend√™ncias que detecta vers√µes vulner√°veis (usar um banco de dados est√°tico de exemplo).
219. (A) Desenvolva um fuzzer simples para fun√ß√µes que recebem strings (gerar entradas aleat√≥rias e detectar crashes/exceptions).
220. (A) Implemente um scheduler de tarefas cron-like que executa comandos em hor√°rios especificados e registra hist√≥rico.
221. (A) Construa um analisador de linguagem natural simples que extrai intents e entidades de frases (heur√≠sticas, sem ML obrigat√≥rio).
222. (A) Implemente um mecanismo de replica√ß√£o eventual para pares chave-valor entre dois processos (simples, reconciliar por timestamp).
223. (A) Crie um analisador sem√¢ntico m√≠nimo que verifica tipos b√°sicos em um subset de JavaScript (infer√™ncia simples).
224. (A) Desenvolva uma vers√£o simplificada de `grep` que suporta regex e busca recursiva em pastas com progress bar.
225. (A) Escreva um otimizador que extrai constantes em tempo de compila√ß√£o (constant folding) para express√µes simples.
226. (A) Implemente um sistema de autoriza√ß√£o RBAC simples com roles, permiss√µes e checagens em CLI.
227. (A) Crie um motor de simula√ß√£o f√≠sica b√°sico para part√≠culas em 2D (integrador simples e colis√µes el√°sticas) e exponha resultados em CSV.
228. (A) Desenvolva um analisador de logs distribu√≠dos que correlaciona eventos por trace-id (simular m√∫ltiplos arquivos e agrega√ß√£o).
229. (A) Implemente um algoritmo de criptografia sim√©trica educacional (ex.: AES-like toy cipher) e documente fraquezas.
230. (A) Construa um servidor de autentica√ß√£o OAuth2 m√≠nimo (grant type password/refresh token) para fins educacionais.
231. (A) Desenvolva um mecanismo de versionamento de schema para JSON com aplica√ß√£o autom√°tica de migra√ß√µes.
232. (A) Implemente um gerador de documenta√ß√£o autom√°tica que l√™ coment√°rios JSDoc e gera Markdown.
233. (A) Crie um sistema de replica√ß√£o de arquivos com deduplica√ß√£o por chunk hashing.
234. (A) Desenvolva um verificador de integridade de backups que valida snapshots por hashes e metadata.
235. (A) Implemente um mini mecanismo de busca sem√¢ntica usando embeddings simples (ex.: bag-of-words ponderado) e ranking.
236. (A) Construa uma ferramenta para comparar dois bancos de dados JSON e gerar script de sincroniza√ß√£o (diff-to-migrations).
237. (A) Implemente uma pipeline de processamento de dados com etapas configur√°veis (extract, transform, load) e monitoramento.
238. (A) Crie um analisador de bin√°rios PE/ELF simples que extrai cabe√ßalhos e se√ß√µes (leitura bin√°ria).
239. (A) Desenvolva um sistema de alertas que dispara a√ß√µes (scripts) quando m√©tricas cruzam thresholds.
240. (A) Implemente um gerenciador de sess√µes distribu√≠do que armazena sess√µes em arquivo com sincroniza√ß√£o eventual.
241. (A) Construa um motor de busca que suporta consultas booleanas (AND, OR, NOT) e ranking simples.
242. (A) Desenvolva um sistema de autoriza√ß√£o baseado em pol√≠ticas (policy engine) com linguagem declarativa m√≠nima.
243. (A) Implemente monitoramento de integridade de processos: supervisionar, reiniciar e reportar falhas.
244. (A) Crie um otimizador de imagens simples que reduz qualidade e tamanho sem bibliotecas externas (trabalhar sobre BMP/PPM simples).
245. (A) Desenvolva uma ferramenta de migra√ß√£o que converte dados CSV para um formato otimizado bin√°rio pr√≥prio e roda opera√ß√µes de qu





Aqui est√° um plano de 250 exerc√≠cios de JavaScript focados apenas em l√≥gica e execu√ß√£o no modo ‚Äúhead‚Äëless‚Äù (Node.js ou console), sem nenhum c√≥digo HTML/CSS.

Dividi os exerc√≠cios em blocos tem√°ticos para que voc√™ possa avan√ßar progressivamente, refor√ßando conceitos fundamentais antes de passar para desafios mais avan√ßados. Cada bloco cont√©m o n√∫mero de exerc√≠cios sugeridos, uma breve descri√ß√£o do objetivo e, quando √∫til, um ponto de partida (esqueleto de c√≥digo) que voc√™ pode copiar e colar no seu editor.

üìö Estrutura dos Blocos
Bloco	Tema	N¬∫ de Exerc√≠cios	Principais Conceitos
1	Fundamentos da Sintaxe	20	Vari√°veis (let, const), tipos primitivos, operadores aritm√©ticos e l√≥gicos, template strings
2	Controle de Fluxo	30	if/else, operador tern√°rio, switch, loops (for, while, do‚Ä¶while)
3	Fun√ß√µes	35	Declara√ß√£o vs express√£o, par√¢metros padr√£o, retorno m√∫ltiplo (objetos/arrays), fun√ß√µes de ordem superior, closures
4	Arrays	40	Cria√ß√£o, m√©todos (push, pop, shift, unshift, splice, slice), itera√ß√£o (forEach, map, filter, reduce), desestrutura√ß√£o
5	Objetos	30	Literais, propriedades din√¢micas, m√©todos, this, desestrutura√ß√£o, spread/rest
6	Strings & RegEx	25	Manipula√ß√£o (split, replace, trim), padr√µes com express√µes regulares, valida√ß√µes simples
7	Data & Hora	15	Date, timestamps, formata√ß√£o b√°sica, c√°lculo de diferen√ßa entre datas
8	Recurs√£o	15	Fun√ß√µes recursivas simples, recurs√£o de cauda, problemas cl√°ssicos (fatorial, fibonacci, √°rvore)
9	Estruturas de Dados Simples	20	Pilhas, filas, listas ligadas (implementa√ß√£o m√≠nima)
10	Algoritmos B√°sicos	25	Ordena√ß√£o (bubble, insertion, quick), busca (linear, bin√°ria), soma acumulada, m√°ximo/m√≠nimo
11	Programa√ß√£o Ass√≠ncrona	20	Callbacks, Promises, async/await, tratamento de erros, temporizadores (setTimeout, setInterval)
12	M√≥dulos & ES6+	10	import/export, m√≥dulos CommonJS (require/module.exports), uso de pacotes NPM simples
13	Testes Unit√°rios	10	Introdu√ß√£o ao Jest ou Mocha, escrita de testes b√°sicos para fun√ß√µes puras
TOTAL	‚Äî	250	‚Äî
Dica: Se quiser gerar automaticamente novos exerc√≠cios a partir desses padr√µes, basta combinar varia√ß√µes de entrada/sa√≠da (por exemplo, trocar valores de arrays ou mudar condi√ß√µes). Isso permite criar infinitas vers√µes ‚Äúpersonalizadas‚Äù.

üöÄ Exemplos de Exerc√≠cios por Bloco
A seguir, mostro alguns exemplos representativos de cada bloco. Voc√™ pode usar esses como modelo para criar os demais.

1Ô∏è‚É£ Fundamentos da Sintaxe (exerc√≠cios 1‚Äë5)
// 1. Trocar valores de duas vari√°veis usando destructuring
let a = 5;
let b = 10;
// TODO: troque os valores sem usar vari√°vel tempor√°ria
[a, b] = [b, a];
console.log(a, b); // 10 5
// 2. Verificar se um n√∫mero √© par ou √≠mpar (operador tern√°rio)
const num = 42;
const tipo = (num % 2 === 0) ? 'par' : '√≠mpar';
console.log(`${num} √© ${tipo}`);
// 3. Concatenar tr√™s strings usando template literals
const nome = 'Ana';
const idade = 27;
const cidade = 'S√£o Paulo';
console.log(`Meu nome √© ${nome}, tenho ${idade} anos e moro em ${cidade}.`);
2Ô∏è‚É£ Controle de Fluxo (exerc√≠cios 21‚Äë25)
// 21. Imprimir n√∫meros de 1 a 100, mas substituir m√∫ltiplos de 3 por "Fizz",
// m√∫ltiplos de 5 por "Buzz" e m√∫ltiplos de ambos por "FizzBuzz".
for (let i = 1; i <= 100 i++) {
  let out = '';
  if (i % 3 === 0) out += 'Fizz';
  if (i % 5 === 0) out += 'Buzz';
  console.log(out || i);
}
// 22. Receber um n√∫mero (1‚Äë7) e imprimir o dia da semana usando switch
function diaDaSemana(num) {
  switch (num) {
    case 1: return 'Domingo';
    case 2: return 'Segunda-feira';
    case 3: return 'Ter√ßa-feira';
    case 4: return 'Quarta-feira';
    case 5: return 'Quinta-feira';
    case 6: return 'Sexta-feira';
    case 7: return 'S√°bado';
    default: return 'N√∫mero inv√°lido';
  }
}
3Ô∏è‚É£ Fun√ß√µes (exerc√≠cios 36‚Äë40)
// 36. Fun√ß√£o que recebe um array e retorna outro contendo apenas os n√∫meros pares
function filtraPares(arr) {
  return arr.filter(n => n % 2 === 0);
}
// 37. Closure que cria um contador independente
function criaContador(inicial = 0) {
  let count = inicial;
  return () => ++count;
}
const contadorA = criaContador();
console.log(contadorA()); // 1
console.log(contadorA()); // 2
4Ô∏è‚É£ Arrays (exerc√≠cios 56‚Äë60)
// 56. Dado um array de objetos {nome, idade}, ordenar por idade ascendente
const pessoas = [{nome:'Bob', idade:34},{nome:'Ada', idade:28},{nome:'Zoe', idade:45}];
pessoas.sort((a,b) => a.idade - b.idade);
console.log(pessoas);
// 57. Reduzir um array de n√∫meros ao seu produto total
const nums = [2,3,4];
const produto = nums.reduce((acc, v) => acc * v, 1);
console.log(produto); // 24
5Ô∏è‚É£ Objetos (exerc√≠cios 86‚Äë90)
// 86. Criar um objeto "carro" com m√©todo que calcula consumo (km/l)
const carro = {
  marca: 'Toyota',
  modelo: 'Corolla',
  kmRodado: 500,
  litrosUsados: 40,
  consumo() {
    return this.kmRodado / this.litrosUsados;
  }
};
console.log(carro.consumo()); // 12.5
6Ô∏è‚É£ Strings & RegEx (exerc√≠cios 111‚Äë115)
// 111. Validar se uma string √© um e‚Äëmail simples (regex b√°sico)
function validaEmail(email) {
  const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return re.test(email);
}
console.log(validaEmail('teste@dominio.com')); // true
7Ô∏è‚É£ Data & Hora (exerc√≠cios 126‚Äë130)
// 126. Calcular a diferen√ßa em dias entre duas datas
function diffDias(data1, data2) {
  const msDia = 24 * 60 * 60 * 1000;
  return Math.abs((data2 - data1) / msDia);
}
const d1 = new Date('2025-01-01');
const d2 = new Date('2025-01-15');
console.log(diffDias(d1, d2)); // 14
8Ô∏è‚É£ Recurs√£o (exerc√≠cios 141‚Äë145)
// 141. Fatorial recursivo
function fatorial(n) {
  if (n <= 1) return 1;
  return n * fatorial(n - 1);
}
console.log(fatorial(5)); // 120
9Ô∏è‚É£ Estruturas de Dados Simples (exerc√≠cios 166‚Äë170)
// 166. Implementar pilha com array
class Pilha {
  constructor() { this.itens = []; }
  push(v) { this.itens.push(v); }
  pop() { return this.itens.pop(); }
  peek() { return this.itens[this.itens.length - 1]; }
  tamanho() { return this.itens.length; }
}
üîü Algoritmos B√°sicos (exerc√≠cios 191‚Äë195)
// 191. Ordena√ß√£o Bubble Sort
function bubbleSort(arr) {
  const a = [...arr];
  for (let i = 0; i < a.length; i++) {
    for (let j = 0; j < a.length - i - 1; j++) {
      if (a[j] > a[j + 1]) [a[j], a[j + 1]] = [a[j + 1], a[j]];
    }
  }
  return a;
}
1Ô∏è‚É£1Ô∏è‚É£ Programa√ß√£o Ass√≠ncrona (exerc√≠cios 216‚Äë220)
// 216. Simular uma chamada ass√≠ncrona que resolve ap√≥s 2 segundos
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
async function exemplo() {
  console.log('Iniciando...');
  await delay(2000);
  console.log('2 segundos depois');
}
exemplo();
1Ô∏è‚É£2Ô∏è‚É£ M√≥dulos & ES6+ (exerc√≠cios 236‚Äë240)
// 236. Exportar e importar fun√ß√£o utilit√°ria (CommonJS)
// utils.js
module.exports.soma = (a,b) => a + b;

// app.js
const { soma } = require('./utils');
console.log(soma(3,4)); // 7
1Ô∏è‚É£3Ô∏è‚É£ Testes Unit√°rios (exerc√≠cios 246‚Äë250)
// 246. Teste simples com Jest para a fun√ß√£o soma acima
// soma.test.js
const { soma } = require('./utils');
test('soma dois n√∫meros positivos', () => {
  expect(soma(2,3)).toBe(5);
});
üìÇ Como Usar Essa Lista
Escolha um bloco que corresponda ao seu n√≠vel atual ou ao conceito que deseja praticar.
Copie o esqueleto (quando houver) para um arquivo .js e execute com node nome.js.
Resolva o ‚ÄúTODO‚Äù ou escreva sua pr√≥pria solu√ß√£o.
Quando terminar, adicione varia√ß√µes (troque valores, aumente o tamanho dos arrays, modifique as condi√ß√µes) para gerar novos exerc√≠cios rapidamente.
Se precisar de mais detalhes sobre algum exerc√≠cio espec√≠fico, de explica√ß√µes passo‚Äëa‚Äëpasso ou de solu√ß√µes completas, √© s√≥ dizer! Estou aqui para ajudar a transformar esses 250 desafios em aprendizado s√≥lido.

Aqui est√£o ideias para 250 exerc√≠cios em JavaScript, focando apenas no modo sem navegador (Node.js ou ambiente console), sem HTML. Eles est√£o organizados por temas para facilitar o estudo:

**1. Vari√°veis e Tipos de Dados**
1. Declare uma vari√°vel num√©rica.
2. Declare uma vari√°vel de texto.
3. Declare uma vari√°vel booleana.
4. Fa√ßa a soma de dois n√∫meros.
5. Fa√ßa a subtra√ß√£o de dois n√∫meros.
6. Multiplique dois n√∫meros.
7. Divida dois n√∫meros.
8. Calcule o resto da divis√£o entre dois n√∫meros.
9. Converta um n√∫mero para string.
10. Converta uma string para n√∫mero.

**2. Operadores**
11. Use operadores de compara√ß√£o (==, ===, !=, !==).
12. Use operadores l√≥gicos (&&, ||, !).
13. Use operador tern√°rio.
14. Incremente uma vari√°vel.
15. Decremente uma vari√°vel.

**3. Entrada e Sa√≠da**
16. Pe√ßa ao usu√°rio para digitar um n√∫mero (use prompt-sync ou readline).
17. Pe√ßa ao usu√°rio para digitar seu nome.
18. Mostre uma mensagem de boas-vindas usando o nome digitado.
19. Mostre o resultado de uma opera√ß√£o matem√°tica.
20. Mostre o tipo de uma vari√°vel usando typeof.

**4. Estruturas de Controle**
21. Fa√ßa um if para verificar se um n√∫mero √© positivo.
22. Fa√ßa um if para verificar se um n√∫mero √© par.
23. Fa√ßa um if-else para verificar se um n√∫mero √© maior que outro.
24. Fa√ßa um switch-case para determinar o dia da semana.
25. Fa√ßa um loop for para imprimir n√∫meros de 1 a 10.
26. Fa√ßa um loop while para contar de 10 a 0.
27. Fa√ßa um loop do-while para pedir ao usu√°rio uma senha at√© acertar.

**5. Fun√ß√µes**
28. Crie uma fun√ß√£o que soma dois n√∫meros.
29. Crie uma fun√ß√£o que retorna o quadrado de um n√∫mero.
30. Crie uma fun√ß√£o que verifica se um n√∫mero √© primo.
31. Crie uma fun√ß√£o que retorna o maior de tr√™s n√∫meros.
32. Crie uma fun√ß√£o que inverte uma string.
33. Crie uma fun√ß√£o que retorna o comprimento de um array.
34. Crie uma fun√ß√£o que recebe um array e retorna a soma dos elementos.
35. Crie uma fun√ß√£o que filtra n√∫meros pares de um array.
36. Crie uma fun√ß√£o que gera uma lista de n√∫meros de 1 a N.
37. Crie uma fun√ß√£o recursiva para calcular fatorial.

**6. Arrays**
38. Crie um array de n√∫meros.
39. Crie um array de nomes.
40. Adicione um elemento ao final de um array.
41. Adicione um elemento no in√≠cio de um array.
42. Remova o √∫ltimo elemento de um array.
43. Remova o primeiro elemento de um array.
44. Encontre o √≠ndice de um elemento em um array.
45. Ordene um array de n√∫meros.
46. Inverta um array.
47. Junte dois arrays em um s√≥.
48. Filtre elementos maiores que 10 de um array.
49. Some todos os elementos do array.
50. Multiplique todos os elementos do array.

**7. Objetos**
51. Crie um objeto representando uma pessoa.
52. Acesse uma propriedade de um objeto.
53. Adicione uma propriedade a um objeto.
54. Remova uma propriedade de um objeto.
55. Liste todas as propriedades de um objeto.
56. Crie um array de objetos.
57. Filtre objetos por uma propriedade.
58. Atualize uma propriedade de um objeto.
59. Crie um m√©todo em um objeto.
60. Copie um objeto usando spread.

**8. Strings**
61. Junte duas strings.
62. Separe uma string por espa√ßos.
63. Converta uma string para mai√∫sculas.
64. Converta uma string para min√∫sculas.
65. Remova espa√ßos do in√≠cio e fim de uma string.
66. Substitua parte de uma string por outra.
67. Conte quantas vezes uma letra aparece em uma string.
68. Verifique se uma string come√ßa com determinada letra.
69. Verifique se uma string termina com determinada letra.
70. Pegue um peda√ßo de uma string (substring).

**9. Datas**
71. Mostre a data atual.
72. Mostre o ano atual.
73. Mostre o m√™s atual.
74. Mostre o dia da semana atual.
75. Calcule a diferen√ßa entre duas datas.
76. Adicione dias a uma data.
77. Formate uma data como ‚ÄúDD/MM/AAAA‚Äù.
78. Verifique se um ano √© bissexto.

**10. Matem√°tica**
79. Calcule a raiz quadrada de um n√∫mero.
80. Calcule o valor absoluto de um n√∫mero.
81. Arredonde um n√∫mero para cima.
82. Arredonde um n√∫mero para baixo.
83. Gere um n√∫mero aleat√≥rio entre 1 e 100.
84. Calcule o seno de um n√∫mero.
85. Calcule o cosseno de um n√∫mero.
86. Calcule o logaritmo de um n√∫mero.

**11. Convers√£o de tipos**
87. Converta n√∫mero para booleano.
88. Converta booleano para n√∫mero.
89. Converta string para booleano.
90. Converta array para string.
91. Converta objeto para array de pares.

**12. Manipula√ß√£o de arquivos** *(Node.js)*
92. Leia um arquivo de texto.
93. Escreva em um arquivo de texto.
94. Liste arquivos de um diret√≥rio.
95. Apague um arquivo.
96. Renomeie um arquivo.
97. Leia um arquivo JSON.
98. Escreva um arquivo JSON.

**13. Tratamento de erros**
99. Use try-catch para tratar erro de divis√£o por zero.
100. Lance um erro personalizado.
101. Trate erro ao ler arquivo inexistente.

**14. Algoritmos cl√°ssicos**
102. Fa√ßa a ordena√ß√£o bubble sort.
103. Fa√ßa a ordena√ß√£o selection sort.
104. Fa√ßa a ordena√ß√£o insertion sort.
105. Implemente busca bin√°ria.
106. Implemente busca linear.
107. Gere a sequ√™ncia de Fibonacci.
108. Verifique se uma palavra √© pal√≠ndromo.
109. Gere todos os anagramas de uma palavra.
110. Calcule MDC de dois n√∫meros.
111. Calcule MMC de dois n√∫meros.

**15. Exerc√≠cios l√≥gicos**
112. Verifique se tr√™s lados formam um tri√¢ngulo.
113. Classifique tri√¢ngulo: equil√°tero, is√≥sceles, escaleno.
114. Calcule √°rea de um c√≠rculo.
115. Calcule √°rea de um tri√¢ngulo.
116. Calcule √°rea de um ret√¢ngulo.
117. Calcule √°rea de um trap√©zio.
118. Calcule per√≠metro de um pol√≠gono.

**16. Listas e manipula√ß√£o**
119. Remova elementos duplicados de um array.
120. Conte elementos √∫nicos de um array.
121. Crie um array bidimensional (matriz).
122. Some os elementos de uma matriz.
123. Encontre maior valor em matriz.
124. Transponha uma matriz.

**17. Recurs√£o**
125. Fa√ßa fatorial recursivo.
126. Fa√ßa Fibonacci recursivo.
127. Fa√ßa busca em √°rvore bin√°ria recursiva.
128. Crie fun√ß√£o recursiva para pot√™ncia.

**18. Programa√ß√£o funcional**
129. Use map para dobrar elementos de um array.
130. Use filter para selecionar √≠mpares.
131. Use reduce para somar elementos.
132. Use find para achar elemento espec√≠fico.
133. Use every para verificar se todos s√£o positivos.
134. Use some para verificar se algum √© negativo.

**19. Modulariza√ß√£o**
135. Crie um m√≥dulo para opera√ß√µes matem√°ticas.
136. Importe e use m√≥dulo em outro arquivo.
137. Exporte fun√ß√£o de um arquivo.
138. Exporte objeto de um arquivo.

**20. Promises e async/await**
139. Crie uma promise simples.
140. Use .then e .catch para tratar promise.
141. Crie fun√ß√£o async que retorna resultado ap√≥s 1s.
142. Fa√ßa chamada ass√≠ncrona para ler arquivo.
143. Trate erro em fun√ß√£o async.

**21. Estruturas de dados**
144. Implemente pilha (stack).
145. Implemente fila (queue).
146. Implemente lista encadeada simples.
147. Implemente √°rvore bin√°ria de busca.
148. Implemente grafo simples (adjac√™ncia).
149. Fa√ßa busca em largura (BFS).
150. Fa√ßa busca em profundidade (DFS).

**22. Simula√ß√µes**
151. Simule lan√ßamento de dados.
152. Simule sorteio de n√∫meros.
153. Simule sistema de senhas.
154. Simule cadastro de usu√°rios.
155. Simule sistema banc√°rio simples.

**23. Exerc√≠cios de l√≥gica de programa√ß√£o**
156. Troque valores de duas vari√°veis.
157. Inverta uma lista.
158. Encontre segundos em uma quantidade de minutos.
159. Converta Celsius para Fahrenheit.
160. Converta Fahrenheit para Celsius.

**24. Exerc√≠cios com objetos**
161. Crie objeto livro com t√≠tulo, autor, ano.
162. Liste livros publicados ap√≥s 2000.
163. Atualize t√≠tulo de um livro.
164. Remova livro por t√≠tulo.
165. Ordene lista de livros por ano.

**25. Exerc√≠cios de manipula√ß√£o de arrays**
166. Crie fun√ß√£o para remover elemento pelo √≠ndice.
167. Crie fun√ß√£o para inserir elemento em posi√ß√£o espec√≠fica.
168. Crie fun√ß√£o para copiar array sem refer√™ncia.
169. Crie fun√ß√£o para mesclar dois arrays sem duplicados.
170. Crie fun√ß√£o para dividir array em dois.

**26. Exerc√≠cios matem√°ticos**
171. Calcule m√©dia aritm√©tica de array.
172. Calcule moda.
173. Calcule mediana.
174. Calcule desvio padr√£o.
175. Calcule porcentagem.

**27. Exerc√≠cios com strings**
176. Remova vogais de uma string.
177. Remova consoantes de uma string.
178. Conte palavras em uma frase.
179. Separe frase em palavras.
180. Gere acr√¥nimo de uma frase.

**28. Exerc√≠cios com datas**
181. Calcule idade a partir de data de nascimento.
182. Calcule dias entre duas datas.
183. Formate data para ‚ÄúYYYY-MM-DD‚Äù.
184. Adicione um m√™s a uma data.

**29. Exerc√≠cios de l√≥gica**
185. Resolva o problema das Torres de Hanoi (recursivo).
186. Gere sudoku v√°lido (simples).
187. Resolva sudoku (simples).
188. Simule jogo da velha.
189. Simule jogo de adivinha√ß√£o.

**30. Exerc√≠cios de manipula√ß√£o de arquivos**
190. Conte linhas em arquivo de texto.
191. Conte palavras em arquivo de texto.
192. Procure palavra em arquivo de texto.
193. Substitua palavra em arquivo de texto.

**31. Exerc√≠cios avan√ßados**
194. Crie um CRUD simples em mem√≥ria (array de objetos).
195. Implemente sistema de login simples.
196. Implemente sistema de cadastro com valida√ß√µes.
197. Implemente sistema de notas escolares.
198. Implemente lista de tarefas (to-do).

**32. Exerc√≠cios com fun√ß√µes**
199. Crie fun√ß√£o que retorna fun√ß√£o (closure).
200. Crie fun√ß√£o que soma v√°rios n√∫meros (rest).
201. Crie fun√ß√£o que aceita callback.

**33. Exerc√≠cios de ordena√ß√£o**
202. Ordene array de strings por tamanho.
203. Ordene array de objetos por propriedade.
204. Ordene array de n√∫meros decrescente.

**34. Exerc√≠cios com regex**
205. Valide e-mail com regex.
206. Valide CPF com regex.
207. Extraia n√∫meros de uma string.
208. Extraia palavras de uma frase.

**35. Exerc√≠cios de l√≥gica**
209. Resolva problema de l√≥gica com operadores AND, OR, NOT.
210. Simule sem√°foro com switch-case.
211. Simule rel√≥gio digital.

**36. Exerc√≠cios com JSON**
212. Converta objeto para JSON.
213. Converta JSON para objeto.
214. Filtre objetos de um array JSON.

**37. Exerc√≠cios com Map e Set**
215. Crie Map para pares chave-valor.
216. Crie Set para valores √∫nicos.
217. Adicione e remova itens de Map.
218. Adicione e remova itens de Set.

**38. Exerc√≠cios com Symbol**
219. Crie Symbol √∫nico.
220. Use Symbol como chave de propriedade.

**39. Exerc√≠cios com fun√ß√µes de ordem superior**
221. Crie fun√ß√£o que recebe outra fun√ß√£o como argumento.
222. Crie fun√ß√£o que retorna outra fun√ß√£o.

**40. Exerc√≠cios de simula√ß√£o**
223. Simule sorteio de nomes.
224. Simule busca de produtos em estoque.

**41. Exerc√≠cios com estruturas condicionais**
225. Verifique se n√∫mero est√° dentro de intervalo.
226. Valide senha com regras espec√≠ficas.

**42. Exerc√≠cios com n√∫meros**
227. Arredonde n√∫mero para duas casas decimais.
228. Gere n√∫mero aleat√≥rio inteiro.
229. Gere n√∫mero aleat√≥rio com casas decimais.

**43. Exerc√≠cios com l√≥gica condicional**
230. Verifique se ano √© bissexto.
231. Verifique se palavra √© pal√≠ndromo.

**44. Exerc√≠cios com arrays**
232. Gere array com N elementos aleat√≥rios.
233. Remova elemento em array por valor.

**45. Exerc√≠cios extras**
234. Crie fun√ß√£o para contar caracteres diferentes em string.
235. Crie fun√ß√£o para encontrar todos os divisores de um n√∫mero.
236. Crie fun√ß√£o para verificar se n√∫mero √© perfeito.
237. Crie fun√ß√£o para converter n√∫mero romano para decimal.
238. Crie fun√ß√£o para converter decimal para romano.

**46. Exerc√≠cios de manipula√ß√£o de objetos**
239. Crie fun√ß√£o para mesclar dois objetos.
240. Crie fun√ß√£o para remover propriedades nulas de objeto.
241. Crie fun√ß√£o para contar propriedades de objeto.

**47. Exerc√≠cios com fun√ß√µes**
242. Crie fun√ß√£o que retorna array de fun√ß√µes.
243. Crie fun√ß√£o que executa v√°rias fun√ß√µes em sequ√™ncia.

**48. Exerc√≠cios de l√≥gica**
244. Calcule valor de express√£o matem√°tica (parser simples).
245. Implemente algoritmo de criptografia simples (Cesar).
246. Implemente algoritmo de decodifica√ß√£o Cesar.

**49. Exerc√≠cios com arrays**
247. Crie array de arrays (matriz).
248. Some elementos por linha de matriz.

**50. Exerc√≠cios finais**
249. Implemente agenda de contatos em mem√≥ria.
250. Implemente calculadora de opera√ß√µes b√°sicas (soma, subtra√ß√£o, multiplica√ß√£o, divis√£o).

Se precisar do c√≥digo de algum exerc√≠cio espec√≠fico, pe√ßa pelo n√∫mero ou descri√ß√£o!


# Cole√ß√£o Completa de 250 Exerc√≠cios de JavaScript (Node.js)

Esta cole√ß√£o abrangente apresenta 250 exerc√≠cios de JavaScript, cuidadosamente elaborados para serem executados em um ambiente Node.js. O foco principal √© a l√≥gica de programa√ß√£o e a manipula√ß√£o de dados, sem a necessidade de um navegador web ou HTML. Os exerc√≠cios s√£o organizados em tr√™s n√≠veis de dificuldade ‚Äì B√°sico, Intermedi√°rio e Avan√ßado ‚Äì para proporcionar uma jornada de aprendizado progressiva e desafiadora.

Cada exerc√≠cio segue uma estrutura padronizada para facilitar a compreens√£o e a resolu√ß√£o:

*   **T√≠tulo do Exerc√≠cio**: Um nome descritivo para o problema.
*   **Descri√ß√£o do Problema**: Detalhes sobre o que o exerc√≠cio deve resolver.
*   **Entrada (Input)**: Exemplos de dados de entrada para a fun√ß√£o ou l√≥gica.
*   **Sa√≠da Esperada (Output)**: Exemplos da sa√≠da esperada com base na entrada fornecida.
*   **Restri√ß√µes/Observa√ß√µes**: Condi√ß√µes especiais, dicas ou requisitos adicionais.
*   **Solu√ß√£o (Opcional)**: Um esqueleto de fun√ß√£o ou uma solu√ß√£o completa para guiar o desenvolvimento ou para verifica√ß√£o.

Estes exerc√≠cios s√£o ideais para estudantes, desenvolvedores iniciantes e at√© mesmo para profissionais experientes que desejam aprimorar suas habilidades em JavaScript puro e algoritmos. A pr√°tica regular com estes problemas ajudar√° a solidificar o conhecimento da linguagem e a desenvolver o racioc√≠nio l√≥gico necess√°rio para resolver desafios de programa√ß√£o complexos.

---



# Exerc√≠cios de JavaScript - N√≠vel B√°sico (1-80)

Esta se√ß√£o cont√©m 80 exerc√≠cios de JavaScript focados em conceitos fundamentais da linguagem, projetados para serem executados em um ambiente Node.js, sem a necessidade de um navegador ou HTML.

## Estrutura dos Exerc√≠cios

Cada exerc√≠cio segue a estrutura definida no plano:

*   **T√≠tulo do Exerc√≠cio**: Nome do exerc√≠cio.
*   **Descri√ß√£o do Problema**: O que o exerc√≠cio deve resolver.
*   **Entrada (Input)**: Exemplos de dados de entrada.
*   **Sa√≠da Esperada (Output)**: Exemplos da sa√≠da esperada.
*   **Restri√ß√µes/Observa√ß√µes**: Condi√ß√µes especiais.
*   **Solu√ß√£o (Opcional)**: Esqueleto de fun√ß√£o ou solu√ß√£o completa.

---

### Exerc√≠cio 1: Declarar e Atribuir Vari√°veis

**Descri√ß√£o do Problema**: Declare tr√™s vari√°veis: `nome` (string), `idade` (number) e `estaAtivo` (boolean). Atribua valores a elas e imprima cada uma no console.

**Entrada (Input)**:
N√£o h√° entrada direta para este exerc√≠cio, os valores s√£o atribu√≠dos internamente.

**Sa√≠da Esperada (Output)**:
```
Nome: Jo√£o
Idade: 30
Ativo: true
```
(Os valores podem variar dependendo da atribui√ß√£o)

**Restri√ß√µes/Observa√ß√µes**: Utilize `let` ou `const` para a declara√ß√£o das vari√°veis.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio1() {
  // Declare e atribua as vari√°veis aqui
  let nome = "Jo√£o";
  let idade = 30;
  let estaAtivo = true;

  console.log("Nome: " + nome);
  console.log("Idade: " + idade);
  console.log("Ativo: " + estaAtivo);
}

// Para testar:
// exercicio1();
```

---

### Exerc√≠cio 2: Opera√ß√µes Aritm√©ticas B√°sicas

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba dois n√∫meros como par√¢metros e retorne a soma, subtra√ß√£o, multiplica√ß√£o e divis√£o desses n√∫meros. Imprima os resultados.

**Entrada (Input)**:
```
numero1 = 10
numero2 = 5
```

**Sa√≠da Esperada (Output)**:
```
Soma: 15
Subtra√ß√£o: 5
Multiplica√ß√£o: 50
Divis√£o: 2
```

**Restri√ß√µes/Observa√ß√µes**: Considere que o segundo n√∫mero nunca ser√° zero para a divis√£o.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio2(numero1, numero2) {
  let soma = numero1 + numero2;
  let subtracao = numero1 - numero2;
  let multiplicacao = numero1 * numero2;
  let divisao = numero1 / numero2;

  console.log("Soma: " + soma);
  console.log("Subtra√ß√£o: " + subtracao);
  console.log("Multiplica√ß√£o: " + multiplicacao);
  console.log("Divis√£o: " + divisao);
}

// Para testar:
// exercicio2(10, 5);
```

---

### Exerc√≠cio 3: Concatena√ß√£o de Strings

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um primeiro nome e um sobrenome como par√¢metros e retorne o nome completo formatado como "Sobrenome, Nome".

**Entrada (Input)**:
```
primeiroNome = "Maria"
sobrenome = "Silva"
```

**Sa√≠da Esperada (Output)**:
```
Silva, Maria
```

**Restri√ß√µes/Observa√ß√µes**: Utilize o operador `+` ou template literals para a concatena√ß√£o.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio3(primeiroNome, sobrenome) {
  let nomeCompleto = sobrenome + ", " + primeiroNome;
  // Ou usando template literals:
  // let nomeCompleto = `${sobrenome}, ${primeiroNome}`;
  return nomeCompleto;
}

// Para testar:
// console.log(exercicio3("Maria", "Silva"));
```

---

### Exerc√≠cio 4: Verifica√ß√£o de N√∫mero Par ou √çmpar

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um n√∫mero inteiro como par√¢metro e retorne se ele √© par ou √≠mpar.

**Entrada (Input)**:
```
numero = 7
```

**Sa√≠da Esperada (Output)**:
```
√çmpar
```

**Restri√ß√µes/Observa√ß√µes**: Utilize o operador de m√≥dulo (`%`).

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio4(numero) {
  if (numero % 2 === 0) {
    return "Par";
  } else {
    return "√çmpar";
  }
}

// Para testar:
// console.log(exercicio4(7)); // Sa√≠da: √çmpar
// console.log(exercicio4(10)); // Sa√≠da: Par
```

---

### Exerc√≠cio 5: Maior de Dois N√∫meros

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba dois n√∫meros como par√¢metros e retorne o maior entre eles.

**Entrada (Input)**:
```
num1 = 25
num2 = 18
```

**Sa√≠da Esperada (Output)**:
```
25
```

**Restri√ß√µes/Observa√ß√µes**: Utilize uma estrutura condicional `if/else` ou o operador tern√°rio.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio5(num1, num2) {
  if (num1 > num2) {
    return num1;
  } else {
    return num2;
  }
  // Ou com operador tern√°rio:
  // return (num1 > num2) ? num1 : num2;
}

// Para testar:
// console.log(exercicio5(25, 18)); // Sa√≠da: 25
// console.log(exercicio5(10, 30)); // Sa√≠da: 30
```

---

### Exerc√≠cio 6: Soma dos Elementos de um Array

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array de n√∫meros como par√¢metro e retorne a soma de todos os seus elementos.

**Entrada (Input)**:
```
array = [1, 2, 3, 4, 5]
```

**Sa√≠da Esperada (Output)**:
```
15
```

**Restri√ß√µes/Observa√ß√µes**: O array conter√° apenas n√∫meros. Utilize um loop `for` ou `forEach`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio6(array) {
  let soma = 0;
  for (let i = 0; i < array.length; i++) {
    soma += array[i];
  }
  // Ou com forEach:
  // array.forEach(numero => { soma += numero; });
  return soma;
}

// Para testar:
// console.log(exercicio6([1, 2, 3, 4, 5])); // Sa√≠da: 15
// console.log(exercicio6([10, 20, 30])); // Sa√≠da: 60
```

---

### Exerc√≠cio 7: Inverter uma String

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba uma string como par√¢metro e retorne a string invertida.

**Entrada (Input)**:
```
texto = "hello"
```

**Sa√≠da Esperada (Output)**:
```
olleh
```

**Restri√ß√µes/Observa√ß√µes**: Utilize m√©todos de string e array.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio7(texto) {
  return texto.split(\'\').reverse().join(\'\');
}

// Para testar:
// console.log(exercicio7("hello")); // Sa√≠da: olleh
// console.log(exercicio7("JavaScript")); // Sa√≠da: tpircSavaJ
```

---

### Exerc√≠cio 8: Contar Vogais em uma String

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba uma string como par√¢metro e retorne o n√∫mero de vogais (a, e, i, o, u, mai√∫sculas e min√∫sculas) presentes nela.

**Entrada (Input)**:
```
frase = "Programacao"
```

**Sa√≠da Esperada (Output)**:
```
5
```

**Restri√ß√µes/Observa√ß√µes**: Considere apenas as vogais padr√£o do alfabeto latino.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio8(frase) {
  let count = 0;
  const vogais = "aeiouAEIOU";
  for (let i = 0; i < frase.length; i++) {
    if (vogais.includes(frase[i])) {
      count++;
    }
  }
  return count;
}

// Para testar:
// console.log(exercicio8("Programacao")); // Sa√≠da: 5
// console.log(exercicio8("JavaScript")); // Sa√≠da: 3
```

---

### Exerc√≠cio 9: Calcular Fatorial

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um n√∫mero inteiro n√£o negativo como par√¢metro e retorne o seu fatorial.

**Entrada (Input)**:
```
numero = 5
```

**Sa√≠da Esperada (Output)**:
```
120
```

**Restri√ß√µes/Observa√ß√µes**: O fatorial de 0 √© 1. Utilize um loop `for`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio9(numero) {
  if (numero === 0) {
    return 1;
  }
  let fatorial = 1;
  for (let i = 1; i <= numero; i++) {
    fatorial *= i;
  }
  return fatorial;
}

// Para testar:
// console.log(exercicio9(5)); // Sa√≠da: 120
// console.log(exercicio9(0)); // Sa√≠da: 1
// console.log(exercicio9(3)); // Sa√≠da: 6
```

---

### Exerc√≠cio 10: Verificar Pal√≠ndromo

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba uma string como par√¢metro e retorne `true` se ela for um pal√≠ndromo (l√™-se da mesma forma de tr√°s para frente) e `false` caso contr√°rio. Ignore espa√ßos e a capitaliza√ß√£o.

**Entrada (Input)**:
```
texto = "Arara"
```

**Sa√≠da Esperada (Output)**:
```
true
```

**Restri√ß√µes/Observa√ß√µes**: Converta a string para min√∫sculas e remova espa√ßos antes de verificar.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio10(texto) {
  const formatado = texto.toLowerCase().replace(/\s/g, \'\');
  const invertido = formatado.split(\'\').reverse().join(\'\');
  return formatado === invertido;
}

// Para testar:
// console.log(exercicio10("Arara")); // Sa√≠da: true
// console.log(exercicio10("Ame o poema")); // Sa√≠da: true
// console.log(exercicio10("Hello")); // Sa√≠da: false
```

---

### Exerc√≠cio 11: Encontrar o Maior Elemento em um Array

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array de n√∫meros e retorne o maior n√∫mero presente no array.

**Entrada (Input)**:
```
numeros = [3, 8, 1, 9, 4]
```

**Sa√≠da Esperada (Output)**:
```
9
```

**Restri√ß√µes/Observa√ß√µes**: O array n√£o estar√° vazio. Utilize um loop `for`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio11(numeros) {
  let maior = numeros[0];
  for (let i = 1; i < numeros.length; i++) {
    if (numeros[i] > maior) {
      maior = numeros[i];
    }
  }
  return maior;
  // Ou usando Math.max e spread operator:
  // return Math.max(...numeros);
}

// Para testar:
// console.log(exercicio11([3, 8, 1, 9, 4])); // Sa√≠da: 9
// console.log(exercicio11([-5, -1, -10])); // Sa√≠da: -1
```

---

### Exerc√≠cio 12: Encontrar o Menor Elemento em um Array

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array de n√∫meros e retorne o menor n√∫mero presente no array.

**Entrada (Input)**:
```
numeros = [3, 8, 1, 9, 4]
```

**Sa√≠da Esperada (Output)**:
```
1
```

**Restri√ß√µes/Observa√ß√µes**: O array n√£o estar√° vazio. Utilize um loop `for`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio12(numeros) {
  let menor = numeros[0];
  for (let i = 1; i < numeros.length; i++) {
    if (numeros[i] < menor) {
      menor = numeros[i];
    }
  }
  return menor;
  // Ou usando Math.min e spread operator:
  // return Math.min(...numeros);
}

// Para testar:
// console.log(exercicio12([3, 8, 1, 9, 4])); // Sa√≠da: 1
// console.log(exercicio12([-5, -1, -10])); // Sa√≠da: -10
```

---

### Exerc√≠cio 13: Remover Duplicatas de um Array

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array e retorne um novo array contendo apenas os elementos √∫nicos, removendo duplicatas.

**Entrada (Input)**:
```
array = [1, 2, 2, 3, 4, 4, 5]
```

**Sa√≠da Esperada (Output)**:
```
[1, 2, 3, 4, 5]
```

**Restri√ß√µes/Observa√ß√µes**: A ordem dos elementos √∫nicos pode ser mantida ou n√£o, dependendo da implementa√ß√£o.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio13(array) {
  return [...new Set(array)];
  // Ou com filter e indexOf:
  // return array.filter((item, index) => array.indexOf(item) === index);
}

// Para testar:
// console.log(exercicio13([1, 2, 2, 3, 4, 4, 5])); // Sa√≠da: [1, 2, 3, 4, 5]
// console.log(exercicio13(["a", "b", "a", "c"])); // Sa√≠da: ["a", "b", "c"]
```

---

### Exerc√≠cio 14: Contar Ocorr√™ncias de um Caractere

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba uma string e um caractere como par√¢metros e retorne o n√∫mero de vezes que o caractere aparece na string (case-insensitive).

**Entrada (Input)**:
```
texto = "Banana"
caractere = "a"
```

**Sa√≠da Esperada (Output)**:
```
3
```

**Restri√ß√µes/Observa√ß√µes**: Converta ambos para min√∫sculas antes de comparar.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio14(texto, caractere) {
  let count = 0;
  const textoLower = texto.toLowerCase();
  const caractereLower = caractere.toLowerCase();
  for (let i = 0; i < textoLower.length; i++) {
    if (textoLower[i] === caractereLower) {
      count++;
    }
  }
  return count;
}

// Para testar:
// console.log(exercicio14("Banana", "a")); // Sa√≠da: 3
// console.log(exercicio14("JavaScript", "A")); // Sa√≠da: 2
```

---

### Exerc√≠cio 15: Calcular M√©dia de um Array de N√∫meros

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array de n√∫meros e retorne a m√©dia aritm√©tica dos seus elementos.

**Entrada (Input)**:
```
numeros = [10, 20, 30, 40]
```

**Sa√≠da Esperada (Output)**:
```
25
```

**Restri√ß√µes/Observa√ß√µes**: O array n√£o estar√° vazio. Retorne 0 se o array estiver vazio.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio15(numeros) {
  if (numeros.length === 0) {
    return 0;
  }
  let soma = 0;
  for (let i = 0; i < numeros.length; i++) {
    soma += numeros[i];
  }
  return soma / numeros.length;
  // Ou com reduce:
  // return numeros.reduce((acc, curr) => acc + curr, 0) / numeros.length;
}

// Para testar:
// console.log(exercicio15([10, 20, 30, 40])); // Sa√≠da: 25
// console.log(exercicio15([])); // Sa√≠da: 0
```

---

### Exerc√≠cio 16: Converter Celsius para Fahrenheit

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba uma temperatura em Celsius e a converta para Fahrenheit. A f√≥rmula √© `F = C * 9/5 + 32`.

**Entrada (Input)**:
```
celsius = 25
```

**Sa√≠da Esperada (Output)**:
```
77
```

**Restri√ß√µes/Observa√ß√µes**: Retorne um n√∫mero.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio16(celsius) {
  return (celsius * 9/5) + 32;
}

// Para testar:
// console.log(exercicio16(25)); // Sa√≠da: 77
// console.log(exercicio16(0)); // Sa√≠da: 32
```

---

### Exerc√≠cio 17: Converter Fahrenheit para Celsius

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba uma temperatura em Fahrenheit e a converta para Celsius. A f√≥rmula √© `C = (F - 32) * 5/9`.

**Entrada (Input)**:
```
fahrenheit = 77
```

**Sa√≠da Esperada (Output)**:
```
25
```

**Restri√ß√µes/Observa√ß√µes**: Retorne um n√∫mero.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio17(fahrenheit) {
  return (fahrenheit - 32) * 5/9;
}

// Para testar:
// console.log(exercicio17(77)); // Sa√≠da: 25
// console.log(exercicio17(32)); // Sa√≠da: 0
```

---

### Exerc√≠cio 18: Gerar N√∫meros Pares at√© N

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um n√∫mero inteiro `N` como par√¢metro e retorne um array contendo todos os n√∫meros pares de 1 at√© `N` (inclusive).

**Entrada (Input)**:
```
N = 10
```

**Sa√≠da Esperada (Output)**:
```
[2, 4, 6, 8, 10]
```

**Restri√ß√µes/Observa√ß√µes**: `N` ser√° um n√∫mero positivo. Se `N` for menor que 2, retorne um array vazio.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio18(N) {
  const pares = [];
  for (let i = 1; i <= N; i++) {
    if (i % 2 === 0) {
      pares.push(i);
    }
  }
  return pares;
}

// Para testar:
// console.log(exercicio18(10)); // Sa√≠da: [2, 4, 6, 8, 10]
// console.log(exercicio18(5)); // Sa√≠da: [2, 4]
// console.log(exercicio18(1)); // Sa√≠da: []
```

---

### Exerc√≠cio 19: Gerar N√∫meros √çmpares at√© N

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um n√∫mero inteiro `N` como par√¢metro e retorne um array contendo todos os n√∫meros √≠mpares de 1 at√© `N` (inclusive).

**Entrada (Input)**:
```
N = 10
```

**Sa√≠da Esperada (Output)**:
```
[1, 3, 5, 7, 9]
```

**Restri√ß√µes/Observa√ß√µes**: `N` ser√° um n√∫mero positivo.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio19(N) {
  const impares = [];
  for (let i = 1; i <= N; i++) {
    if (i % 2 !== 0) {
      impares.push(i);
    }
  }
  return impares;
}

// Para testar:
// console.log(exercicio19(10)); // Sa√≠da: [1, 3, 5, 7, 9]
// console.log(exercicio19(5)); // Sa√≠da: [1, 3, 5]
```

---

### Exerc√≠cio 20: Calcular Pot√™ncia

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba dois n√∫meros, `base` e `expoente`, e retorne o resultado da `base` elevada ao `expoente`.

**Entrada (Input)**:
```
base = 2
expoente = 3
```

**Sa√≠da Esperada (Output)**:
```
8
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `Math.pow()` ou o operador `**`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio20(base, expoente) {
  return Math.pow(base, expoente);
  // Ou com operador **:
  // return base ** expoente;
}

// Para testar:
// console.log(exercicio20(2, 3)); // Sa√≠da: 8
// console.log(exercicio20(5, 2)); // Sa√≠da: 25
```

---

### Exerc√≠cio 21: Converter String para Mai√∫sculas

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba uma string e retorne a mesma string com todos os caracteres em mai√∫sculas.

**Entrada (Input)**:
```
texto = "javascript"
```

**Sa√≠da Esperada (Output)**:
```
JAVASCRIPT
```

**Restri√ß√µes/Observa√ß√µes**: Utilize o m√©todo `toUpperCase()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio21(texto) {
  return texto.toUpperCase();
}

// Para testar:
// console.log(exercicio21("javascript")); // Sa√≠da: JAVASCRIPT
// console.log(exercicio21("Hello World")); // Sa√≠da: HELLO WORLD
```

---

### Exerc√≠cio 22: Converter String para Min√∫sculas

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba uma string e retorne a mesma string com todos os caracteres em min√∫sculas.

**Entrada (Input)**:
```
texto = "JAVASCRIPT"
```

**Sa√≠da Esperada (Output)**:
```
javascript
```

**Restri√ß√µes/Observa√ß√µes**: Utilize o m√©todo `toLowerCase()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio22(texto) {
  return texto.toLowerCase();
}

// Para testar:
// console.log(exercicio22("JAVASCRIPT")); // Sa√≠da: javascript
// console.log(exercicio22("Hello World")); // Sa√≠da: hello world
```

---

### Exerc√≠cio 23: Retornar o Primeiro Elemento de um Array

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array e retorne o seu primeiro elemento.

**Entrada (Input)**:
```
array = [10, 20, 30]
```

**Sa√≠da Esperada (Output)**:
```
10
```

**Restri√ß√µes/Observa√ß√µes**: O array n√£o estar√° vazio.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio23(array) {
  return array[0];
}

// Para testar:
// console.log(exercicio23([10, 20, 30])); // Sa√≠da: 10
// console.log(exercicio23(["a", "b", "c"])); // Sa√≠da: "a"
```

---

### Exerc√≠cio 24: Retornar o √öltimo Elemento de um Array

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array e retorne o seu √∫ltimo elemento.

**Entrada (Input)**:
```
array = [10, 20, 30]
```

**Sa√≠da Esperada (Output)**:
```
30
```

**Restri√ß√µes/Observa√ß√µes**: O array n√£o estar√° vazio.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio24(array) {
  return array[array.length - 1];
}

// Para testar:
// console.log(exercicio24([10, 20, 30])); // Sa√≠da: 30
// console.log(exercicio24(["a", "b", "c"])); // Sa√≠da: "c"
```

---

### Exerc√≠cio 25: Verificar se um Elemento Existe em um Array

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array e um elemento, e retorne `true` se o elemento estiver presente no array, `false` caso contr√°rio.

**Entrada (Input)**:
```
array = [1, 2, 3, 4, 5]
elemento = 3
```

**Sa√≠da Esperada (Output)**:
```
true
```

**Restri√ß√µes/Observa√ß√µes**: Utilize o m√©todo `includes()` ou um loop `for`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio25(array, elemento) {
  return array.includes(elemento);
  // Ou com loop for:
  // for (let i = 0; i < array.length; i++) {
  //   if (array[i] === elemento) {
  //     return true;
  //   }
  // }
  // return false;
}

// Para testar:
// console.log(exercicio25([1, 2, 3, 4, 5], 3)); // Sa√≠da: true
// console.log(exercicio25([1, 2, 3, 4, 5], 6)); // Sa√≠da: false
```

---

### Exerc√≠cio 26: Multiplicar Todos os Elementos de um Array por um Fator

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array de n√∫meros e um fator, e retorne um novo array onde cada elemento do original foi multiplicado pelo fator.

**Entrada (Input)**:
```
numeros = [1, 2, 3]
fator = 2
```

**Sa√≠da Esperada (Output)**:
```
[2, 4, 6]
```

**Restri√ß√µes/Observa√ß√µes**: Utilize o m√©todo `map()` ou um loop `for`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio26(numeros, fator) {
  return numeros.map(numero => numero * fator);
  // Ou com loop for:
  // const novoArray = [];
  // for (let i = 0; i < numeros.length; i++) {
  //   novoArray.push(numeros[i] * fator);
  // }
  // return novoArray;
}

// Para testar:
// console.log(exercicio26([1, 2, 3], 2)); // Sa√≠da: [2, 4, 6]
// console.log(exercicio26([5, 10], 3)); // Sa√≠da: [15, 30]
```

---

### Exerc√≠cio 27: Filtrar N√∫meros Maiores que um Valor

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array de n√∫meros e um valor limite, e retorne um novo array contendo apenas os n√∫meros do original que s√£o maiores que o valor limite.

**Entrada (Input)**:
```
numeros = [10, 5, 20, 15, 25]
limite = 15
```

**Sa√≠da Esperada (Output)**:
```
[20, 25]
```

**Restri√ß√µes/Observa√ß√µes**: Utilize o m√©todo `filter()` ou um loop `for`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio27(numeros, limite) {
  return numeros.filter(numero => numero > limite);
  // Ou com loop for:
  // const novoArray = [];
  // for (let i = 0; i < numeros.length; i++) {
  //   if (numeros[i] > limite) {
  //     novoArray.push(numeros[i]);
  //   }
  // }
  // return novoArray;
}

// Para testar:
// console.log(exercicio27([10, 5, 20, 15, 25], 15)); // Sa√≠da: [20, 25]
// console.log(exercicio27([1, 2, 3], 5)); // Sa√≠da: []
```

---

### Exerc√≠cio 28: Calcular a Raiz Quadrada de um N√∫mero

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um n√∫mero n√£o negativo e retorne a sua raiz quadrada.

**Entrada (Input)**:
```
numero = 16
```

**Sa√≠da Esperada (Output)**:
```
4
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `Math.sqrt()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio28(numero) {
  return Math.sqrt(numero);
}

// Para testar:
// console.log(exercicio28(16)); // Sa√≠da: 4
// console.log(exercicio28(9)); // Sa√≠da: 3
```

---

### Exerc√≠cio 29: Arredondar um N√∫mero para o Inteiro Mais Pr√≥ximo

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um n√∫mero decimal e o arredonde para o inteiro mais pr√≥ximo.

**Entrada (Input)**:
```
numero = 3.7
```

**Sa√≠da Esperada (Output)**:
```
4
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `Math.round()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio29(numero) {
  return Math.round(numero);
}

// Para testar:
// console.log(exercicio29(3.7)); // Sa√≠da: 4
// console.log(exercicio29(3.2)); // Sa√≠da: 3
// console.log(exercicio29(3.5)); // Sa√≠da: 4
```

---

### Exerc√≠cio 30: Gerar um N√∫mero Aleat√≥rio entre Dois Valores

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba dois n√∫meros inteiros, `min` e `max`, e retorne um n√∫mero inteiro aleat√≥rio entre `min` (inclusive) e `max` (inclusive).

**Entrada (Input)**:
```
min = 1
max = 10
```

**Sa√≠da Esperada (Output)**:
```
(Um n√∫mero inteiro entre 1 e 10, por exemplo, 7)
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `Math.random()` e `Math.floor()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio30(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

// Para testar:
// console.log(exercicio30(1, 10)); // Sa√≠da: Um n√∫mero entre 1 e 10
// console.log(exercicio30(100, 200)); // Sa√≠da: Um n√∫mero entre 100 e 200
```

---

### Exerc√≠cio 31: Capitalizar a Primeira Letra de uma String

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba uma string e retorne uma nova string com a primeira letra em mai√∫scula e o restante em min√∫scula.

**Entrada (Input)**:
```
texto = "hello world"
```

**Sa√≠da Esperada (Output)**:
```
Hello world
```

**Restri√ß√µes/Observa√ß√µes**: A string n√£o estar√° vazia.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio31(texto) {
  if (texto.length === 0) return "";
  return texto.charAt(0).toUpperCase() + texto.slice(1).toLowerCase();
}

// Para testar:
// console.log(exercicio31("hello world")); // Sa√≠da: Hello world
// console.log(exercicio31("JAVASCRIPT")); // Sa√≠da: Javascript
```

---

### Exerc√≠cio 32: Verificar se um N√∫mero √© Primo

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um n√∫mero inteiro positivo e retorne `true` se ele for primo, `false` caso contr√°rio.

**Entrada (Input)**:
```
numero = 7
```

**Sa√≠da Esperada (Output)**:
```
true
```

**Restri√ß√µes/Observa√ß√µes**: Um n√∫mero primo √© maior que 1 e s√≥ √© divis√≠vel por 1 e por ele mesmo.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio32(numero) {
  if (numero <= 1) return false;
  for (let i = 2; i <= Math.sqrt(numero); i++) {
    if (numero % i === 0) {
      return false;
    }
  }
  return true;
}

// Para testar:
// console.log(exercicio32(7)); // Sa√≠da: true
// console.log(exercicio32(10)); // Sa√≠da: false
// console.log(exercicio32(2)); // Sa√≠da: true
```

---

### Exerc√≠cio 33: Somar N√∫meros de 1 a N

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um n√∫mero inteiro positivo `N` e retorne a soma de todos os n√∫meros de 1 at√© `N`.

**Entrada (Input)**:
```
N = 5
```

**Sa√≠da Esperada (Output)**:
```
15
```

**Restri√ß√µes/Observa√ß√µes**: Utilize um loop `for`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio33(N) {
  let soma = 0;
  for (let i = 1; i <= N; i++) {
    soma += i;
  }
  return soma;
  // Ou usando a f√≥rmula de Gauss:
  // return N * (N + 1) / 2;
}

// Para testar:
// console.log(exercicio33(5)); // Sa√≠da: 15
// console.log(exercicio33(10)); // Sa√≠da: 55
```

---

### Exerc√≠cio 34: Contar Palavras em uma String

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba uma string e retorne o n√∫mero de palavras nela. Considere palavras separadas por espa√ßos.

**Entrada (Input)**:
```
frase = "Ol√° mundo JavaScript"
```

**Sa√≠da Esperada (Output)**:
```
3
```

**Restri√ß√µes/Observa√ß√µes**: Ignore m√∫ltiplos espa√ßos e espa√ßos no in√≠cio/fim da string.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio34(frase) {
  const palavras = frase.trim().split(/\s+/);
  return palavras.length;
}

// Para testar:
// console.log(exercicio34("Ol√° mundo JavaScript")); // Sa√≠da: 3
// console.log(exercicio34("  Uma frase com   muitos espa√ßos  ")); // Sa√≠da: 5
// console.log(exercicio34("")); // Sa√≠da: 1 (ou 0 se considerar string vazia como 0 palavras)
// Ajuste para 0 se string vazia:
// function exercicio34(frase) {
//   const palavras = frase.trim().split(/\s+/);
//   return palavras[0] === "" ? 0 : palavras.length;
// }
```

---

### Exerc√≠cio 35: Remover Espa√ßos em Branco de uma String

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba uma string e retorne uma nova string sem nenhum espa√ßo em branco (incluindo espa√ßos, tabs e quebras de linha).

**Entrada (Input)**:
```
texto = "  Hello   World  \n  JavaScript  "
```

**Sa√≠da Esperada (Output)**:
```
HelloWorldJavaScript
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `replace()` com express√£o regular.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio35(texto) {
  return texto.replace(/\s/g, \'\');
}

// Para testar:
// console.log(exercicio35("  Hello   World  \n  JavaScript  ")); // Sa√≠da: HelloWorldJavaScript
// console.log(exercicio35("SemEspacos")); // Sa√≠da: SemEspacos
```

---

### Exerc√≠cio 36: Concatenar Arrays

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba dois arrays e retorne um novo array contendo todos os elementos de ambos os arrays, na ordem em que aparecem.

**Entrada (Input)**:
```
array1 = [1, 2]
array2 = [3, 4]
```

**Sa√≠da Esperada (Output)**:
```
[1, 2, 3, 4]
```

**Restri√ß√µes/Observa√ß√µes**: Utilize o m√©todo `concat()` ou o spread operator (`...`).

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio36(array1, array2) {
  return array1.concat(array2);
  // Ou com spread operator:
  // return [...array1, ...array2];
}

// Para testar:
// console.log(exercicio36([1, 2], [3, 4])); // Sa√≠da: [1, 2, 3, 4]
// console.log(exercicio36(["a", "b"], ["c", "d"])); // Sa√≠da: ["a", "b", "c", "d"]
```

---

### Exerc√≠cio 37: Obter Substring

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba uma string, um √≠ndice de in√≠cio e um comprimento, e retorne a substring correspondente.

**Entrada (Input)**:
```
texto = "JavaScript"
inicio = 4
comprimento = 6
```

**Sa√≠da Esperada (Output)**:
```
Script
```

**Restri√ß√µes/Observa√ß√µes**: Utilize o m√©todo `substring()` ou `slice()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio37(texto, inicio, comprimento) {
  return texto.substring(inicio, inicio + comprimento);
  // Ou com slice:
  // return texto.slice(inicio, inicio + comprimento);
}

// Para testar:
// console.log(exercicio37("JavaScript", 4, 6)); // Sa√≠da: Script
// console.log(exercicio37("Hello World", 0, 5)); // Sa√≠da: Hello
```

---

### Exerc√≠cio 38: Verificar se uma String Cont√©m Outra

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba duas strings, `textoPrincipal` e `subtexto`, e retorne `true` se `textoPrincipal` contiver `subtexto`, `false` caso contr√°rio (case-sensitive).

**Entrada (Input)**:
```
textoPrincipal = "Programa√ß√£o JavaScript"
subtexto = "Java"
```

**Sa√≠da Esperada (Output)**:
```
true
```

**Restri√ß√µes/Observa√ß√µes**: Utilize o m√©todo `includes()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio38(textoPrincipal, subtexto) {
  return textoPrincipal.includes(subtexto);
}

// Para testar:
// console.log(exercicio38("Programa√ß√£o JavaScript", "Java")); // Sa√≠da: true
// console.log(exercicio38("Programa√ß√£o JavaScript", "python")); // Sa√≠da: false
// console.log(exercicio38("Programa√ß√£o JavaScript", "java")); // Sa√≠da: false (case-sensitive)
```

---

### Exerc√≠cio 39: Substituir Caracteres em uma String

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba uma string, um caractere a ser substitu√≠do e um caractere substituto, e retorne a string com todas as ocorr√™ncias do primeiro caractere substitu√≠das pelo segundo.

**Entrada (Input)**:
```
texto = "banana"
caractereAntigo = "a"
caractereNovo = "o"
```

**Sa√≠da Esperada (Output)**:
```
bonono
```

**Restri√ß√µes/Observa√ß√µes**: Utilize o m√©todo `replace()` com express√£o regular global (`/g`).

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio39(texto, caractereAntigo, caractereNovo) {
  // Para substituir todas as ocorr√™ncias, √© necess√°rio usar uma RegExp com a flag \'g\'
  const regex = new RegExp(caractereAntigo, \'g\');
  return texto.replace(regex, caractereNovo);
}

// Para testar:
// console.log(exercicio39("banana", "a", "o")); // Sa√≠da: bonono
// console.log(exercicio39("mississippi", "s", "z")); // Sa√≠da: mizziZZippi
```

---

### Exerc√≠cio 40: Calcular a √Årea de um C√≠rculo

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba o raio de um c√≠rculo e retorne a sua √°rea. A f√≥rmula √© `√Årea = œÄ * raio¬≤`.

**Entrada (Input)**:
```
raio = 5
```

**Sa√≠da Esperada (Output)**:
```
78.53981633974483
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `Math.PI` e `Math.pow()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio40(raio) {
  return Math.PI * Math.pow(raio, 2);
}

// Para testar:
// console.log(exercicio40(5)); // Sa√≠da: 78.53981633974483
// console.log(exercicio40(10)); // Sa√≠da: 314.1592653589793
```

---

### Exerc√≠cio 41: Calcular a √Årea de um Ret√¢ngulo

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba a largura e a altura de um ret√¢ngulo e retorne a sua √°rea.

**Entrada (Input)**:
```
largura = 10
altura = 5
```

**Sa√≠da Esperada (Output)**:
```
50
```

**Restri√ß√µes/Observa√ß√µes**: A √°rea √© `largura * altura`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio41(largura, altura) {
  return largura * altura;
}

// Para testar:
// console.log(exercicio41(10, 5)); // Sa√≠da: 50
// console.log(exercicio41(7, 7)); // Sa√≠da: 49
```

---

### Exerc√≠cio 42: Verificar se um Ano √© Bissexto

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um ano como par√¢metro e retorne `true` se ele for bissexto, `false` caso contr√°rio.

**Entrada (Input)**:
```
ano = 2024
```

**Sa√≠da Esperada (Output)**:
```
true
```

**Restri√ß√µes/Observa√ß√µes**: Um ano √© bissexto se for divis√≠vel por 4, exceto se for divis√≠vel por 100 mas n√£o por 400.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio42(ano) {
  return (ano % 4 === 0 && ano % 100 !== 0) || ano % 400 === 0;
}

// Para testar:
// console.log(exercicio42(2024)); // Sa√≠da: true
// console.log(exercicio42(2000)); // Sa√≠da: true
// console.log(exercicio42(1900)); // Sa√≠da: false
// console.log(exercicio42(2023)); // Sa√≠da: false
```

---

### Exerc√≠cio 43: Gerar Sequ√™ncia de Fibonacci at√© N Termos

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um n√∫mero inteiro `N` e retorne um array contendo os primeiros `N` termos da sequ√™ncia de Fibonacci.

**Entrada (Input)**:
```
N = 7
```

**Sa√≠da Esperada (Output)**:
```
[0, 1, 1, 2, 3, 5, 8]
```

**Restri√ß√µes/Observa√ß√µes**: A sequ√™ncia come√ßa com 0 e 1. Se `N` for 0, retorne um array vazio. Se `N` for 1, retorne `[0]`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio43(N) {
  if (N <= 0) return [];
  if (N === 1) return [0];

  const fib = [0, 1];
  for (let i = 2; i < N; i++) {
    fib.push(fib[i - 1] + fib[i - 2]);
  }
  return fib;
}

// Para testar:
// console.log(exercicio43(7)); // Sa√≠da: [0, 1, 1, 2, 3, 5, 8]
// console.log(exercicio43(1)); // Sa√≠da: [0]
// console.log(exercicio43(0)); // Sa√≠da: []
```

---

### Exerc√≠cio 44: Remover o √öltimo Elemento de um Array

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array e retorne um novo array com o √∫ltimo elemento removido. N√£o modifique o array original.

**Entrada (Input)**:
```
array = [1, 2, 3, 4]
```

**Sa√≠da Esperada (Output)**:
```
[1, 2, 3]
```

**Restri√ß√µes/Observa√ß√µes**: O array n√£o estar√° vazio. Utilize `slice()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio44(array) {
  return array.slice(0, -1);
  // Ou:
  // return array.slice(0, array.length - 1);
}

// Para testar:
// console.log(exercicio44([1, 2, 3, 4])); // Sa√≠da: [1, 2, 3]
// console.log(exercicio44(["a", "b"])); // Sa√≠da: ["a"]
```

---

### Exerc√≠cio 45: Adicionar Elemento ao Final de um Array

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array e um elemento, e retorne um novo array com o elemento adicionado ao final. N√£o modifique o array original.

**Entrada (Input)**:
```
array = [1, 2, 3]
elemento = 4
```

**Sa√≠da Esperada (Output)**:
```
[1, 2, 3, 4]
```

**Restri√ß√µes/Observa√ß√µes**: Utilize o spread operator (`...`) ou `concat()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio45(array, elemento) {
  return [...array, elemento];
  // Ou:
  // return array.concat(elemento);
}

// Para testar:
// console.log(exercicio45([1, 2, 3], 4)); // Sa√≠da: [1, 2, 3, 4]
// console.log(exercicio45(["a", "b"], "c")); // Sa√≠da: ["a", "b", "c"]
```

---

### Exerc√≠cio 46: Remover o Primeiro Elemento de um Array

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array e retorne um novo array com o primeiro elemento removido. N√£o modifique o array original.

**Entrada (Input)**:
```
array = [1, 2, 3, 4]
```

**Sa√≠da Esperada (Output)**:
```
[2, 3, 4]
```

**Restri√ß√µes/Observa√ß√µes**: O array n√£o estar√° vazio. Utilize `slice()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio46(array) {
  return array.slice(1);
}

// Para testar:
// console.log(exercicio46([1, 2, 3, 4])); // Sa√≠da: [2, 3, 4]
// console.log(exercicio46(["a", "b"])); // Sa√≠da: ["b"]
```

---

### Exerc√≠cio 47: Adicionar Elemento ao In√≠cio de um Array

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array e um elemento, e retorne um novo array com o elemento adicionado ao in√≠cio. N√£o modifique o array original.

**Entrada (Input)**:
```
array = [2, 3, 4]
elemento = 1
```

**Sa√≠da Esperada (Output)**:
```
[1, 2, 3, 4]
```

**Restri√ß√µes/Observa√ß√µes**: Utilize o spread operator (`...`) ou `concat()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio47(array, elemento) {
  return [elemento, ...array];
  // Ou:
  // return [elemento].concat(array);
}

// Para testar:
// console.log(exercicio47([2, 3, 4], 1)); // Sa√≠da: [1, 2, 3, 4]
// console.log(exercicio47(["b", "c"], "a")); // Sa√≠da: ["a", "b", "c"]
```

---

### Exerc√≠cio 48: Juntar Elementos de um Array em uma String

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array de strings e um separador, e retorne uma √∫nica string com os elementos do array unidos pelo separador.

**Entrada (Input)**:
```
array = ["Ma√ß√£", "Banana", "Laranja"]
separador = ", "
```

**Sa√≠da Esperada (Output)**:
```
Ma√ß√£, Banana, Laranja
```

**Restri√ß√µes/Observa√ß√µes**: Utilize o m√©todo `join()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio48(array, separador) {
  return array.join(separador);
}

// Para testar:
// console.log(exercicio48(["Ma√ß√£", "Banana", "Laranja"], ", ")); // Sa√≠da: Ma√ß√£, Banana, Laranja
// console.log(exercicio48(["um", "dois", "tr√™s"], "-")); // Sa√≠da: um-dois-tr√™s
```

---

### Exerc√≠cio 49: Dividir uma String em um Array

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba uma string e um delimitador, e retorne um array de substrings divididas pelo delimitador.

**Entrada (Input)**:
```
texto = "Ma√ß√£,Banana,Laranja"
delimitador = ","
```

**Sa√≠da Esperada (Output)**:
```
["Ma√ß√£", "Banana", "Laranja"]
```

**Restri√ß√µes/Observa√ß√µes**: Utilize o m√©todo `split()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio49(texto, delimitador) {
  return texto.split(delimitador);
}

// Para testar:
// console.log(exercicio49("Ma√ß√£,Banana,Laranja", ",")); // Sa√≠da: ["Ma√ß√£", "Banana", "Laranja"]
// console.log(exercicio49("um-dois-tr√™s", "-")); // Sa√≠da: ["um", "dois", "tr√™s"]
```

---

### Exerc√≠cio 50: Verificar se Todos os Elementos de um Array Satisfazem uma Condi√ß√£o

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array de n√∫meros e uma fun√ß√£o de callback (condi√ß√£o), e retorne `true` se todos os elementos do array satisfizerem a condi√ß√£o, `false` caso contr√°rio.

**Entrada (Input)**:
```
numeros = [2, 4, 6, 8]
condicao = (num) => num % 2 === 0 // Verifica se √© par
```

**Sa√≠da Esperada (Output)**:
```
true
```

**Restri√ß√µes/Observa√ß√µes**: Utilize o m√©todo `every()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio50(numeros, condicao) {
  return numeros.every(condicao);
}

// Para testar:
// console.log(exercicio50([2, 4, 6, 8], (num) => num % 2 === 0)); // Sa√≠da: true
// console.log(exercicio50([1, 2, 3], (num) => num > 0)); // Sa√≠da: true
// console.log(exercicio50([1, 2, 3], (num) => num % 2 === 0)); // Sa√≠da: false
```

---

### Exerc√≠cio 51: Verificar se Algum Elemento de um Array Satisfaz uma Condi√ß√£o

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array de n√∫meros e uma fun√ß√£o de callback (condi√ß√£o), e retorne `true` se pelo menos um elemento do array satisfizer a condi√ß√£o, `false` caso contr√°rio.

**Entrada (Input)**:
```
numeros = [1, 3, 5, 8]
condicao = (num) => num % 2 === 0 // Verifica se √© par
```

**Sa√≠da Esperada (Output)**:
```
true
```

**Restri√ß√µes/Observa√ß√µes**: Utilize o m√©todo `some()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio51(numeros, condicao) {
  return numeros.some(condicao);
}

// Para testar:
// console.log(exercicio51([1, 3, 5, 8], (num) => num % 2 === 0)); // Sa√≠da: true
// console.log(exercicio51([1, 3, 5], (num) => num > 10)); // Sa√≠da: false
```

---

### Exerc√≠cio 52: Encontrar o √çndice de um Elemento em um Array

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array e um elemento, e retorne o √≠ndice da primeira ocorr√™ncia do elemento no array. Se o elemento n√£o for encontrado, retorne -1.

**Entrada (Input)**:
```
array = [10, 20, 30, 20, 40]
elemento = 20
```

**Sa√≠da Esperada (Output)**:
```
1
```

**Restri√ß√µes/Observa√ß√µes**: Utilize o m√©todo `indexOf()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio52(array, elemento) {
  return array.indexOf(elemento);
}

// Para testar:
// console.log(exercicio52([10, 20, 30, 20, 40], 20)); // Sa√≠da: 1
// console.log(exercicio52([1, 2, 3], 5)); // Sa√≠da: -1
```

---

### Exerc√≠cio 53: Encontrar o √öltimo √çndice de um Elemento em um Array

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array e um elemento, e retorne o √≠ndice da √∫ltima ocorr√™ncia do elemento no array. Se o elemento n√£o for encontrado, retorne -1.

**Entrada (Input)**:
```
array = [10, 20, 30, 20, 40]
elemento = 20
```

**Sa√≠da Esperada (Output)**:
```
3
```

**Restri√ß√µes/Observa√ß√µes**: Utilize o m√©todo `lastIndexOf()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio53(array, elemento) {
  return array.lastIndexOf(elemento);
}

// Para testar:
// console.log(exercicio53([10, 20, 30, 20, 40], 20)); // Sa√≠da: 3
// console.log(exercicio53([1, 2, 3], 5)); // Sa√≠da: -1
```

---

### Exerc√≠cio 54: Reverter a Ordem dos Elementos de um Array

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array e retorne um novo array com os elementos na ordem inversa. N√£o modifique o array original.

**Entrada (Input)**:
```
array = [1, 2, 3, 4]
```

**Sa√≠da Esperada (Output)**:
```
[4, 3, 2, 1]
```

**Restri√ß√µes/Observa√ß√µes**: Utilize o m√©todo `reverse()` em uma c√≥pia do array ou um loop `for`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio54(array) {
  return [...array].reverse();
  // Ou com loop for:
  // const novoArray = [];
  // for (let i = array.length - 1; i >= 0; i--) {
  //   novoArray.push(array[i]);
  // }
  // return novoArray;
}

// Para testar:
// console.log(exercicio54([1, 2, 3, 4])); // Sa√≠da: [4, 3, 2, 1]
// console.log(exercicio54(["a", "b", "c"])); // Sa√≠da: ["c", "b", "a"]
```

---

### Exerc√≠cio 55: Ordenar um Array de N√∫meros em Ordem Crescente

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array de n√∫meros e retorne um novo array com os n√∫meros ordenados em ordem crescente. N√£o modifique o array original.

**Entrada (Input)**:
```
numeros = [3, 1, 4, 1, 5, 9, 2, 6]
```

**Sa√≠da Esperada (Output)**:
```
[1, 1, 2, 3, 4, 5, 6, 9]
```

**Restri√ß√µes/Observa√ß√µes**: Utilize o m√©todo `sort()` com uma fun√ß√£o de compara√ß√£o.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio55(numeros) {
  return [...numeros].sort((a, b) => a - b);
}

// Para testar:
// console.log(exercicio55([3, 1, 4, 1, 5, 9, 2, 6])); // Sa√≠da: [1, 1, 2, 3, 4, 5, 6, 9]
// console.log(exercicio55([10, 1, 5, 20])); // Sa√≠da: [1, 5, 10, 20]
```

---

### Exerc√≠cio 56: Ordenar um Array de N√∫meros em Ordem Decrescente

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array de n√∫meros e retorne um novo array com os n√∫meros ordenados em ordem decrescente. N√£o modifique o array original.

**Entrada (Input)**:
```
numeros = [3, 1, 4, 1, 5, 9, 2, 6]
```

**Sa√≠da Esperada (Output)**:
```
[9, 6, 5, 4, 3, 2, 1, 1]
```

**Restri√ß√µes/Observa√ß√µes**: Utilize o m√©todo `sort()` com uma fun√ß√£o de compara√ß√£o.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio56(numeros) {
  return [...numeros].sort((a, b) => b - a);
}

// Para testar:
// console.log(exercicio56([3, 1, 4, 1, 5, 9, 2, 6])); // Sa√≠da: [9, 6, 5, 4, 3, 2, 1, 1]
// console.log(exercicio56([10, 1, 5, 20])); // Sa√≠da: [20, 10, 5, 1]
```

---

### Exerc√≠cio 57: Calcular a Soma dos Quadrados de um Array

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array de n√∫meros e retorne a soma dos quadrados de cada elemento.

**Entrada (Input)**:
```
numeros = [1, 2, 3]
```

**Sa√≠da Esperada (Output)**:
```
14 // (1*1 + 2*2 + 3*3 = 1 + 4 + 9 = 14)
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `map()` e `reduce()` ou um loop `for`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio57(numeros) {
  return numeros.reduce((acc, curr) => acc + (curr * curr), 0);
  // Ou com map e reduce:
  // const quadrados = numeros.map(num => num * num);
  // return quadrados.reduce((acc, curr) => acc + curr, 0);
}

// Para testar:
// console.log(exercicio57([1, 2, 3])); // Sa√≠da: 14
// console.log(exercicio57([2, 4])); // Sa√≠da: 20 (4 + 16)
```

---

### Exerc√≠cio 58: Remover Elemento por Valor de um Array

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array e um valor, e retorne um novo array com todas as ocorr√™ncias desse valor removidas. N√£o modifique o array original.

**Entrada (Input)**:
```
array = [1, 2, 3, 2, 4]
valor = 2
```

**Sa√≠da Esperada (Output)**:
```
[1, 3, 4]
```

**Restri√ß√µes/Observa√ß√µes**: Utilize o m√©todo `filter()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio58(array, valor) {
  return array.filter(item => item !== valor);
}

// Para testar:
// console.log(exercicio58([1, 2, 3, 2, 4], 2)); // Sa√≠da: [1, 3, 4]
// console.log(exercicio58(["a", "b", "c", "a"], "a")); // Sa√≠da: ["b", "c"]
```

---

### Exerc√≠cio 59: Obter o Comprimento de uma String

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba uma string e retorne o seu comprimento.

**Entrada (Input)**:
```
texto = "JavaScript"
```

**Sa√≠da Esperada (Output)**:
```
10
```

**Restri√ß√µes/Observa√ß√µes**: Utilize a propriedade `length`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio59(texto) {
  return texto.length;
}

// Para testar:
// console.log(exercicio59("JavaScript")); // Sa√≠da: 10
// console.log(exercicio59("")); // Sa√≠da: 0
```

---

### Exerc√≠cio 60: Obter o Comprimento de um Array

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array e retorne o n√∫mero de elementos nele.

**Entrada (Input)**:
```
array = [1, 2, 3, 4, 5]
```

**Sa√≠da Esperada (Output)**:
```
5
```

**Restri√ß√µes/Observa√ß√µes**: Utilize a propriedade `length`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio60(array) {
  return array.length;
}

// Para testar:
// console.log(exercicio60([1, 2, 3, 4, 5])); // Sa√≠da: 5
// console.log(exercicio60([])); // Sa√≠da: 0
```

---

### Exerc√≠cio 61: Repetir uma String N Vezes

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba uma string e um n√∫mero inteiro `N`, e retorne uma nova string que √© a original repetida `N` vezes.

**Entrada (Input)**:
```
texto = "abc"
N = 3
```

**Sa√≠da Esperada (Output)**:
```
abcabcabc
```

**Restri√ß√µes/Observa√ß√µes**: `N` ser√° um n√∫mero n√£o negativo. Utilize o m√©todo `repeat()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio61(texto, N) {
  return texto.repeat(N);
}

// Para testar:
// console.log(exercicio61("abc", 3)); // Sa√≠da: abcabcabc
// console.log(exercicio61("hi", 0)); // Sa√≠da: ""
```

---

### Exerc√≠cio 62: Verificar se uma String Come√ßa com um Prefixo

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba duas strings, `texto` e `prefixo`, e retorne `true` se `texto` come√ßar com `prefixo`, `false` caso contr√°rio (case-sensitive).

**Entrada (Input)**:
```
texto = "JavaScript"
prefixo = "Java"
```

**Sa√≠da Esperada (Output)**:
```
true
```

**Restri√ß√µes/Observa√ß√µes**: Utilize o m√©todo `startsWith()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio62(texto, prefixo) {
  return texto.startsWith(prefixo);
}

// Para testar:
// console.log(exercicio62("JavaScript", "Java")); // Sa√≠da: true
// console.log(exercicio62("Hello World", "world")); // Sa√≠da: false
```

---

### Exerc√≠cio 63: Verificar se uma String Termina com um Sufixo

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba duas strings, `texto` e `sufixo`, e retorne `true` se `texto` terminar com `sufixo`, `false` caso contr√°rio (case-sensitive).

**Entrada (Input)**:
```
texto = "JavaScript"
sufixo = "Script"
```

**Sa√≠da Esperada (Output)**:
```
true
```

**Restri√ß√µes/Observa√ß√µes**: Utilize o m√©todo `endsWith()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio63(texto, sufixo) {
  return texto.endsWith(sufixo);
}

// Para testar:
// console.log(exercicio63("JavaScript", "Script")); // Sa√≠da: true
// console.log(exercicio63("Hello World", "hello")); // Sa√≠da: false
```

---

### Exerc√≠cio 64: Encontrar o M√≠nimo de Tr√™s N√∫meros

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba tr√™s n√∫meros e retorne o menor entre eles.

**Entrada (Input)**:
```
num1 = 10
num2 = 5
num3 = 15
```

**Sa√≠da Esperada (Output)**:
```
5
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `Math.min()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio64(num1, num2, num3) {
  return Math.min(num1, num2, num3);
}

// Para testar:
// console.log(exercicio64(10, 5, 15)); // Sa√≠da: 5
// console.log(exercicio64(100, 20, 30)); // Sa√≠da: 20
```

---

### Exerc√≠cio 65: Encontrar o M√°ximo de Tr√™s N√∫meros

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba tr√™s n√∫meros e retorne o maior entre eles.

**Entrada (Input)**:
```
num1 = 10
num2 = 5
num3 = 15
```

**Sa√≠da Esperada (Output)**:
```
15
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `Math.max()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio65(num1, num2, num3) {
  return Math.max(num1, num2, num3);
}

// Para testar:
// console.log(exercicio65(10, 5, 15)); // Sa√≠da: 15
// console.log(exercicio65(100, 20, 30)); // Sa√≠da: 100
```

---

### Exerc√≠cio 66: Calcular a M√©dia Ponderada

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba dois arrays: um de `notas` e outro de `pesos` correspondentes. Retorne a m√©dia ponderada.

**Entrada (Input)**:
```
notas = [70, 80, 90]
pesos = [0.2, 0.3, 0.5]
```

**Sa√≠da Esperada (Output)**:
```
83 // (70*0.2 + 80*0.3 + 90*0.5 = 14 + 24 + 45 = 83)
```

**Restri√ß√µes/Observa√ß√µes**: Os arrays ter√£o o mesmo comprimento e os pesos somar√£o 1.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio66(notas, pesos) {
  let somaPonderada = 0;
  let somaPesos = 0;
  for (let i = 0; i < notas.length; i++) {
    somaPonderada += notas[i] * pesos[i];
    somaPesos += pesos[i];
  }
  return somaPonderada / somaPesos;
}

// Para testar:
// console.log(exercicio66([70, 80, 90], [0.2, 0.3, 0.5])); // Sa√≠da: 83
// console.log(exercicio66([10, 20], [0.5, 0.5])); // Sa√≠da: 15
```

---

### Exerc√≠cio 67: Converter Horas para Minutos

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um n√∫mero de horas e retorne o equivalente em minutos.

**Entrada (Input)**:
```
horas = 2
```

**Sa√≠da Esperada (Output)**:
```
120
```

**Restri√ß√µes/Observa√ß√µes**: 1 hora = 60 minutos.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio67(horas) {
  return horas * 60;
}

// Para testar:
// console.log(exercicio67(2)); // Sa√≠da: 120
// console.log(exercicio67(0.5)); // Sa√≠da: 30
```

---

### Exerc√≠cio 68: Converter Minutos para Horas e Minutos

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um n√∫mero total de minutos e retorne uma string formatada como "X horas e Y minutos".

**Entrada (Input)**:
```
minutosTotais = 150
```

**Sa√≠da Esperada (Output)**:
```
2 horas e 30 minutos
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `Math.floor()` para as horas e o operador de m√≥dulo (`%`) para os minutos restantes.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio68(minutosTotais) {
  const horas = Math.floor(minutosTotais / 60);
  const minutos = minutosTotais % 60;
  return `${horas} horas e ${minutos} minutos`;
}

// Para testar:
// console.log(exercicio68(150)); // Sa√≠da: 2 horas e 30 minutos
// console.log(exercicio68(60)); // Sa√≠da: 1 horas e 0 minutos
// console.log(exercicio68(45)); // Sa√≠da: 0 horas e 45 minutos
```

---

### Exerc√≠cio 69: Verificar se um N√∫mero √© Positivo, Negativo ou Zero

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um n√∫mero e retorne "Positivo", "Negativo" ou "Zero" conforme o valor.

**Entrada (Input)**:
```
numero = -5
```

**Sa√≠da Esperada (Output)**:
```
Negativo
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `if/else if/else`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio69(numero) {
  if (numero > 0) {
    return "Positivo";
  } else if (numero < 0) {
    return "Negativo";
  } else {
    return "Zero";
  }
}

// Para testar:
// console.log(exercicio69(-5)); // Sa√≠da: Negativo
// console.log(exercicio69(10)); // Sa√≠da: Positivo
// console.log(exercicio69(0)); // Sa√≠da: Zero
```

---

### Exerc√≠cio 70: Calcular o Produto de um Array de N√∫meros

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array de n√∫meros e retorne o produto de todos os seus elementos.

**Entrada (Input)**:
```
numeros = [1, 2, 3, 4]
```

**Sa√≠da Esperada (Output)**:
```
24 // (1 * 2 * 3 * 4 = 24)
```

**Restri√ß√µes/Observa√ß√µes**: O array n√£o estar√° vazio. Retorne 1 se o array estiver vazio.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio70(numeros) {
  if (numeros.length === 0) {
    return 1;
  }
  let produto = 1;
  for (let i = 0; i < numeros.length; i++) {
    produto *= numeros[i];
  }
  return produto;
  // Ou com reduce:
  // return numeros.reduce((acc, curr) => acc * curr, 1);
}

// Para testar:
// console.log(exercicio70([1, 2, 3, 4])); // Sa√≠da: 24
// console.log(exercicio70([5, 2])); // Sa√≠da: 10
// console.log(exercicio70([])); // Sa√≠da: 1
```

---

### Exerc√≠cio 71: Inverter a Ordem das Palavras em uma Frase

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba uma string (frase) e retorne uma nova string com a ordem das palavras invertida.

**Entrada (Input)**:
```
frase = "Ol√° mundo JavaScript"
```

**Sa√≠da Esperada (Output)**:
```
JavaScript mundo Ol√°
```

**Restri√ß√µes/Observa√ß√µes**: Considere palavras separadas por um √∫nico espa√ßo.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio71(frase) {
  return frase.split(\' \').reverse().join(\' \');
}

// Para testar:
// console.log(exercicio71("Ol√° mundo JavaScript")); // Sa√≠da: JavaScript mundo Ol√°
// console.log(exercicio71("um dois tr√™s")); // Sa√≠da: tr√™s dois um
```

---

### Exerc√≠cio 72: Remover Espa√ßos Extras entre Palavras

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba uma string e retorne uma nova string onde m√∫ltiplos espa√ßos entre palavras s√£o substitu√≠dos por um √∫nico espa√ßo, e espa√ßos no in√≠cio/fim s√£o removidos.

**Entrada (Input)**:
```
frase = "  Ol√°   mundo    JavaScript  "
```

**Sa√≠da Esperada (Output)**:
```
Ol√° mundo JavaScript
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `trim()` e `replace()` com express√£o regular.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio72(frase) {
  return frase.trim().replace(/\s+/g, \' \');
}

// Para testar:
// console.log(exercicio72("  Ol√°   mundo    JavaScript  ")); // Sa√≠da: Ol√° mundo JavaScript
// console.log(exercicio72("Apenas uma palavra")); // Sa√≠da: Apenas uma palavra
```

---

### Exerc√≠cio 73: Verificar se um Objeto est√° Vazio

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um objeto e retorne `true` se ele n√£o tiver nenhuma propriedade pr√≥pria enumer√°vel, `false` caso contr√°rio.

**Entrada (Input)**:
```
objeto1 = {}
objeto2 = {a: 1}
```

**Sa√≠da Esperada (Output)**:
```
true (para objeto1)
false (para objeto2)
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `Object.keys()` ou `Object.entries()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio73(obj) {
  return Object.keys(obj).length === 0;
}

// Para testar:
// console.log(exercicio73({})); // Sa√≠da: true
// console.log(exercicio73({a: 1})); // Sa√≠da: false
```

---

### Exerc√≠cio 74: Obter as Chaves de um Objeto

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um objeto e retorne um array contendo todas as chaves (nomes das propriedades) do objeto.

**Entrada (Input)**:
```
objeto = { nome: "Jo√£o", idade: 30, cidade: "S√£o Paulo" }
```

**Sa√≠da Esperada (Output)**:
```
["nome", "idade", "cidade"]
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `Object.keys()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio74(obj) {
  return Object.keys(obj);
}

// Para testar:
// console.log(exercicio74({ nome: "Jo√£o", idade: 30, cidade: "S√£o Paulo" })); // Sa√≠da: ["nome", "idade", "cidade"]
// console.log(exercicio74({ a: 1, b: 2 })); // Sa√≠da: ["a", "b"]
```

---

### Exerc√≠cio 75: Obter os Valores de um Objeto

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um objeto e retorne um array contendo todos os valores das propriedades do objeto.

**Entrada (Input)**:
```
objeto = { nome: "Jo√£o", idade: 30, cidade: "S√£o Paulo" }
```

**Sa√≠da Esperada (Output)**:
```
["Jo√£o", 30, "S√£o Paulo"]
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `Object.values()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio75(obj) {
  return Object.values(obj);
}

// Para testar:
// console.log(exercicio75({ nome: "Jo√£o", idade: 30, cidade: "S√£o Paulo" })); // Sa√≠da: ["Jo√£o", 30, "S√£o Paulo"]
// console.log(exercicio75({ a: 1, b: 2 })); // Sa√≠da: [1, 2]
```

---

### Exerc√≠cio 76: Obter Pares Chave-Valor de um Objeto

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um objeto e retorne um array de arrays, onde cada sub-array cont√©m um par `[chave, valor]` das propriedades do objeto.

**Entrada (Input)**:
```
objeto = { nome: "Jo√£o", idade: 30 }
```

**Sa√≠da Esperada (Output)**:
```
[["nome", "Jo√£o"], ["idade", 30]]
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `Object.entries()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio76(obj) {
  return Object.entries(obj);
}

// Para testar:
// console.log(exercicio76({ nome: "Jo√£o", idade: 30 })); // Sa√≠da: [["nome", "Jo√£o"], ["idade", 30]]
// console.log(exercicio76({ a: 1, b: 2 })); // Sa√≠da: [["a", 1], ["b", 2]]
```

---

### Exerc√≠cio 77: Criar um Objeto a Partir de Arrays de Chaves e Valores

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba dois arrays, um de `chaves` e outro de `valores`, e retorne um objeto onde cada chave corresponde ao seu valor no mesmo √≠ndice.

**Entrada (Input)**:
```
chaves = ["nome", "idade"]
valores = ["Maria", 25]
```

**Sa√≠da Esperada (Output)**:
```
{ nome: "Maria", idade: 25 }
```

**Restri√ß√µes/Observa√ß√µes**: Os arrays ter√£o o mesmo comprimento. Utilize `reduce()` ou um loop `for`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio77(chaves, valores) {
  const obj = {};
  for (let i = 0; i < chaves.length; i++) {
    obj[chaves[i]] = valores[i];
  }
  return obj;
  // Ou com reduce:
  // return chaves.reduce((acc, chave, index) => {
  //   acc[chave] = valores[index];
  //   return acc;
  // }, {});
}

// Para testar:
// console.log(exercicio77(["nome", "idade"], ["Maria", 25])); // Sa√≠da: { nome: "Maria", idade: 25 }
// console.log(exercicio77(["a", "b"], [1, 2])); // Sa√≠da: { a: 1, b: 2 }
```

---

### Exerc√≠cio 78: Clonar um Objeto Simples

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um objeto simples (sem aninhamento ou fun√ß√µes) e retorne uma c√≥pia exata dele. N√£o modifique o objeto original.

**Entrada (Input)**:
```
objetoOriginal = { a: 1, b: "hello" }
```

**Sa√≠da Esperada (Output)**:
```
{ a: 1, b: "hello" }
```

**Restri√ß√µes/Observa√ß√µes**: Utilize o spread operator (`...`) ou `Object.assign()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio78(obj) {
  return { ...obj };
  // Ou:
  // return Object.assign({}, obj);
}

// Para testar:
// const original = { a: 1, b: "hello" };
// const clone = exercicio78(original);
// console.log(clone); // Sa√≠da: { a: 1, b: "hello" }
// console.log(original === clone); // Sa√≠da: false (verifica que √© uma nova refer√™ncia)
```

---

### Exerc√≠cio 79: Mesclar Dois Objetos Simples

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba dois objetos simples e retorne um novo objeto que √© a fus√£o dos dois. Se houver chaves duplicadas, o valor do segundo objeto deve prevalecer.

**Entrada (Input)**:
```
objeto1 = { a: 1, b: 2 }
objeto2 = { b: 3, c: 4 }
```

**Sa√≠da Esperada (Output)**:
```
{ a: 1, b: 3, c: 4 }
```

**Restri√ß√µes/Observa√ß√µes**: Utilize o spread operator (`...`) ou `Object.assign()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio79(obj1, obj2) {
  return { ...obj1, ...obj2 };
  // Ou:
  // return Object.assign({}, obj1, obj2);
}

// Para testar:
// console.log(exercicio79({ a: 1, b: 2 }, { b: 3, c: 4 })); // Sa√≠da: { a: 1, b: 3, c: 4 }
// console.log(exercicio79({ x: 10 }, { y: 20 })); // Sa√≠da: { x: 10, y: 20 }
```

---

### Exerc√≠cio 80: Calcular a Soma dos D√≠gitos de um N√∫mero

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um n√∫mero inteiro positivo e retorne a soma de seus d√≠gitos.

**Entrada (Input)**:
```
numero = 123
```

**Sa√≠da Esperada (Output)**:
```
6 // (1 + 2 + 3 = 6)
```

**Restri√ß√µes/Observa√ß√µes**: Converta o n√∫mero para string para iterar sobre os d√≠gitos.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio80(numero) {
  let soma = 0;
  const strNumero = String(numero);
  for (let i = 0; i < strNumero.length; i++) {
    soma += parseInt(strNumero[i], 10);
  }
  return soma;
  // Ou com split, map e reduce:
  // return String(numero).split(\'\').map(Number).reduce((acc, curr) => acc + curr, 0);
}

// Para testar:
// console.log(exercicio80(123)); // Sa√≠da: 6
// console.log(exercicio80(9876)); // Sa√≠da: 30
// console.log(exercicio80(0)); // Sa√≠da: 0
```

---



# Exerc√≠cios de JavaScript - N√≠vel Intermedi√°rio (81-170)

Esta se√ß√£o cont√©m 90 exerc√≠cios de JavaScript focados em conceitos intermedi√°rios da linguagem, manipula√ß√£o de dados e algoritmos mais complexos, projetados para serem executados em um ambiente Node.js, sem a necessidade de um navegador ou HTML.

## Estrutura dos Exerc√≠cios

Cada exerc√≠cio segue a estrutura definida no plano:

*   **T√≠tulo do Exerc√≠cio**: Nome do exerc√≠cio.
*   **Descri√ß√£o do Problema**: O que o exerc√≠cio deve resolver.
*   **Entrada (Input)**: Exemplos de dados de entrada.
*   **Sa√≠da Esperada (Output)**: Exemplos da sa√≠da esperada.
*   **Restri√ß√µes/Observa√ß√µes**: Condi√ß√µes especiais.
*   **Solu√ß√£o (Opcional)**: Esqueleto de fun√ß√£o ou solu√ß√£o completa.

---

### Exerc√≠cio 81: Criar um Objeto B√°sico

**Descri√ß√£o do Problema**: Crie um objeto `pessoa` com as propriedades `nome` (string), `idade` (number) e `cidade` (string). Atribua valores a elas e imprima o objeto completo.

**Entrada (Input)**:
N√£o h√° entrada direta, os valores s√£o atribu√≠dos internamente.

**Sa√≠da Esperada (Output)**:
```javascript
{ nome: \'Ana\', idade: 28, cidade: \'Rio de Janeiro\' }
```

**Restri√ß√µes/Observa√ß√µes**: Utilize a sintaxe de objeto literal.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio81() {
  const pessoa = {
    nome: \'Ana\',
    idade: 28,
    cidade: \'Rio de Janeiro\'
  };
  console.log(pessoa);
}

// exercicio81();
```

---

### Exerc√≠cio 82: Acessar Propriedades de um Objeto

**Descri√ß√£o do Problema**: Dado o objeto `produto = { nome: \'Laptop\', preco: 1200, emEstoque: true }`, acesse e imprima o `nome` e o `preco`.

**Entrada (Input)**:
```javascript
produto = { nome: \'Laptop\', preco: 1200, emEstoque: true }
```

**Sa√≠da Esperada (Output)**:
```
Nome do produto: Laptop
Pre√ßo: 1200
```

**Restri√ß√µes/Observa√ß√µes**: Utilize a nota√ß√£o de ponto ou colchetes.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio82() {
  const produto = { nome: \'Laptop\', preco: 1200, emEstoque: true };
  console.log(\'Nome do produto: \' + produto.nome);
  console.log(\'Pre√ßo: \' + produto[\'preco\']);
}

// exercicio82();
```

---

### Exerc√≠cio 83: Adicionar e Modificar Propriedades de um Objeto

**Descri√ß√£o do Problema**: Dado o objeto `carro = { marca: \'Ford\', modelo: \'Fiesta\' }`, adicione a propriedade `ano` com o valor `2020` e modifique o `modelo` para `\'Focus\'`. Imprima o objeto resultante.

**Entrada (Input)**:
```javascript
carro = { marca: \'Ford\', modelo: \'Fiesta\' }
```

**Sa√≠da Esperada (Output)**:
```javascript
{ marca: \'Ford\', modelo: \'Focus\', ano: 2020 }
```

**Restri√ß√µes/Observa√ß√µes**: Modifique o objeto diretamente.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio83() {
  const carro = { marca: \'Ford\', modelo: \'Fiesta\' };
  carro.ano = 2020;
  carro.modelo = \'Focus\';
  console.log(carro);
}

// exercicio83();
```

---

### Exerc√≠cio 84: Iterar sobre Propriedades de um Objeto

**Descri√ß√£o do Problema**: Dado o objeto `usuario = { id: 1, nome: \'Carlos\', email: \'carlos@example.com\' }`, itere sobre suas propriedades e imprima cada chave e valor.

**Entrada (Input)**:
```javascript
usuario = { id: 1, nome: \'Carlos\', email: \'carlos@example.com\' }
```

**Sa√≠da Esperada (Output)**:
```
Chave: id, Valor: 1
Chave: nome, Valor: Carlos
Chave: email, Valor: carlos@example.com
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `for...in` ou `Object.keys().forEach()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio84() {
  const usuario = { id: 1, nome: \'Carlos\', email: \'carlos@example.com\' };
  for (const chave in usuario) {
    console.log(`Chave: ${chave}, Valor: ${usuario[chave]}`);
  }
  // Ou:
  // Object.keys(usuario).forEach(chave => {
  //   console.log(`Chave: ${chave}, Valor: ${usuario[chave]}`);
  // });
}

// exercicio84();
```

---

### Exerc√≠cio 85: Objeto Aninhado

**Descri√ß√£o do Problema**: Crie um objeto `empresa` com propriedades `nome`, `cnpj` e um objeto aninhado `endereco` com `rua`, `numero` e `cidade`. Imprima a cidade da empresa.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
```
Cidade da empresa: S√£o Paulo
```

**Restri√ß√µes/Observa√ß√µes**: Acesso a propriedades aninhadas.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio85() {
  const empresa = {
    nome: \'Tech Solutions\',
    cnpj: \'12.345.678/0001-90\',
    endereco: {
      rua: \'Av. Paulista\',
      numero: 1000,
      cidade: \'S√£o Paulo\'
    }
  };
  console.log(\'Cidade da empresa: \' + empresa.endereco.cidade);
}

// exercicio85();
```

---

### Exerc√≠cio 86: Desestrutura√ß√£o de Objeto

**Descri√ß√£o do Problema**: Dado o objeto `livro = { titulo: \'O Senhor dos An√©is\', autor: \'J.R.R. Tolkien\', ano: 1954 }`, use desestrutura√ß√£o para extrair `titulo` e `autor` em vari√°veis separadas e imprima-as.

**Entrada (Input)**:
```javascript
livro = { titulo: \'O Senhor dos An√©is\', autor: \'J.R.R. Tolkien\', ano: 1954 }
```

**Sa√≠da Esperada (Output)**:
```
T√≠tulo: O Senhor dos An√©is
Autor: J.R.R. Tolkien
```

**Restri√ß√µes/Observa√ß√µes**: Utilize a sintaxe de desestrutura√ß√£o.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio86() {
  const livro = { titulo: \'O Senhor dos An√©is\', autor: \'J.R.R. Tolkien\', ano: 1954 };
  const { titulo, autor } = livro;
  console.log(\'T√≠tulo: \' + titulo);
  console.log(\'Autor: \' + autor);
}

// exercicio86();
```

---

### Exerc√≠cio 87: Desestrutura√ß√£o de Array

**Descri√ß√£o do Problema**: Dado o array `coordenadas = [10, 20, 30]`, use desestrutura√ß√£o para extrair o primeiro e o segundo elemento em vari√°veis `x` e `y` respectivamente. Imprima `x` e `y`.

**Entrada (Input)**:
```javascript
coordenadas = [10, 20, 30]
```

**Sa√≠da Esperada (Output)**:
```
X: 10
Y: 20
```

**Restri√ß√µes/Observa√ß√µes**: Utilize a sintaxe de desestrutura√ß√£o de array.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio87() {
  const coordenadas = [10, 20, 30];
  const [x, y] = coordenadas;
  console.log(\'X: \' + x);
  console.log(\'Y: \' + y);
}

// exercicio87();
```

---

### Exerc√≠cio 88: Par√¢metros de Fun√ß√£o com Desestrutura√ß√£o

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o `imprimirDetalhes` que receba um objeto `produto` com `nome` e `preco` e use desestrutura√ß√£o nos par√¢metros para imprimir esses detalhes.

**Entrada (Input)**:
```javascript
produto = { nome: \'Teclado\', preco: 75 }
```

**Sa√≠da Esperada (Output)**:
```
Produto: Teclado, Pre√ßo: 75
```

**Restri√ß√µes/Observa√ß√µes**: A desestrutura√ß√£o deve ocorrer diretamente na assinatura da fun√ß√£o.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio88() {
  function imprimirDetalhes({ nome, preco }) {
    console.log(`Produto: ${nome}, Pre√ßo: ${preco}`);
  }

  const produto = { nome: \'Teclado\', preco: 75 };
  imprimirDetalhes(produto);
}

// exercicio88();
```

---

### Exerc√≠cio 89: Spread Operator em Arrays

**Descri√ß√£o do Problema**: Dados dois arrays `arr1 = [1, 2]` e `arr2 = [3, 4]`, crie um novo array `arrCombinado` que contenha todos os elementos de `arr1` e `arr2` usando o spread operator. Imprima `arrCombinado`.

**Entrada (Input)**:
```javascript
arr1 = [1, 2]
arr2 = [3, 4]
```

**Sa√≠da Esperada (Output)**:
```
[1, 2, 3, 4]
```

**Restri√ß√µes/Observa√ß√µes**: O spread operator deve ser usado para combinar os arrays.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio89() {
  const arr1 = [1, 2];
  const arr2 = [3, 4];
  const arrCombinado = [...arr1, ...arr2];
  console.log(arrCombinado);
}

// exercicio89();
```

---

### Exerc√≠cio 90: Spread Operator em Objetos

**Descri√ß√£o do Problema**: Dados dois objetos `obj1 = { a: 1, b: 2 }` e `obj2 = { c: 3, d: 4 }`, crie um novo objeto `objCombinado` que contenha todas as propriedades de `obj1` e `obj2` usando o spread operator. Imprima `objCombinado`.

**Entrada (Input)**:
```javascript
obj1 = { a: 1, b: 2 }
obj2 = { c: 3, d: 4 }
```

**Sa√≠da Esperada (Output)**:
```javascript
{ a: 1, b: 2, c: 3, d: 4 }
```

**Restri√ß√µes/Observa√ß√µes**: O spread operator deve ser usado para combinar os objetos.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio90() {
  const obj1 = { a: 1, b: 2 };
  const obj2 = { c: 3, d: 4 };
  const objCombinado = { ...obj1, ...obj2 };
  console.log(objCombinado);
}

// exercicio90();
```

---

### Exerc√≠cio 91: Rest Parameters em Fun√ß√µes

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o `somarTudo` que receba um n√∫mero vari√°vel de argumentos e retorne a soma de todos eles. Utilize rest parameters.

**Entrada (Input)**:
```javascript
somarTudo(1, 2, 3, 4, 5)
```

**Sa√≠da Esperada (Output)**:
```
15
```

**Restri√ß√µes/Observa√ß√µes**: A fun√ß√£o deve ser capaz de somar qualquer quantidade de n√∫meros.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio91() {
  function somarTudo(...numeros) {
    return numeros.reduce((acc, curr) => acc + curr, 0);
  }

  console.log(somarTudo(1, 2, 3, 4, 5));
  console.log(somarTudo(10, 20));
}

// exercicio91();
```

---

### Exerc√≠cio 92: `map()` para Dobrar Valores

**Descri√ß√£o do Problema**: Dado um array de n√∫meros `[1, 2, 3, 4, 5]`, use `map()` para criar um novo array onde cada n√∫mero √© dobrado. Imprima o novo array.

**Entrada (Input)**:
```javascript
numeros = [1, 2, 3, 4, 5]
```

**Sa√≠da Esperada (Output)**:
```
[2, 4, 6, 8, 10]
```

**Restri√ß√µes/Observa√ß√µes**: N√£o modifique o array original.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio92() {
  const numeros = [1, 2, 3, 4, 5];
  const dobrados = numeros.map(num => num * 2);
  console.log(dobrados);
}

// exercicio92();
```

---

### Exerc√≠cio 93: `filter()` para N√∫meros Pares

**Descri√ß√£o do Problema**: Dado um array de n√∫meros `[1, 2, 3, 4, 5, 6]`, use `filter()` para criar um novo array contendo apenas os n√∫meros pares. Imprima o novo array.

**Entrada (Input)**:
```javascript
numeros = [1, 2, 3, 4, 5, 6]
```

**Sa√≠da Esperada (Output)**:
```
[2, 4, 6]
```

**Restri√ß√µes/Observa√ß√µes**: N√£o modifique o array original.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio93() {
  const numeros = [1, 2, 3, 4, 5, 6];
  const pares = numeros.filter(num => num % 2 === 0);
  console.log(pares);
}

// exercicio93();
```

---

### Exerc√≠cio 94: `reduce()` para Somar Elementos

**Descri√ß√£o do Problema**: Dado um array de n√∫meros `[1, 2, 3, 4, 5]`, use `reduce()` para calcular a soma de todos os elementos. Imprima a soma.

**Entrada (Input)**:
```javascript
numeros = [1, 2, 3, 4, 5]
```

**Sa√≠da Esperada (Output)**:
```
15
```

**Restri√ß√µes/Observa√ß√µes**: Forne√ßa um valor inicial para o acumulador.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio94() {
  const numeros = [1, 2, 3, 4, 5];
  const soma = numeros.reduce((acumulador, atual) => acumulador + atual, 0);
  console.log(soma);
}

// exercicio94();
```

---

### Exerc√≠cio 95: `forEach()` para Imprimir Elementos

**Descri√ß√£o do Problema**: Dado um array de strings `[\'ma√ß√£\', \'banana\', \'laranja\']`, use `forEach()` para imprimir cada fruta no console.

**Entrada (Input)**:
```javascript
frutas = [\'ma√ß√£\', \'banana\', \'laranja\']
```

**Sa√≠da Esperada (Output)**:
```
ma√ß√£
banana
laranja
```

**Restri√ß√µes/Observa√ß√µes**: Apenas imprima, n√£o retorne um novo array.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio95() {
  const frutas = [\'ma√ß√£\', \'banana\', \'laranja\'];
  frutas.forEach(fruta => console.log(fruta));
}

// exercicio95();
```

---

### Exerc√≠cio 96: `find()` para Encontrar Objeto

**Descri√ß√£o do Problema**: Dado um array de objetos `usuarios = [{ id: 1, nome: \'Alice\' }, { id: 2, nome: \'Bob\' }]`, use `find()` para encontrar o usu√°rio com `id: 2`. Imprima o objeto encontrado.

**Entrada (Input)**:
```javascript
usuarios = [{ id: 1, nome: \'Alice\' }, { id: 2, nome: \'Bob\' }]
```

**Sa√≠da Esperada (Output)**:
```javascript
{ id: 2, nome: \'Bob\' }
```

**Restri√ß√µes/Observa√ß√µes**: Retorna o primeiro elemento que satisfaz a condi√ß√£o.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio96() {
  const usuarios = [{ id: 1, nome: \'Alice\' }, { id: 2, nome: \'Bob\' }];
  const usuarioEncontrado = usuarios.find(usuario => usuario.id === 2);
  console.log(usuarioEncontrado);
}

// exercicio96();
```

---

### Exerc√≠cio 97: `findIndex()` para Encontrar √çndice

**Descri√ß√£o do Problema**: Dado um array de n√∫meros `[10, 20, 30, 40]`, use `findIndex()` para encontrar o √≠ndice do n√∫mero `30`. Imprima o √≠ndice.

**Entrada (Input)**:
```javascript
numeros = [10, 20, 30, 40]
```

**Sa√≠da Esperada (Output)**:
```
2
```

**Restri√ß√µes/Observa√ß√µes**: Retorna -1 se o elemento n√£o for encontrado.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio97() {
  const numeros = [10, 20, 30, 40];
  const indice = numeros.findIndex(num => num === 30);
  console.log(indice);
}

// exercicio97();
```

---

### Exerc√≠cio 98: `some()` para Verificar Exist√™ncia

**Descri√ß√£o do Problema**: Dado um array de n√∫meros `[1, 3, 5, 7]`, use `some()` para verificar se h√° algum n√∫mero par. Imprima `true` ou `false`.

**Entrada (Input)**:
```javascript
numeros = [1, 3, 5, 7]
```

**Sa√≠da Esperada (Output)**:
```
false
```

**Restri√ß√µes/Observa√ß√µes**: Retorna `true` se pelo menos um elemento satisfaz a condi√ß√£o.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio98() {
  const numeros = [1, 3, 5, 7];
  const temPar = numeros.some(num => num % 2 === 0);
  console.log(temPar);
}

// exercicio98();
```

---

### Exerc√≠cio 99: `every()` para Verificar Todos

**Descri√ß√£o do Problema**: Dado um array de n√∫meros `[2, 4, 6, 8]`, use `every()` para verificar se todos os n√∫meros s√£o pares. Imprima `true` ou `false`.

**Entrada (Input)**:
```javascript
numeros = [2, 4, 6, 8]
```

**Sa√≠da Esperada (Output)**:
```
true
```

**Restri√ß√µes/Observa√ß√µes**: Retorna `true` se todos os elementos satisfazem a condi√ß√£o.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio99() {
  const numeros = [2, 4, 6, 8];
  const todosPares = numeros.every(num => num % 2 === 0);
  console.log(todosPares);
}

// exercicio99();
```

---

### Exerc√≠cio 100: `sort()` para Ordenar Strings

**Descri√ß√£o do Problema**: Dado um array de strings `[\'banana\', \'ma√ß√£\', \'abacaxi\']`, use `sort()` para ordenar as strings em ordem alfab√©tica. Imprima o array ordenado.

**Entrada (Input)**:
```javascript
frutas = [\'banana\', \'ma√ß√£\', \'abacaxi\']
```

**Sa√≠da Esperada (Output)**:
```
[\'abacaxi\', \'banana\', \'ma√ß√£\']
```

**Restri√ß√µes/Observa√ß√µes**: `sort()` modifica o array original. Fa√ßa uma c√≥pia se necess√°rio.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio100() {
  const frutas = [\'banana\', \'ma√ß√£\', \'abacaxi\'];
  const frutasOrdenadas = [...frutas].sort(); // Cria uma c√≥pia para n√£o modificar o original
  console.log(frutasOrdenadas);
}

// exercicio100();
```

---

### Exerc√≠cio 101: `sort()` para Ordenar N√∫meros (Crescente)

**Descri√ß√£o do Problema**: Dado um array de n√∫meros `[3, 1, 4, 1, 5, 9]`, use `sort()` com uma fun√ß√£o de compara√ß√£o para ordenar os n√∫meros em ordem crescente. Imprima o array ordenado.

**Entrada (Input)**:
```javascript
numeros = [3, 1, 4, 1, 5, 9]
```

**Sa√≠da Esperada (Output)**:
```
[1, 1, 3, 4, 5, 9]
```

**Restri√ß√µes/Observa√ß√µes**: A fun√ß√£o de compara√ß√£o √© essencial para n√∫meros.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio101() {
  const numeros = [3, 1, 4, 1, 5, 9];
  const numerosOrdenados = [...numeros].sort((a, b) => a - b);
  console.log(numerosOrdenados);
}

// exercicio101();
```

---

### Exerc√≠cio 102: `sort()` para Ordenar N√∫meros (Decrescente)

**Descri√ß√£o do Problema**: Dado um array de n√∫meros `[3, 1, 4, 1, 5, 9]`, use `sort()` com uma fun√ß√£o de compara√ß√£o para ordenar os n√∫meros em ordem decrescente. Imprima o array ordenado.

**Entrada (Input)**:
```javascript
numeros = [3, 1, 4, 1, 5, 9]
```

**Sa√≠da Esperada (Output)**:
```
[9, 5, 4, 3, 1, 1]
```

**Restri√ß√µes/Observa√ß√µes**: A fun√ß√£o de compara√ß√£o deve ser `(a, b) => b - a`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio102() {
  const numeros = [3, 1, 4, 1, 5, 9];
  const numerosOrdenados = [...numeros].sort((a, b) => b - a);
  console.log(numerosOrdenados);
}

// exercicio102();
```

---

### Exerc√≠cio 103: `map()` com Objetos

**Descri√ß√£o do Problema**: Dado um array de objetos `produtos = [{ id: 1, nome: \'Caneta\', preco: 2 }, { id: 2, nome: \'Caderno\', preco: 15 }]`, use `map()` para criar um novo array contendo apenas os nomes dos produtos. Imprima o novo array.

**Entrada (Input)**:
```javascript
produtos = [{ id: 1, nome: \'Caneta\', preco: 2 }, { id: 2, nome: \'Caderno\', preco: 15 }]
```

**Sa√≠da Esperada (Output)**:
```
[\'Caneta\', \'Caderno\']
```

**Restri√ß√µes/Observa√ß√µes**: Extraia a propriedade `nome` de cada objeto.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio103() {
  const produtos = [{ id: 1, nome: \'Caneta\', preco: 2 }, { id: 2, nome: \'Caderno\', preco: 15 }];
  const nomesProdutos = produtos.map(produto => produto.nome);
  console.log(nomesProdutos);
}

// exercicio103();
```

---

### Exerc√≠cio 104: `filter()` com Objetos

**Descri√ß√£o do Problema**: Dado um array de objetos `produtos = [{ id: 1, nome: \'Caneta\', preco: 2 }, { id: 2, nome: \'Caderno\', preco: 15 }, { id: 3, nome: \'L√°pis\', preco: 1 }]`, use `filter()` para obter apenas os produtos com `preco` maior que `5`. Imprima o novo array.

**Entrada (Input)**:
```javascript
produtos = [{ id: 1, nome: \'Caneta\', preco: 2 }, { id: 2, nome: \'Caderno\', preco: 15 }, { id: 3, nome: \'L√°pis\', preco: 1 }]
```

**Sa√≠da Esperada (Output)**:
```javascript
[{ id: 2, nome: \'Caderno\', preco: 15 }]
```

**Restri√ß√µes/Observa√ß√µes**: Filtre com base na propriedade `preco`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio104() {
  const produtos = [{ id: 1, nome: \'Caneta\', preco: 2 }, { id: 2, nome: \'Caderno\', preco: 15 }, { id: 3, nome: \'L√°pis\', preco: 1 }];
  const produtosCaros = produtos.filter(produto => produto.preco > 5);
  console.log(produtosCaros);
}

// exercicio104();
```

---

### Exerc√≠cio 105: `reduce()` para Contar Ocorr√™ncias em Array de Objetos

**Descri√ß√£o do Problema**: Dado um array de objetos `pedidos = [{ status: \'pendente\' }, { status: \'entregue\' }, { status: \'pendente\' }]`, use `reduce()` para contar quantos pedidos est√£o com `status: \'pendente\'`. Imprima a contagem.

**Entrada (Input)**:
```javascript
pedidos = [{ status: \'pendente\' }, { status: \'entregue\' }, { status: \'pendente\' }]
```

**Sa√≠da Esperada (Output)**:
```
2
```

**Restri√ß√µes/Observa√ß√µes**: O acumulador deve ser um n√∫mero.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio105() {
  const pedidos = [{ status: \'pendente\' }, { status: \'entregue\' }, { status: \'pendente\' }];
  const pendentes = pedidos.reduce((count, pedido) => {
    return pedido.status === \'pendente\' ? count + 1 : count;
  }, 0);
  console.log(pendentes);
}

// exercicio105();
```

---

### Exerc√≠cio 106: `reduce()` para Agrupar Objetos por Propriedade

**Descri√ß√£o do Problema**: Dado um array de objetos `pessoas = [{ nome: \'Ana\', idade: 30 }, { nome: \'Jo√£o\', idade: 25 }, { nome: \'Maria\', idade: 30 }]`, use `reduce()` para agrupar as pessoas por idade. O resultado deve ser um objeto onde as chaves s√£o as idades e os valores s√£o arrays de pessoas com aquela idade.

**Entrada (Input)**:
```javascript
pessoas = [{ nome: \'Ana\', idade: 30 }, { nome: \'Jo√£o\', idade: 25 }, { nome: \'Maria\', idade: 30 }]
```

**Sa√≠da Esperada (Output)**:
```javascript
{
  \'25\': [ { nome: \'Jo√£o\', idade: 25 } ],
  \'30\': [ { nome: \'Ana\', idade: 30 }, { nome: \'Maria\', idade: 30 } ]
}
```

**Restri√ß√µes/Observa√ß√µes**: O acumulador deve ser um objeto.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio106() {
  const pessoas = [{ nome: \'Ana\', idade: 30 }, { nome: \'Jo√£o\', idade: 25 }, { nome: \'Maria\', idade: 30 }];
  const pessoasPorIdade = pessoas.reduce((acc, pessoa) => {
    const idade = pessoa.idade;
    if (!acc[idade]) {
      acc[idade] = [];
    }
    acc[idade].push(pessoa);
    return acc;
  }, {});
  console.log(pessoasPorIdade);
}

// exercicio106();
```

---

### Exerc√≠cio 107: Fun√ß√µes de Alta Ordem - `map()` e `filter()` Encadeados

**Descri√ß√£o do Problema**: Dado um array de n√∫meros `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`, primeiro filtre os n√∫meros pares e depois dobre cada um deles. Imprima o array resultante.

**Entrada (Input)**:
```javascript
numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

**Sa√≠da Esperada (Output)**:
```
[4, 8, 12, 16, 20]
```

**Restri√ß√µes/Observa√ß√µes**: Encadeie os m√©todos `filter()` e `map()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio107() {
  const numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  const resultado = numeros.filter(num => num % 2 === 0).map(num => num * 2);
  console.log(resultado);
}

// exercicio107();
```

---

### Exerc√≠cio 108: Fun√ß√µes de Alta Ordem - `map()` e `reduce()` Encadeados

**Descri√ß√£o do Problema**: Dado um array de objetos `itens = [{ valor: 10, quantidade: 2 }, { valor: 5, quantidade: 3 }]`, calcule o valor total de todos os itens (valor * quantidade) usando `map()` e `reduce()`. Imprima o total.

**Entrada (Input)**:
```javascript
itens = [{ valor: 10, quantidade: 2 }, { valor: 5, quantidade: 3 }]
```

**Sa√≠da Esperada (Output)**:
```
35 // (10*2 + 5*3 = 20 + 15 = 35)
```

**Restri√ß√µes/Observa√ß√µes**: Primeiro mapeie para os totais de cada item, depois reduza para a soma.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio108() {
  const itens = [{ valor: 10, quantidade: 2 }, { valor: 5, quantidade: 3 }];
  const total = itens
    .map(item => item.valor * item.quantidade)
    .reduce((acc, curr) => acc + curr, 0);
  console.log(total);
}

// exercicio108();
```

---

### Exerc√≠cio 109: Closures B√°sicas

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o `criarContador()` que retorne outra fun√ß√£o. A fun√ß√£o interna deve incrementar um contador privado e retorn√°-lo a cada chamada. Demonstre o uso criando dois contadores independentes.

**Entrada (Input)**:
```javascript
contador1 = criarContador()
contador2 = criarContador()
contador1()
contador1()
contador2()
```

**Sa√≠da Esperada (Output)**:
```
1
2
1
```

**Restri√ß√µes/Observa√ß√µes**: O contador deve ser encapsulado e n√£o acess√≠vel diretamente.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio109() {
  function criarContador() {
    let count = 0;
    return function() {
      count++;
      return count;
    };
  }

  const contador1 = criarContador();
  const contador2 = criarContador();

  console.log(contador1()); // 1
  console.log(contador1()); // 2
  console.log(contador2()); // 1
}

// exercicio109();
```

---

### Exerc√≠cio 110: Currying de Fun√ß√µes

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o `multiplicar(a)` que retorne uma nova  que, por sua vez, retorne `a * b`. Demonstre o uso criando uma fun√ß√£o `dobrar` e `triplicar` a partir dela.

**Entrada (Input)**:
```javascript
dobrar = multiplicar(2)
triplicar = multiplicar(3)
dobrar(5)
triplicar(5)
```

**Sa√≠da Esperada (Output)**:
```
10
15
```

**Restri√ß√µes/Observa√ß√µes**: A fun√ß√£o deve ser curried.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio110() {
  function multiplicar(a) {
    {
      return a * b;
    };
  }

  const dobrar = multiplicar(2);
  const triplicar = multiplicar(3);

  console.log(dobrar(5));
  console.log(triplicar(5));
}

// exercicio110();
```

---

### Exerc√≠cio 111: Recurs√£o - Fatorial

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o recursiva `fatorial(n)` que calcule o fatorial de um n√∫mero `n`.

**Entrada (Input)**:
```javascript
fatorial(5)
```

**Sa√≠da Esperada (Output)**:
```
120
```

**Restri√ß√µes/Observa√ß√µes**: O caso base deve ser `n === 0` retornando `1`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio111(n) {
  if (n === 0) {
    return 1;
  }
  return n * exercicio111(n - 1);
}

// console.log(exercicio111(5));
// console.log(exercicio111(0));
// console.log(exercicio111(3));
```

---

### Exerc√≠cio 112: Recurs√£o - Soma de Array

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o recursiva `somaArray(arr)` que calcule a soma de todos os elementos de um array de n√∫meros.

**Entrada (Input)**:
```javascript
somaArray([1, 2, 3, 4, 5])
```

**Sa√≠da Esperada (Output)**:
```
15
```

**Restri√ß√µes/Observa√ß√µes**: O caso base deve ser um array vazio retornando `0`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio112(arr) {
  if (arr.length === 0) {
    return 0;
  }
  return arr[0] + exercicio112(arr.slice(1));
}

// console.log(exercicio112([1, 2, 3, 4, 5]));
// console.log(exercicio112([]));
// console.log(exercicio112([10]));
```

---

### Exerc√≠cio 113: Callback Simples

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o `executarDepois(callback)` que recebe uma fun√ß√£o de callback e a executa ap√≥s 2 segundos. Demonstre com um `console.log`.

**Entrada (Input)**:
```javascript
executarDepois(() => console.log(\'Executado ap√≥s 2 segundos\'))
```

**Sa√≠da Esperada (Output)**:
```
// (Ap√≥s 2 segundos)
Executado ap√≥s 2 segundos
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `setTimeout()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio113() {
  function executarDepois(callback) {
    setTimeout(callback, 2000);
  }

  executarDepois(() => console.log(\'Executado ap√≥s 2 segundos\'));
}

// exercicio113();
```

---

### Exerc√≠cio 114: Callback com Par√¢metros

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o `processarDados(dados, callback)` que recebe um array de `dados` e uma fun√ß√£o de `callback`. A fun√ß√£o deve processar os dados (ex: dobrar cada n√∫mero) e passar o resultado para o callback. Demonstre.

**Entrada (Input)**:
```javascript
processarDados([1, 2, 3], (resultado) => console.log(resultado))
```

**Sa√≠da Esperada (Output)**:
```
[2, 4, 6]
```

**Restri√ß√µes/Observa√ß√µes**: O callback deve receber o resultado do processamento.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio114() {
  function processarDados(dados, callback) {
    const dadosProcessados = dados.map(item => item * 2);
    callback(dadosProcessados);
  }

  processarDados([1, 2, 3], (resultado) => console.log(resultado));
}

// exercicio114();
```

---

### Exerc√≠cio 115: Criar e Formatar Objeto `Date`

**Descri√ß√£o do Problema**: Crie um objeto `Date` para a data atual e imprima-o no formato `DD/MM/YYYY HH:MM:SS`.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
```
// Exemplo: 05/10/2025 14:30:00
```

**Restri√ß√µes/Observa√ß√µes**: Utilize m√©todos do objeto `Date` para obter dia, m√™s, ano, hora, minuto, segundo.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio115() {
  const dataAtual = new Date();

  const dia = String(dataAtual.getDate()).padStart(2, \'0\');
  const mes = String(dataAtual.getMonth() + 1).padStart(2, \'0\'); // M√™s √© 0-indexado
  const ano = dataAtual.getFullYear();
  const horas = String(dataAtual.getHours()).padStart(2, \'0\');
  const minutos = String(dataAtual.getMinutes()).padStart(2, \'0\');
  const segundos = String(dataAtual.getSeconds()).padStart(2, \'0\');

  const dataFormatada = `${dia}/${mes}/${ano} ${horas}:${minutos}:${segundos}`;
  console.log(dataFormatada);
}

// exercicio115();
```

---

### Exerc√≠cio 116: Calcular Diferen√ßa entre Datas

**Descri√ß√£o do Problema**: Crie duas datas: `data1 = new Date(\'2025-01-01\')` e `data2 = new Date(\'2025-01-31\')`. Calcule a diferen√ßa em dias entre elas e imprima o resultado.

**Entrada (Input)**:
```javascript
data1 = new Date(\'2025-01-01\')
data2 = new Date(\'2025-01-31\')
```

**Sa√≠da Esperada (Output)**:
```
Diferen√ßa em dias: 30
```

**Restri√ß√µes/Observa√ß√µes**: A diferen√ßa de tempo √© em milissegundos. 1 dia = 24 * 60 * 60 * 1000 milissegundos.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio116() {
  const data1 = new Date(\'2025-01-01\');
  const data2 = new Date(\'2025-01-31\');

  const diferencaMs = data2.getTime() - data1.getTime();
  const diferencaDias = diferencaMs / (1000 * 60 * 60 * 24);

  console.log(\'Diferen√ßa em dias: \' + diferencaDias);
}

// exercicio116();
```

---

### Exerc√≠cio 117: Adicionar Dias a uma Data

**Descri√ß√£o do Problema**: Dada uma data `dataBase = new Date(\'2025-01-15\')`, adicione 10 dias a ela e imprima a nova data formatada como `YYYY-MM-DD`.

**Entrada (Input)**:
```javascript
dataBase = new Date(\'2025-01-15\')
diasParaAdicionar = 10
```

**Sa√≠da Esperada (Output)**:
```
Nova data: 2025-01-25
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `setDate()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio117() {
  const dataBase = new Date(\'2025-01-15\');
  const diasParaAdicionar = 10;

  dataBase.setDate(dataBase.getDate() + diasParaAdicionar);

  const ano = dataBase.getFullYear();
  const mes = String(dataBase.getMonth() + 1).padStart(2, \'0\');
  const dia = String(dataBase.getDate()).padStart(2, \'0\');

  console.log(`Nova data: ${ano}-${mes}-${dia}`);
}

// exercicio117();
```

---

### Exerc√≠cio 118: Express√£o Regular - Validar Email Simples

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o `validarEmail(email)` que use uma express√£o regular para verificar se uma string √© um email em um formato b√°sico (ex: `nome@dominio.com`). Retorne `true` ou `false`.

**Entrada (Input)**:
```javascript
email1 = \'teste@example.com\'
email2 = \'teste@example\'
```

**Sa√≠da Esperada (Output)**:
```
true (para email1)
false (para email2)
```

**Restri√ß√µes/Observa√ß√µes**: A regex n√£o precisa ser exaustiva, apenas cobrir o formato comum.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio118(email) {
  const regex = /^\S+@\S+\.\S+$/;
  return regex.test(email);
}

// console.log(exercicio118(\'teste@example.com\'));
// console.log(exercicio118(\'teste@example\'));
// console.log(exercicio118(\'email.valido@sub.dominio.co.uk\'));
```

---

### Exerc√≠cio 119: Express√£o Regular - Extrair N√∫meros

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o `extrairNumeros(texto)` que use uma express√£o regular para extrair todos os n√∫meros de uma string e retorn√°-los em um array de strings.

**Entrada (Input)**:
```javascript
texto = \'O pre√ßo √© R$ 123.45 e o c√≥digo √© ABC-678.\'
```

**Sa√≠da Esperada (Output)**:
```
[\'123\', \'45\', \'678\']
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `match()` com a flag global (`g`).

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio119(texto) {
  const regex = /\d+/g;
  return texto.match(regex) || [];
}

// console.log(exercicio119(\'O pre√ßo √© R$ 123.45 e o c√≥digo √© ABC-678.\'));
// console.log(exercicio119(\'N√£o h√° n√∫meros aqui.\'));
```

---

### Exerc√≠cio 120: Express√£o Regular - Substituir Padr√µes

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o `anonimizarTelefone(texto)` que substitua todos os n√∫meros de telefone no formato `(XX) XXXX-XXXX` por `(XX) ****-XXXX`.

**Entrada (Input)**:
```javascript
texto = \'Meu telefone √© (11) 9876-5432 e o do trabalho √© (21) 1234-5678.\'
```

**Sa√≠da Esperada (Output)**:
```
Meu telefone √© (11) ****-5432 e o do trabalho √© (21) ****-5678.
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `replace()` com express√£o regular e grupos de captura.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio120(texto) {
  const regex = /(\(\d{2}\))\s*\d{4}-(\d{4})/g;
  return texto.replace(regex, \'$1 ****-$2\');
}

// console.log(exercicio120(\'Meu telefone √© (11) 9876-5432 e o do trabalho √© (21) 1234-5678.\'));
```

---

### Exerc√≠cio 121: Tratamento de Erros com `try...catch`

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o `dividir(a, b)` que retorne a divis√£o de `a` por `b`. Se `b` for `0`, lance um erro. Use `try...catch` para chamar a fun√ß√£o e lidar com o erro, imprimindo uma mensagem apropriada.

**Entrada (Input)**:
```javascript
dividir(10, 2)
dividir(10, 0)
```

**Sa√≠da Esperada (Output)**:
```
Resultado da divis√£o: 5
Erro: Divis√£o por zero n√£o permitida.
```

**Restri√ß√µes/Observa√ß√µes**: O erro deve ser um `Error` com uma mensagem clara.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio121() {
  function dividir(a, b) {
    if (b === 0) {
      throw new Error(\'Divis√£o por zero n√£o permitida.\');
    }
    return a / b;
  }

  try {
    console.log(\'Resultado da divis√£o: \' + dividir(10, 2));
  } catch (error) {
    console.log(\'Erro: \' + error.message);
  }

  try {
    console.log(\'Resultado da divis√£o: \' + dividir(10, 0));
  } catch (error) {
    console.log(\'Erro: \' + error.message);
  }
}

// exercicio121();
```

---

### Exerc√≠cio 122: `try...catch...finally`

**Descri√ß√£o do Problema**: Modifique o exerc√≠cio anterior para incluir um bloco `finally` que sempre imprima a mensagem "Opera√ß√£o de divis√£o finalizada.", independentemente de ter ocorrido um erro ou n√£o.

**Entrada (Input)**:
```javascript
dividir(10, 2)
dividir(10, 0)
```

**Sa√≠da Esperada (Output)**:
```
Resultado da divis√£o: 5
Opera√ß√£o de divis√£o finalizada.
Erro: Divis√£o por zero n√£o permitida.
Opera√ß√£o de divis√£o finalizada.
```

**Restri√ß√µes/Observa√ß√µes**: O bloco `finally` deve ser executado sempre.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio122() {
  function dividir(a, b) {
    if (b === 0) {
      throw new Error(\'Divis√£o por zero n√£o permitida.\');
    }
    return a / b;
  }

  try {
    console.log(\'Resultado da divis√£o: \' + dividir(10, 2));
  } catch (error) {
    console.log(\'Erro: \' + error.message);
  } finally {
    console.log(\'Opera√ß√£o de divis√£o finalizada.\');
  }

  try {
    console.log(\'Resultado da divis√£o: \' + dividir(10, 0));
  } catch (error) {
    console.log(\'Erro: \' + error.message);
  } finally {
    console.log(\'Opera√ß√£o de divis√£o finalizada.\');
  }
}

// exercicio122();
```

---

### Exerc√≠cio 123: M√≥dulos CommonJS - Exportar Fun√ß√£o

**Descri√ß√£o do Problema**: Crie um arquivo `matematica.js` que exporte uma fun√ß√£o `somar(a, b)`. Em um arquivo principal, importe e use essa fun√ß√£o.

**Entrada (Input)**:
(Conte√∫do de `matematica.js` e do arquivo principal)

**Sa√≠da Esperada (Output)**:
```
Soma: 7
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `module.exports` e `require()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
// matematica.js
/*
function somar(a, b) {
  return a + b;
}
module.exports = somar;
*/

// Arquivo principal (ex: main.js)
/*
const somar = require(\'./matematica\');
console.log(\'Soma: \' + somar(3, 4));
*/

// Para simular no ambiente de exerc√≠cio:
function exercicio123() {
  // Simula√ß√£o do conte√∫do de matematica.js
  const matematicaModule = {
    exports: null
  };
  (function(module, exports) {
    function somar(a, b) {
      return a + b;
    }
    module.exports = somar;
  })(matematicaModule, matematicaModule.exports);

  const somar = matematicaModule.exports;
  console.log(\'Soma: \' + somar(3, 4));
}

// exercicio123();
```

---

### Exerc√≠cio 124: M√≥dulos CommonJS - Exportar Objeto

**Descri√ß√£o do Problema**: Crie um arquivo `utilidades.js` que exporte um objeto com duas fun√ß√µes: `multiplicar(a, b)` e `dividir(a, b)`. Em um arquivo principal, importe e use essas fun√ß√µes.

**Entrada (Input)**:
(Conte√∫do de `utilidades.js` e do arquivo principal)

**Sa√≠da Esperada (Output)**:
```
Multiplica√ß√£o: 20
Divis√£o: 5
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `module.exports = { ... }`.

**Solu√ß√£o (Esqueleto)**:
```javascript
// utilidades.js
/*
function multiplicar(a, b) {
  return a * b;
}
function dividir(a, b) {
  return a / b;
}
module.exports = { multiplicar, dividir };
*/

// Arquivo principal (ex: main.js)
/*
const { multiplicar, dividir } = require(\'./utilidades\');
console.log(\'Multiplica√ß√£o: \' + multiplicar(4, 5));
console.log(\'Divis√£o: \' + dividir(25, 5));
*/

// Para simular no ambiente de exerc√≠cio:
function exercicio124() {
  // Simula√ß√£o do conte√∫do de utilidades.js
  const utilidadesModule = {
    exports: null
  };
  (function(module, exports) {
    function multiplicar(a, b) {
      return a * b;
    }
    function dividir(a, b) {
      return a / b;
    }
    module.exports = { multiplicar, dividir };
  })(utilidadesModule, utilidadesModule.exports);

  const { multiplicar, dividir } = utilidadesModule.exports;
  console.log(\'Multiplica√ß√£o: \' + multiplicar(4, 5));
  console.log(\'Divis√£o: \' + dividir(25, 5));
}

// exercicio124();
```

---

### Exerc√≠cio 125: M√≥dulos ES Modules - Exportar e Importar (B√°sico)

**Descri√ß√£o do Problema**: Crie um arquivo `saudacao.mjs` que exporte uma fun√ß√£o `dizerOla(nome)`. Em um arquivo principal `app.mjs`, importe e use essa fun√ß√£o. (Assuma que o ambiente Node.js est√° configurado para ES Modules).

**Entrada (Input)**:
(Conte√∫do de `saudacao.mjs` e `app.mjs`)

**Sa√≠da Esperada (Output)**:
```
Ol√°, Mundo!
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `export` e `import`.

**Solu√ß√£o (Esqueleto)**:
```javascript
// saudacao.mjs
/*
export function dizerOla(nome) {
  return `Ol√°, ${nome}!`;
}
*/

// app.mjs
/*
import { dizerOla } from \'./saudacao.mjs\';
console.log(dizerOla(\'Mundo\'));
*/

// Para simular no ambiente de exerc√≠cio (n√£o √© poss√≠vel simular import/export diretamente aqui):
function exercicio125() {
  console.log(\'Este exerc√≠cio requer a execu√ß√£o em arquivos .mjs separados para demonstrar ES Modules.\');
  console.log(\'Exemplo de uso:\');
  console.log(\'// saudacao.mjs\');
  console.log(\'export function dizerOla(nome) { return `Ol√°, ${nome}!`; }\');
  console.log(\'// app.mjs\');
  console.log(\'import { dizerOla } from \'./saudacao.mjs\';\');
  console.log(\'console.log(dizerOla(\'Mundo\'));\');
}

// exercicio125();
```

---

### Exerc√≠cio 126: Algoritmo de Busca Linear

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o `buscaLinear(arr, alvo)` que receba um array e um valor `alvo`. A fun√ß√£o deve retornar o √≠ndice da primeira ocorr√™ncia do `alvo` no array, ou `-1` se n√£o for encontrado.

**Entrada (Input)**:
```javascript
arr = [5, 2, 8, 12, 3]
alvo1 = 8
alvo2 = 10
```

**Sa√≠da Esperada (Output)**:
```
2
-1
```

**Restri√ß√µes/Observa√ß√µes**: Implemente a busca linear manualmente (sem `indexOf`).

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio126(arr, alvo) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === alvo) {
      return i;
    }
  }
  return -1;
}

// console.log(exercicio126([5, 2, 8, 12, 3], 8));
// console.log(exercicio126([5, 2, 8, 12, 3], 10));
```

---

### Exerc√≠cio 127: Algoritmo de Busca Bin√°ria (Array Ordenado)

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o `buscaBinaria(arr, alvo)` que receba um array **ordenado** e um valor `alvo`. A fun√ß√£o deve retornar o √≠ndice do `alvo` no array, ou `-1` se n√£o for encontrado.

**Entrada (Input)**:
```javascript
arr = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
alvo1 = 23
alvo2 = 10
```

**Sa√≠da Esperada (Output)**:
```
5
-1
```

**Restri√ß√µes/Observa√ß√µes**: O array de entrada deve estar ordenado. Implemente a busca bin√°ria.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio127(arr, alvo) {
  let inicio = 0;
  let fim = arr.length - 1;

  while (inicio <= fim) {
    let meio = Math.floor((inicio + fim) / 2);

    if (arr[meio] === alvo) {
      return meio;
    } else if (arr[meio] < alvo) {
      inicio = meio + 1;
    } else {
      fim = meio - 1;
    }
  }
  return -1;
}

// console.log(exercicio127([2, 5, 8, 12, 16, 23, 38, 56, 72, 91], 23));
// console.log(exercicio127([2, 5, 8, 12, 16, 23, 38, 56, 72, 91], 10));
```

---

### Exerc√≠cio 128: Algoritmo Bubble Sort

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o `bubbleSort(arr)` que receba um array de n√∫meros e o ordene em ordem crescente usando o algoritmo Bubble Sort. Retorne o array ordenado.

**Entrada (Input)**:
```javascript
arr = [64, 34, 25, 12, 22, 11, 90]
```

**Sa√≠da Esperada (Output)**:
```
[11, 12, 22, 25, 34, 64, 90]
```

**Restri√ß√µes/Observa√ß√µes**: Implemente o Bubble Sort.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio128(arr) {
  const n = arr.length;
  const novoArr = [...arr]; // Criar uma c√≥pia para n√£o modificar o original

  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - 1 - i; j++) {
      if (novoArr[j] > novoArr[j + 1]) {
        // Troca os elementos
        [novoArr[j], novoArr[j + 1]] = [novoArr[j + 1], novoArr[j]];
      }
    }
  }
  return novoArr;
}

// console.log(exercicio128([64, 34, 25, 12, 22, 11, 90]));
```

---

### Exerc√≠cio 129: Algoritmo Selection Sort

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o `selectionSort(arr)` que receba um array de n√∫meros e o ordene em ordem crescente usando o algoritmo Selection Sort. Retorne o array ordenado.

**Entrada (Input)**:
```javascript
arr = [64, 25, 12, 22, 11]
```

**Sa√≠da Esperada (Output)**:
```
[11, 12, 22, 25, 64]
```

**Restri√ß√µes/Observa√ß√µes**: Implemente o Selection Sort.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio129(arr) {
  const n = arr.length;
  const novoArr = [...arr]; // Criar uma c√≥pia para n√£o modificar o original

  for (let i = 0; i < n - 1; i++) {
    let minIndex = i;
    for (let j = i + 1; j < n; j++) {
      if (novoArr[j] < novoArr[minIndex]) {
        minIndex = j;
      }
    }
    // Troca o elemento m√≠nimo encontrado com o primeiro elemento n√£o ordenado
    if (minIndex !== i) {
      [novoArr[i], novoArr[minIndex]] = [novoArr[minIndex], novoArr[i]];
    }
  }
  return novoArr;
}

// console.log(exercicio129([64, 25, 12, 22, 11]));
```

---

### Exerc√≠cio 130: Leitura de Arquivo de Texto (S√≠ncrona)

**Descri√ß√£o do Problema**: Crie um arquivo `dados.txt` com algum texto. Em seguida, use o m√≥dulo `fs` do Node.js para ler o conte√∫do deste arquivo de forma s√≠ncrona e imprimi-lo no console.

**Entrada (Input)**:
(Conte√∫do do arquivo `dados.txt`)
```
// dados.txt
Ol√°, este √© um arquivo de teste.
```

**Sa√≠da Esperada (Output)**:
```
Conte√∫do do arquivo:
Ol√°, este √© um arquivo de teste.
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `fs.readFileSync()`. O arquivo `dados.txt` deve ser criado previamente.

**Solu√ß√£o (Esqueleto)**:
```javascript
// Para simular no ambiente de exerc√≠cio, primeiro crie o arquivo:
// shell.exec(\'echo "Ol√°, este √© um arquivo de teste." > dados.txt\');

function exercicio130() {
  const fs = require(\'fs\');
  try {
    const data = fs.readFileSync(\'dados.txt\', \'utf8\');
    console.log(\'Conte√∫do do arquivo:\n\' + data);
  } catch (err) {
    console.error(\'Erro ao ler o arquivo:\', err);
  }
}

// exercicio130();
```

---

### Exerc√≠cio 131: Escrita de Arquivo de Texto (S√≠ncrona)

**Descri√ß√£o do Problema**: Use o m√≥dulo `fs` do Node.js para escrever uma string em um arquivo `saida.txt` de forma s√≠ncrona. Ap√≥s a escrita, imprima uma mensagem de sucesso.

**Entrada (Input)**:
```javascript
conteudo = \'Este √© o conte√∫do a ser escrito no arquivo.\'
```

**Sa√≠da Esperada (Output)**:
```
Arquivo saida.txt escrito com sucesso!
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `fs.writeFileSync()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio131() {
  const fs = require(\'fs\');
  const conteudo = \'Este √© o conte√∫do a ser escrito no arquivo.\';
  try {
    fs.writeFileSync(\'saida.txt\', conteudo, \'utf8\');
    console.log(\'Arquivo saida.txt escrito com sucesso!\');
  } catch (err) {
    console.error(\'Erro ao escrever no arquivo:\', err);
  }
}

// exercicio131();
```

---

### Exerc√≠cio 132: Leitura de Arquivo de Texto (Ass√≠ncrona)

**Descri√ß√£o do Problema**: Crie um arquivo `async_dados.txt` com algum texto. Em seguida, use o m√≥dulo `fs` do Node.js para ler o conte√∫do deste arquivo de forma ass√≠ncrona e imprimi-lo no console.

**Entrada (Input)**:
(Conte√∫do do arquivo `async_dados.txt`)
```
// async_dados.txt
Conte√∫do ass√≠ncrono.
```

**Sa√≠da Esperada (Output)**:
```
Conte√∫do do arquivo ass√≠ncrono:
Conte√∫do ass√≠ncrono.
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `fs.readFile()` com callback.

**Solu√ß√£o (Esqueleto)**:
```javascript
// Para simular no ambiente de exerc√≠cio, primeiro crie o arquivo:
// shell.exec(\'echo "Conte√∫do ass√≠ncrono." > async_dados.txt\');

function exercicio132() {
  const fs = require(\'fs\');
  fs.readFile(\'async_dados.txt\', \'utf8\', (err, data) => {
    if (err) {
      console.error(\'Erro ao ler o arquivo ass√≠ncrono:\', err);
      return;
    }
    console.log(\'Conte√∫do do arquivo ass√≠ncrono:\n\' + data);
  });
}

// exercicio132();
```

---

### Exerc√≠cio 133: Escrita de Arquivo de Texto (Ass√≠ncrona)

**Descri√ß√£o do Problema**: Use o m√≥dulo `fs` do Node.js para escrever uma string em um arquivo `async_saida.txt` de forma ass√≠ncrona. Ap√≥s a escrita, imprima uma mensagem de sucesso.

**Entrada (Input)**:
```javascript
conteudo = \'Este √© o conte√∫do ass√≠ncrono a ser escrito.\'
```

**Sa√≠da Esperada (Output)**:
```
Arquivo async_saida.txt escrito com sucesso!
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `fs.writeFile()` com callback.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio133() {
  const fs = require(\'fs\');
  const conteudo = \'Este √© o conte√∫do ass√≠ncrono a ser escrito.\';
  fs.writeFile(\'async_saida.txt\', conteudo, \'utf8\', (err) => {
    if (err) {
      console.error(\'Erro ao escrever no arquivo ass√≠ncrono:\', err);
      return;
    }
    console.log(\'Arquivo async_saida.txt escrito com sucesso!\');
  });
}

// exercicio133();
```

---

### Exerc√≠cio 134: Promises - B√°sico

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o `simularOperacaoAssincrona(sucesso)` que retorne uma Promise. Se `sucesso` for `true`, a Promise deve resolver com "Opera√ß√£o conclu√≠da!". Se `false`, deve rejeitar com "Opera√ß√£o falhou!". Demonstre o uso com `.then()` e `.catch()`.

**Entrada (Input)**:
```javascript
simularOperacaoAssincrona(true)
simularOperacaoAssincrona(false)
```

**Sa√≠da Esperada (Output)**:
```
Sucesso: Opera√ß√£o conclu√≠da!
Erro: Opera√ß√£o falhou!
```

**Restri√ß√µes/Observa√ß√µes**: A Promise deve resolver/rejeitar ap√≥s um pequeno atraso (ex: 100ms) para simular assincronicidade.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio134() {
  function simularOperacaoAssincrona(sucesso) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (sucesso) {
          resolve(\'Opera√ß√£o conclu√≠da!\');
        } else {
          reject(\'Opera√ß√£o falhou!\');
        }
      }, 100);
    });
  }

  simularOperacaoAssincrona(true)
    .then(resultado => console.log(\'Sucesso: \' + resultado))
    .catch(erro => console.log(\'Erro: \' + erro));

  simularOperacaoAssincrona(false)
    .then(resultado => console.log(\'Sucesso: \' + resultado))
    .catch(erro => console.log(\'Erro: \' + erro));
}

// exercicio134();
```

---

### Exerc√≠cio 135: `async/await` - B√°sico

**Descri√ß√£o do Problema**: Converta a fun√ß√£o `simularOperacaoAssincrona` do exerc√≠cio anterior para usar `async/await`. Crie uma fun√ß√£o `executarOperacao()` que chame a fun√ß√£o ass√≠ncrona e lide com o sucesso e o erro.

**Entrada (Input)**:
```javascript
executarOperacao(true)
executarOperacao(false)
```

**Sa√≠da Esperada (Output)**:
```
Sucesso: Opera√ß√£o conclu√≠da!
Erro: Opera√ß√£o falhou!
```

**Restri√ß√µes/Observa√ß√µes**: A fun√ß√£o `executarOperacao` deve ser `async` e usar `await`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio135() {
  function simularOperacaoAssincrona(sucesso) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (sucesso) {
          resolve(\'Opera√ß√£o conclu√≠da!\');
        } else {
          reject(\'Opera√ß√£o falhou!\');
        }
      }, 100);
    });
  }

  async function executarOperacao(sucesso) {
    try {
      const resultado = await simularOperacaoAssincrona(sucesso);
      console.log(\'Sucesso: \' + resultado);
    } catch (erro) {
      console.log(\'Erro: \' + erro);
    }
  }

  executarOperacao(true);
  executarOperacao(false);
}

// exercicio135();
```

---

### Exerc√≠cio 136: `Promise.all()`

**Descri√ß√£o do Problema**: Crie tr√™s Promises que resolvem com valores diferentes ap√≥s tempos diferentes (ex: 100ms, 200ms, 50ms). Use `Promise.all()` para esperar que todas resolvam e imprima um array com seus resultados.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
```
Todos resolvidos: [ \'Primeiro\', \'Segundo\', \'Terceiro\' ]
```

**Restri√ß√µes/Observa√ß√µes**: Demonstre o comportamento de `Promise.all()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio136() {
  const p1 = new Promise(resolve => setTimeout(() => resolve(\'Primeiro\'), 100));
  const p2 = new Promise(resolve => setTimeout(() => resolve(\'Segundo\'), 200));
  const p3 = new Promise(resolve => setTimeout(() => resolve(\'Terceiro\'), 50));

  Promise.all([p1, p2, p3])
    .then(resultados => console.log(\'Todos resolvidos: \' + resultados))
    .catch(erro => console.log(\'Erro: \' + erro));
}

// exercicio136();
```

---

### Exerc√≠cio 137: `Promise.race()`

**Descri√ß√£o do Problema**: Crie tr√™s Promises que resolvem ou rejeitam com valores diferentes ap√≥s tempos diferentes. Use `Promise.race()` para obter o resultado da primeira Promise a resolver ou rejeitar. Imprima o resultado.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
```
Primeiro a terminar: Terceiro
```

**Restri√ß√µes/Observa√ß√µes**: Demonstre o comportamento de `Promise.race()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio137() {
  const p1 = new Promise(resolve => setTimeout(() => resolve(\'Primeiro\'), 100));
  const p2 = new Promise(resolve => setTimeout(() => resolve(\'Segundo\'), 200));
  const p3 = new Promise(resolve => setTimeout(() => resolve(\'Terceiro\'), 50));

  Promise.race([p1, p2, p3])
    .then(resultado => console.log(\'Primeiro a terminar: \' + resultado))
    .catch(erro => console.log(\'Erro: \' + erro));
}

// exercicio137();
```

---

### Exerc√≠cio 138: Classes - Cria√ß√£o B√°sica

**Descri√ß√£o do Problema**: Crie uma classe `Animal` com um construtor que receba `nome` e `especie`. Adicione um m√©todo `apresentar()` que imprima uma sauda√ß√£o. Crie uma inst√¢ncia e chame o m√©todo.

**Entrada (Input)**:
```javascript
meuAnimal = new Animal(\'Rex\', \'Cachorro\')
meuAnimal.apresentar()
```

**Sa√≠da Esperada (Output)**:
```
Ol√°, meu nome √© Rex e eu sou um Cachorro.
```

**Restri√ß√µes/Observa√ß√µes**: Utilize a sintaxe `class`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio138() {
  class Animal {
    constructor(nome, especie) {
      this.nome = nome;
      this.especie = especie;
    }

    apresentar() {
      console.log(`Ol√°, meu nome √© ${this.nome} e eu sou um ${this.especie}.`);
    }
  }

  const meuAnimal = new Animal(\'Rex\', \'Cachorro\');
  meuAnimal.apresentar();
}

// exercicio138();
```

---

### Exerc√≠cio 139: Classes - Heran√ßa

**Descri√ß√£o do Problema**: Crie uma classe `Cachorro` que herde de `Animal`. Adicione um construtor que tamb√©m receba `raca` e um m√©todo `latir()` que imprima "Au au!". Crie uma inst√¢ncia de `Cachorro` e chame `apresentar()` e `latir()`.

**Entrada (Input)**:
```javascript
meuCachorro = new Cachorro(\'Bob\', \'Cachorro\', \'Golden Retriever\')
meuCachorro.apresentar()
meuCachorro.latir()
```

**Sa√≠da Esperada (Output)**:
```
Ol√°, meu nome √© Bob e eu sou um Cachorro.
Au au!
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `extends` e `super()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio139() {
  class Animal {
    constructor(nome, especie) {
      this.nome = nome;
      this.especie = especie;
    }

    apresentar() {
      console.log(`Ol√°, meu nome √© ${this.nome} e eu sou um ${this.especie}.`);
    }
  }

  class Cachorro extends Animal {
    constructor(nome, especie, raca) {
      super(nome, especie);
      this.raca = raca;
    }

    latir() {
      console.log(\'Au au!\');
    }
  }

  const meuCachorro = new Cachorro(\'Bob\', \'Cachorro\', \'Golden Retriever\');
  meuCachorro.apresentar();
  meuCachorro.latir();
}

// exercicio139();
```

---

### Exerc√≠cio 140: Classes - Getters e Setters

**Descri√ß√£o do Problema**: Crie uma classe `Pessoa` com um construtor que receba `nome`. Adicione um getter e um setter para a propriedade `idade`. O setter deve validar que a idade √© um n√∫mero positivo. Demonstre o uso.

**Entrada (Input)**:
```javascript
joao = new Pessoa(\'Jo√£o\')
joao.idade = 25
joao.idade = -5
```

**Sa√≠da Esperada (Output)**:
```
Idade definida: 25
Idade inv√°lida: -5
Idade atual: 25
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `get` e `set`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio140() {
  class Pessoa {
    constructor(nome) {
      this.nome = nome;
      this._idade = 0; // Conven√ß√£o para propriedade interna
    }

    get idade() {
      return this._idade;
    }

    set idade(novaIdade) {
      if (novaIdade >= 0) {
        this._idade = novaIdade;
        console.log(`Idade definida: ${novaIdade}`);
      } else {
        console.log(`Idade inv√°lida: ${novaIdade}`);
      }
    }
  }

  const joao = new Pessoa(\'Jo√£o\');
  joao.idade = 25;
  joao.idade = -5;
  console.log(`Idade atual: ${joao.idade}`);
}

// exercicio140();
```

---

### Exerc√≠cio 141: Pilha (Stack) - Implementa√ß√£o B√°sica

**Descri√ß√£o do Problema**: Implemente uma classe `Pilha` com os m√©todos `push(elemento)`, `pop()` e `peek()`. `push` adiciona um elemento, `pop` remove e retorna o topo, `peek` retorna o topo sem remover.

**Entrada (Input)**:
```javascript
pilha = new Pilha()
pilha.push(10)
pilha.push(20)
```

**Sa√≠da Esperada (Output)**:
```
Topo: 20
Removido: 20
Topo: 10
```

**Restri√ß√µes/Observa√ß√µes**: Utilize um array interno para armazenar os elementos.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio141() {
  class Pilha {
    constructor() {
      this.elementos = [];
    }

    push(elemento) {
      this.elementos.push(elemento);
    }

    pop() {
      if (this.isEmpty()) {
        return undefined;
      }
      return this.elementos.pop();
    }

    peek() {
      if (this.isEmpty()) {
        return undefined;
      }
      return this.elementos[this.elementos.length - 1];
    }

    isEmpty() {
      return this.elementos.length === 0;
    }

    size() {
      return this.elementos.length;
    }
  }

  const minhaPilha = new Pilha();
  minhaPilha.push(10);
  minhaPilha.push(20);
  console.log(\'Topo: \' + minhaPilha.peek());
  console.log(\'Removido: \' + minhaPilha.pop());
  console.log(\'Topo: \' + minhaPilha.peek());
}

// exercicio141();
```

---

### Exerc√≠cio 142: Fila (Queue) - Implementa√ß√£o B√°sica

**Descri√ß√£o do Problema**: Implemente uma classe `Fila` com os m√©todos `enqueue(elemento)`, `dequeue()` e `front()`. `enqueue` adiciona ao final, `dequeue` remove e retorna o primeiro, `front` retorna o primeiro sem remover.

**Entrada (Input)**:
```javascript
fila = new Fila()
fila.enqueue(\'A\')
fila.enqueue(\'B\')
```

**Sa√≠da Esperada (Output)**:
```
Frente: A
Removido: A
Frente: B
```

**Restri√ß√µes/Observa√ß√µes**: Utilize um array interno para armazenar os elementos.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio142() {
  class Fila {
    constructor() {
      this.elementos = [];
    }

    enqueue(elemento) {
      this.elementos.push(elemento);
    }

    dequeue() {
      if (this.isEmpty()) {
        return undefined;
      }
      return this.elementos.shift();
    }

    front() {
      if (this.isEmpty()) {
        return undefined;
      }
      return this.elementos[0];
    }

    isEmpty() {
      return this.elementos.length === 0;
    }

    size() {
      return this.elementos.length;
    }
  }

  const minhaFila = new Fila();
  minhaFila.enqueue(\'A\');
  minhaFila.enqueue(\'B\');
  console.log(\'Frente: \' + minhaFila.front());
  console.log(\'Removido: \' + minhaFila.dequeue());
  console.log(\'Frente: \' + minhaFila.front());
}

// exercicio142();
```

---

### Exerc√≠cio 143: Lista Encadeada (Linked List) - Adicionar ao Final

**Descri√ß√£o do Problema**: Implemente uma classe `Node` e uma classe `LinkedList`. A `LinkedList` deve ter um m√©todo `add(valor)` que adiciona um novo n√≥ ao final da lista. Imprima os valores da lista.

**Entrada (Input)**:
```javascript
lista = new LinkedList()
lista.add(1)
lista.add(2)
lista.add(3)
```

**Sa√≠da Esperada (Output)**:
```
1 -> 2 -> 3 -> null
```

**Restri√ß√µes/Observa√ß√µes**: Apenas a funcionalidade de adicionar ao final √© necess√°ria.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio143() {
  class Node {
    constructor(valor) {
      this.valor = valor;
      this.proximo = null;
    }
  }

  class LinkedList {
    constructor() {
      this.head = null;
      this.size = 0;
    }

    add(valor) {
      const newNode = new Node(valor);
      if (!this.head) {
        this.head = newNode;
      } else {
        let current = this.head;
        while (current.proximo) {
          current = current.proximo;
        }
        current.proximo = newNode;
      }
      this.size++;
    }

    printList() {
      let current = this.head;
      let result = \'\';
      while (current) {
        result += `${current.valor} -> `;
        current = current.proximo;
      }
      result += \'null\';
      console.log(result);
    }
  }

  const lista = new LinkedList();
  lista.add(1);
  lista.add(2);
  lista.add(3);
  lista.printList();
}

// exercicio143();
```

---

### Exerc√≠cio 144: √Årvore Bin√°ria de Busca (BST) - Inser√ß√£o B√°sica

**Descri√ß√£o do Problema**: Implemente uma classe `Node` e uma classe `BST`. A `BST` deve ter um m√©todo `insert(valor)` que insere um novo n√≥ na posi√ß√£o correta. N√£o √© necess√°rio implementar balanceamento.

**Entrada (Input)**:
```javascript
bst = new BST()
bst.insert(10)
bst.insert(5)
bst.insert(15)
bst.insert(3)
bst.insert(7)
```

**Sa√≠da Esperada (Output)**:
(N√£o h√° sa√≠da direta para a inser√ß√£o, mas a estrutura interna deve estar correta)

**Restri√ß√µes/Observa√ß√µes**: Apenas a funcionalidade de inser√ß√£o √© necess√°ria.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio144() {
  class Node {
    constructor(valor) {
      this.valor = valor;
      this.left = null;
      this.right = null;
    }
  }

  class BST {
    constructor() {
      this.root = null;
    }

    insert(valor) {
      const newNode = new Node(valor);
      if (this.root === null) {
        this.root = newNode;
      } else {
        this.insertNode(this.root, newNode);
      }
    }

    insertNode(node, newNode) {
      if (newNode.valor < node.valor) {
        if (node.left === null) {
          node.left = newNode;
        } else {
          this.insertNode(node.left, newNode);
        }
      } else {
        if (node.right === null) {
          node.right = newNode;
        } else {
          this.insertNode(node.right, newNode);
        }
      }
    }

    // Para verificar a estrutura (opcional, para depura√ß√£o)
    inOrderTraverse(node, callback) {
      if (node !== null) {
        this.inOrderTraverse(node.left, callback);
        callback(node.valor);
        this.inOrderTraverse(node.right, callback);
      }
    }
  }

  const bst = new BST();
  bst.insert(10);
  bst.insert(5);
  bst.insert(15);
  bst.insert(3);
  bst.insert(7);

  // Para verificar a ordem (opcional)
  // const resultados = [];
  // bst.inOrderTraverse(bst.root, valor => resultados.push(valor));
  // console.log(resultados); // Sa√≠da esperada: [3, 5, 7, 10, 15]
}

// exercicio144();
```

---

### Exerc√≠cio 145: Algoritmo Quick Sort (Conceito)

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o `quickSort` que receba um array de n√∫meros e o ordene em ordem crescente usando o algoritmo Quick Sort. Retorne o array ordenado.

**Entrada (Input)**:
```
array = [3, 6, 8, 10, 1, 2, 1]
```

**Sa√≠da Esperada (Output)**:
```
[1, 1, 2, 3, 6, 8, 10]
```

**Restri√ß√µes/Observa√ß√µes**: Implemente o algoritmo Quick Sort. Pode ser uma implementa√ß√£o simplificada.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio145(array) {
  if (array.length <= 1) {
    return array;
  }

  const pivot = array[Math.floor(array.length / 2)];
  const left = [];
  const right = [];
  const equal = [];

  for (let i = 0; i < array.length; i++) {
    if (array[i] < pivot) {
      left.push(array[i]);
    } else if (array[i] > pivot) {
      right.push(array[i]);
    } else {
      equal.push(array[i]);
    }
  }

  return [...exercicio145(left), ...equal, ...exercicio145(right)];
}

// console.log(exercicio145([3, 6, 8, 10, 1, 2, 1]));
```

---

### Exerc√≠cio 146: Algoritmo Merge Sort (Conceito)

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o `mergeSort` que receba um array de n√∫meros e o ordene em ordem crescente usando o algoritmo Merge Sort. Retorne o array ordenado.

**Entrada (Input)**:
```
array = [38, 27, 43, 3, 9, 82, 10]
```

**Sa√≠da Esperada (Output)**:
```
[3, 9, 10, 27, 38, 43, 82]
```

**Restri√ß√µes/Observa√ß√µes**: Implemente o algoritmo Merge Sort.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio146(array) {
  if (array.length <= 1) {
    return array;
  }

  const meio = Math.floor(array.length / 2);
  const left = array.slice(0, meio);
  const right = array.slice(meio);

  const sortedLeft = exercicio146(left);
  const sortedRight = exercicio146(right);

  return merge(sortedLeft, sortedRight);
}

function merge(left, right) {
  let result = [];
  let leftIndex = 0;
  let rightIndex = 0;

  while (leftIndex < left.length && rightIndex < right.length) {
    if (left[leftIndex] < right[rightIndex]) {
      result.push(left[leftIndex]);
      leftIndex++;
    } else {
      result.push(right[rightIndex]);
      rightIndex++;
    }
  }

  return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));
}

// console.log(exercicio146([38, 27, 43, 3, 9, 82, 10]));
```

---

### Exerc√≠cio 147: Design Pattern Singleton (Conceito)

**Descri√ß√£o do Problema**: Implemente o padr√£o Singleton para uma classe `Configuracao`. Garanta que apenas uma inst√¢ncia de `Configuracao` possa ser criada e que todas as chamadas para obter a inst√¢ncia retornem a mesma.

**Entrada (Input)**:
```javascript
instancia1 = Configuracao.getInstance()
instancia2 = Configuracao.getInstance()
```

**Sa√≠da Esperada (Output)**:
```
true (instancia1 === instancia2)
```

**Restri√ß√µes/Observa√ß√µes**: A classe deve ter um m√©todo est√°tico `getInstance()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio147() {
  class Configuracao {
    constructor() {
      if (Configuracao.instance) {
        return Configuracao.instance;
      }
      this.settings = { theme: \'default\', language: \'en\' };
      Configuracao.instance = this;
    }

    static getInstance() {
      if (!Configuracao.instance) {
        Configuracao.instance = new Configuracao();
      }
      return Configuracao.instance;
    }

    getSettings() {
      return this.settings;
    }

    setSetting(key, value) {
      this.settings[key] = value;
    }
  }

  const instance1 = Configuracao.getInstance();
  const instance2 = Configuracao.getInstance();

  console.log(instance1 === instance2); // Deve ser true
  instance1.setSetting(\'theme\', \'dark\');
  console.log(instance2.getSettings().theme); // Deve ser \'dark\'
}

// exercicio147();
```

---

### Exerc√≠cio 148: Design Pattern Factory (Conceito)

**Descri√ß√£o do Problema**: Implemente um padr√£o Factory para criar diferentes tipos de ve√≠culos (Carro, Moto). Crie uma `VehicleFactory` com um m√©todo `createVehicle(tipo, marca)` que retorne a inst√¢ncia correta.

**Entrada (Input)**:
```javascript
carro = VehicleFactory.createVehicle(\'carro\', \'Toyota\')
moto = VehicleFactory.createVehicle(\'moto\', \'Honda\')
```

**Sa√≠da Esperada (Output)**:
```
Carro Toyota criado.
Moto Honda criada.
```

**Restri√ß√µes/Observa√ß√µes**: As classes `Carro` e `Moto` devem ter um m√©todo `apresentar()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio148() {
  class Carro {
    constructor(marca) {
      this.marca = marca;
    }
    apresentar() {
      console.log(`Carro ${this.marca} criado.`);
    }
  }

  class Moto {
    constructor(marca) {
      this.marca = marca;
    }
    apresentar() {
      console.log(`Moto ${this.marca} criada.`);
    }
  }

  class VehicleFactory {
    static createVehicle(tipo, marca) {
      switch (tipo.toLowerCase()) {
        case \'carro\':
          return new Carro(marca);
        case \'moto\':
          return new Moto(marca);
        default:
          throw new Error(\'Tipo de ve√≠culo desconhecido.\');
      }
    }
  }

  const carro = VehicleFactory.createVehicle(\'carro\', \'Toyota\');
  carro.apresentar();

  const moto = VehicleFactory.createVehicle(\'moto\', \'Honda\');
  moto.apresentar();
}

// exercicio148();
```

---

### Exerc√≠cio 149: Design Pattern Observer (Conceito)

**Descri√ß√£o do Problema**: Implemente um padr√£o Observer. Crie uma classe `Subject` (observ√°vel) e uma classe `Observer` (observador). O `Subject` deve ter m√©todos para `adicionarObserver`, `removerObserver` e `notificarObservers`. O `Observer` deve ter um m√©todo `atualizar`.

**Entrada (Input)**:
```javascript
subject = new Subject()
observer1 = new Observer(\'Observer 1\')
observer2 = new Observer(\'Observer 2\')
subject.adicionarObserver(observer1)
subject.adicionarObserver(observer2)
subject.notificarObservers(\'Novo evento!\')
```

**Sa√≠da Esperada (Output)**:
```
Observer 1 recebeu: Novo evento!
Observer 2 recebeu: Novo evento!
```

**Restri√ß√µes/Observa√ß√µes**: Demonstre a comunica√ß√£o entre Subject e Observers.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio149() {
  class Subject {
    constructor() {
      this.observers = [];
    }

    adicionarObserver(observer) {
      this.observers.push(observer);
    }

    removerObserver(observer) {
      this.observers = this.observers.filter(obs => obs !== observer);
    }

    notificarObservers(data) {
      this.observers.forEach(observer => observer.atualizar(data));
    }
  }

  class Observer {
    constructor(nome) {
      this.nome = nome;
    }

    atualizar(data) {
      console.log(`${this.nome} recebeu: ${data}`);
    }
  }

  const subject = new Subject();
  const observer1 = new Observer(\'Observer 1\');
  const observer2 = new Observer(\'Observer 2\');

  subject.adicionarObserver(observer1);
  subject.adicionarObserver(observer2);

  subject.notificarObservers(\'Novo evento!\');

  subject.removerObserver(observer1);
  subject.notificarObservers(\'Outro evento!\');
}

// exercicio149();
```

---

### Exerc√≠cio 150: Manipula√ß√£o de Strings com `slice`

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba uma string e dois √≠ndices (in√≠cio e fim) e retorne a parte da string entre esses √≠ndices (exclusivo no fim).

**Entrada (Input)**:
```
texto = \'JavaScript\'
inicio = 0
fim = 4
```

**Sa√≠da Esperada (Output)**:
```
Java
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `String.slice()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio150(texto, inicio, fim) {
  return texto.slice(inicio, fim);
}

// console.log(exercicio150(\'JavaScript\', 0, 4));
// console.log(exercicio150(\'Hello World\', 6, 11));
```

---

### Exerc√≠cio 151: Manipula√ß√£o de Strings com `substring`

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba uma string e dois √≠ndices (in√≠cio e fim) e retorne a parte da string entre esses √≠ndices. Se o √≠ndice de in√≠cio for maior que o de fim, eles devem ser trocados automaticamente.

**Entrada (Input)**:
```
texto = \'JavaScript\'
inicio = 4
fim = 0
```

**Sa√≠da Esperada (Output)**:
```
Java
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `String.substring()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio151(texto, inicio, fim) {
  return texto.substring(inicio, fim);
}

// console.log(exercicio151(\'JavaScript\', 4, 0)); // Sa√≠da: Java
// console.log(exercicio151(\'Hello World\', 0, 5)); // Sa√≠da: Hello
```

---

### Exerc√≠cio 152: Manipula√ß√£o de Strings com `substr` (Deprecated)

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba uma string, um √≠ndice de in√≠cio e um comprimento, e retorne a parte da string a partir do √≠ndice de in√≠cio com o comprimento especificado.

**Entrada (Input)**:
```
texto = \'JavaScript\'
inicio = 4
comprimento = 6
```

**Sa√≠da Esperada (Output)**:
```
Script
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `String.substr()`. Note que `substr` √© considerado obsoleto.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio152(texto, inicio, comprimento) {
  return texto.substr(inicio, comprimento);
}

// console.log(exercicio152(\'JavaScript\', 4, 6));
// console.log(exercicio152(\'Hello World\', 0, 5));
```

---

### Exerc√≠cio 153: Converter String para Array de Caracteres

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba uma string e retorne um array contendo cada caractere da string como um elemento.

**Entrada (Input)**:
```
texto = \'abc\'
```

**Sa√≠da Esperada (Output)**:
```
[\'a\', \'b\', \'c\']
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `String.split(\'\')` ou o spread operator `[...string]`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio153(texto) {
  return texto.split(\'\');
  // Ou:
  // return [...texto];
}

// console.log(exercicio153(\'abc\'));
```

---

### Exerc√≠cio 154: Verificar se um Objeto Possui uma Propriedade

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um objeto e o nome de uma propriedade (string), e retorne `true` se o objeto possuir essa propriedade, `false` caso contr√°rio.

**Entrada (Input)**:
```javascript
objeto = { a: 1, b: 2 }
propriedade1 = \'a\'
propriedade2 = \'c\'
```

**Sa√≠da Esperada (Output)**:
```
true (para propriedade1)
false (para propriedade2)
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `Object.prototype.hasOwnProperty.call()` ou o operador `in`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio154(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
  // Ou:
  // return prop in obj;
}

// console.log(exercicio154({ a: 1, b: 2 }, \'a\'));
// console.log(exercicio154({ a: 1, b: 2 }, \'c\'));
```

---

### Exerc√≠cio 155: Clonar um Objeto Profundamente (JSON)

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um objeto (que pode conter objetos aninhados) e retorne uma c√≥pia profunda dele. Assuma que o objeto cont√©m apenas tipos de dados que podem ser serializados para JSON.

**Entrada (Input)**:
```javascript
objetoOriginal = { a: 1, b: { c: 2 } }
```

**Sa√≠da Esperada (Output)**:
```javascript
{ a: 1, b: { c: 2 } }
// E objetoOriginal !== clone (refer√™ncia diferente)
// E objetoOriginal.b !== clone.b (refer√™ncia diferente para o objeto aninhado)
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `JSON.parse(JSON.stringify(obj))`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio155(obj) {
  return JSON.parse(JSON.stringify(obj));
}

// const original = { a: 1, b: { c: 2 } };
// const clone = exercicio155(original);
// console.log(clone);
// console.log(original === clone); // false
// console.log(original.b === clone.b); // false
```

---

### Exerc√≠cio 156: Mesclar Objetos com `Object.assign()`

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba dois objetos e retorne um novo objeto que √© a fus√£o dos dois. Se houver chaves duplicadas, o valor do segundo objeto deve prevalecer.

**Entrada (Input)**:
```javascript
objeto1 = { a: 1, b: 2 }
objeto2 = { b: 3, c: 4 }
```

**Sa√≠da Esperada (Output)**:
```javascript
{ a: 1, b: 3, c: 4 }
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `Object.assign()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio156(obj1, obj2) {
  return Object.assign({}, obj1, obj2);
}

// console.log(exercicio156({ a: 1, b: 2 }, { b: 3, c: 4 }));
```

---

### Exerc√≠cio 157: Manipular Arrays com `splice()` - Remover Elementos

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array, um √≠ndice de in√≠cio e um n√∫mero de elementos a serem removidos. Retorne um novo array sem os elementos removidos. N√£o modifique o array original.

**Entrada (Input)**:
```
array = [1, 2, 3, 4, 5]
inicio = 2
quantidade = 2
```

**Sa√≠da Esperada (Output)**:
```
[1, 2, 5]
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `slice()` para criar uma c√≥pia e depois `splice()` na c√≥pia.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio157(array, inicio, quantidade) {
  const novoArray = array.slice(); // Cria uma c√≥pia
  novoArray.splice(inicio, quantidade);
  return novoArray;
}

// console.log(exercicio157([1, 2, 3, 4, 5], 2, 2));
```

---

### Exerc√≠cio 158: Manipular Arrays com `splice()` - Adicionar Elementos

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array, um √≠ndice de in√≠cio e um ou mais elementos a serem adicionados. Retorne um novo array com os elementos adicionados. N√£o modifique o array original.

**Entrada (Input)**:
```
array = [1, 2, 5]
inicio = 2
elementos = [3, 4]
```

**Sa√≠da Esperada (Output)**:
```
[1, 2, 3, 4, 5]
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `slice()` para criar uma c√≥pia e depois `splice()` na c√≥pia.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio158(array, inicio, ...elementos) {
  const novoArray = array.slice(); // Cria uma c√≥pia
  novoArray.splice(inicio, 0, ...elementos);
  return novoArray;
}

// console.log(exercicio158([1, 2, 5], 2, 3, 4));
```

---

### Exerc√≠cio 159: Manipular Arrays com `splice()` - Substituir Elementos

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array, um √≠ndice de in√≠cio, um n√∫mero de elementos a serem removidos e um ou mais elementos a serem adicionados. Retorne um novo array com os elementos substitu√≠dos. N√£o modifique o array original.

**Entrada (Input)**:
```
array = [1, 2, 10, 11, 5]
inicio = 2
quantidadeRemover = 2
elementosAdicionar = [3, 4]
```

**Sa√≠da Esperada (Output)**:
```
[1, 2, 3, 4, 5]
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `slice()` para criar uma c√≥pia e depois `splice()` na c√≥pia.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio159(array, inicio, quantidadeRemover, ...elementosAdicionar) {
  const novoArray = array.slice(); // Cria uma c√≥pia
  novoArray.splice(inicio, quantidadeRemover, ...elementosAdicionar);
  return novoArray;
}

// console.log(exercicio159([1, 2, 10, 11, 5], 2, 2, 3, 4));
```

---

### Exerc√≠cio 160: Gerar um Array de N√∫meros em um Intervalo

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba dois n√∫meros inteiros, `inicio` e `fim`, e retorne um array contendo todos os n√∫meros inteiros nesse intervalo (inclusive).

**Entrada (Input)**:
```
inicio = 1
fim = 5
```

**Sa√≠da Esperada (Output)**:
```
[1, 2, 3, 4, 5]
```

**Restri√ß√µes/Observa√ß√µes**: Assuma `inicio <= fim`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio160(inicio, fim) {
  const resultado = [];
  for (let i = inicio; i <= fim; i++) {
    resultado.push(i);
  }
  return resultado;
}

// console.log(exercicio160(1, 5));
// console.log(exercicio160(-2, 2));
```

---

### Exerc√≠cio 161: Flattening de Array (Array de Arrays)

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array de arrays e retorne um novo array "achatado" (flattened), contendo todos os elementos dos sub-arrays em uma √∫nica dimens√£o.

**Entrada (Input)**:
```
arrayAninhado = [[1, 2], [3, 4], [5]]
```

**Sa√≠da Esperada (Output)**:
```
[1, 2, 3, 4, 5]
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `Array.prototype.flat()` ou `reduce()` com `concat()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio161(arrayAninhado) {
  return arrayAninhado.flat();
  // Ou com reduce:
  // return arrayAninhado.reduce((acc, val) => acc.concat(val), []);
}

// console.log(exercicio161([[1, 2], [3, 4], [5]]));
```

---

### Exerc√≠cio 162: Contar Frequ√™ncia de Elementos em um Array

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array de elementos e retorne um objeto onde as chaves s√£o os elementos √∫nicos e os valores s√£o suas respectivas contagens (frequ√™ncia).

**Entrada (Input)**:
```
array = [\'a\', \'b\', \'a\', \'c\', \'b\', \'a\']
```

**Sa√≠da Esperada (Output)**:
```javascript
{ a: 3, b: 2, c: 1 }
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `reduce()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio162(array) {
  return array.reduce((acc, elemento) => {
    acc[elemento] = (acc[elemento] || 0) + 1;
    return acc;
  }, {});
}

// console.log(exercicio162([\'a\', \'b\', \'a\', \'c\', \'b\', \'a\']));
```

---

### Exerc√≠cio 163: Remover Propriedades de um Objeto (Retornar Novo Objeto)

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um objeto e um array de chaves a serem removidas. Retorne um novo objeto sem essas propriedades. N√£o modifique o objeto original.

**Entrada (Input)**:
```javascript
objeto = { a: 1, b: 2, c: 3 }
chavesParaRemover = [\'b\', \'c\']
```

**Sa√≠da Esperada (Output)**:
```javascript
{ a: 1 }
```

**Restri√ß√µes/Observa√ß√µes**: Utilize desestrutura√ß√£o com rest operator ou `reduce()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio163(obj, chavesParaRemover) {
  return Object.keys(obj).reduce((acc, key) => {
    if (!chavesParaRemover.includes(key)) {
      acc[key] = obj[key];
    }
    return acc;
  }, {});
  // Ou com desestrutura√ß√£o (mais complexo para m√∫ltiplas chaves din√¢micas)
  // const { b, c, ...rest } = obj; // Se as chaves fossem fixas
  // return rest;
}

// console.log(exercicio163({ a: 1, b: 2, c: 3 }, [\'b\', \'c\']));
```

---

### Exerc√≠cio 164: Converter Objeto para Array de Pares Chave-Valor

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um objeto e retorne um array de arrays, onde cada sub-array √© um par `[chave, valor]`.

**Entrada (Input)**:
```javascript
objeto = { a: 1, b: \'dois\' }
```

**Sa√≠da Esperada (Output)**:
```javascript
[[\'a\', 1], [\'b\', \'dois\']]
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `Object.entries()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio164(obj) {
  return Object.entries(obj);
}

// console.log(exercicio164({ a: 1, b: \'dois\' }));
```

---

### Exerc√≠cio 165: Converter Array de Pares Chave-Valor para Objeto

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array de pares `[chave, valor]` e retorne um objeto.

**Entrada (Input)**:
```javascript
pares = [[\'a\', 1], [\'b\', \'dois\']]
```

**Sa√≠da Esperada (Output)**:
```javascript
{ a: 1, b: \'dois\' }
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `Object.fromEntries()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio165(pares) {
  return Object.fromEntries(pares);
}

// console.log(exercicio165([["a", 1], ["b", "dois"]]));
```

---

### Exerc√≠cio 166: Criar um Array com Valores √önicos de M√∫ltiplos Arrays

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba dois ou mais arrays e retorne um novo array contendo todos os valores √∫nicos de todos os arrays combinados.

**Entrada (Input)**:
```
array1 = [1, 2, 3]
array2 = [3, 4, 5]
array3 = [5, 6, 7]
```

**Sa√≠da Esperada (Output)**:
```
[1, 2, 3, 4, 5, 6, 7]
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `Set` e o spread operator.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio166(...arrays) {
  const combinado = [].concat(...arrays);
  return [...new Set(combinado)];
}

// console.log(exercicio166([1, 2, 3], [3, 4, 5], [5, 6, 7]));
```

---

### Exerc√≠cio 167: Interse√ß√£o de Dois Arrays

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba dois arrays e retorne um novo array contendo apenas os elementos que est√£o presentes em ambos os arrays (interse√ß√£o).

**Entrada (Input)**:
```
array1 = [1, 2, 3, 4]
array2 = [3, 4, 5, 6]
```

**Sa√≠da Esperada (Output)**:
```
[3, 4]
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `filter()` e `includes()` ou `Set`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio167(array1, array2) {
  const set2 = new Set(array2);
  return array1.filter(item => set2.has(item));
}

// console.log(exercicio167([1, 2, 3, 4], [3, 4, 5, 6]));
```

---

### Exerc√≠cio 168: Diferen√ßa entre Dois Arrays

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba dois arrays e retorne um novo array contendo os elementos que est√£o no primeiro array, mas n√£o no segundo.

**Entrada (Input)**:
```
array1 = [1, 2, 3, 4]
array2 = [3, 4, 5, 6]
```

**Sa√≠da Esperada (Output)**:
```
[1, 2]
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `filter()` e `includes()` ou `Set`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio168(array1, array2) {
  const set2 = new Set(array2);
  return array1.filter(item => !set2.has(item));
}

// console.log(exercicio168([1, 2, 3, 4], [3, 4, 5, 6]));
```

---

### Exerc√≠cio 169: Gerar um Array de N√∫meros Aleat√≥rios

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um n√∫mero `quantidade` e dois limites `min` e `max`, e retorne um array com `quantidade` n√∫meros inteiros aleat√≥rios entre `min` e `max` (inclusive).

**Entrada (Input)**:
```
quantidade = 5
min = 1
max = 10
```

**Sa√≠da Esperada (Output)**:
```
// Exemplo: [3, 8, 1, 9, 4] (os n√∫meros ser√£o aleat√≥rios)
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `Math.random()` e `Math.floor()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio169(quantidade, min, max) {
  const resultado = [];
  for (let i = 0; i < quantidade; i++) {
    const numAleatorio = Math.floor(Math.random() * (max - min + 1)) + min;
    resultado.push(numAleatorio);
  }
  return resultado;
}

// console.log(exercicio169(5, 1, 10));
```

---

### Exerc√≠cio 170: Validar CPF (Formato B√°sico)

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba uma string e retorne `true` se ela for um CPF v√°lido no formato `XXX.XXX.XXX-XX`, `false` caso contr√°rio. A valida√ß√£o √© apenas do formato, n√£o dos d√≠gitos verificadores.

**Entrada (Input)**:
```
cpf1 = \'123.456.789-00\'
cpf2 = \'12345678900\'
```

**Sa√≠da Esperada (Output)**:
```
true (para cpf1)
false (para cpf2)
```

**Restri√ß√µes/Observa√ß√µes**: Utilize express√£o regular.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio170(cpf) {
  const regex = /^\d{3}\.\d{3}\.\d{3}-\d{2}$/;
  return regex.test(cpf);
}

// console.log(exercicio170(\'123.456.789-00\'));
// console.log(exercicio170(\'12345678900\'));
```

---



# Exerc√≠cios de JavaScript - N√≠vel Avan√ßado (171-250)

Esta se√ß√£o cont√©m 80 exerc√≠cios de JavaScript focados em conceitos avan√ßados, como programa√ß√£o ass√≠ncrona, estruturas de dados complexas, algoritmos, design patterns, testes e seguran√ßa, projetados para serem executados em um ambiente Node.js.

## Estrutura dos Exerc√≠cios

Cada exerc√≠cio segue a estrutura definida no plano:

*   **T√≠tulo do Exerc√≠cio**: Nome do exerc√≠cio.
*   **Descri√ß√£o do Problema**: O que o exerc√≠cio deve resolver.
*   **Entrada (Input)**: Exemplos de dados de entrada.
*   **Sa√≠da Esperada (Output)**: Exemplos da sa√≠da esperada.
*   **Restri√ß√µes/Observa√ß√µes**: Condi√ß√µes especiais.
*   **Solu√ß√£o (Opcional)**: Esqueleto de fun√ß√£o ou solu√ß√£o completa.

---

### Exerc√≠cio 171: `Promise.allSettled()`

**Descri√ß√£o do Problema**: Crie duas Promises, uma que resolve e outra que rejeita. Use `Promise.allSettled()` para esperar que ambas terminem e imprima o array de resultados, mostrando o status de cada uma.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
```javascript
[
  { status: \'fulfilled\", value: \'Sucesso!\" },
  { status: \'rejected\", reason: \'Falha!\" }
]
```

**Restri√ß√µes/Observa√ß√µes**: Demonstre o comportamento de `Promise.allSettled()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio171() {
  const p1 = Promise.resolve(\'Sucesso!\');
  const p2 = Promise.reject(\'Falha!\');

  Promise.allSettled([p1, p2])
    .then(resultados => console.log(resultados));
}

// exercicio171();
```

---

### Exerc√≠cio 172: `Promise.any()`

**Descri√ß√£o do Problema**: Crie tr√™s Promises, duas que rejeitam e uma que resolve. Use `Promise.any()` para obter o valor da primeira Promise a resolver. Imprima o resultado.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
```
Primeiro a resolver: Sucesso r√°pido
```

**Restri√ß√µes/Observa√ß√µes**: Demonstre o comportamento de `Promise.any()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio172() {
  const p1 = new Promise((_, reject) => setTimeout(() => reject(\'Falha lenta\"), 200));
  const p2 = new Promise(resolve => setTimeout(() => resolve(\'Sucesso r√°pido\"), 100));
  const p3 = Promise.reject(\'Falha imediata\');

  Promise.any([p1, p2, p3])
    .then(resultado => console.log(\'Primeiro a resolver: \' + resultado))
    .catch(erro => console.log(\'Todos falharam: \' + erro));
}

// exercicio172();
```

---

### Exerc√≠cio 173: `async/await` com `Promise.all()`

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o `async` que use `await` com `Promise.all()` para buscar m√∫ltiplos dados simultaneamente. Imprima os resultados combinados.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
```
Resultados combinados: [ \'Dado 1\", \'Dado 2\" ]
```

**Restri√ß√µes/Observa√ß√µes**: Combine `async/await` com `Promise.all()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
async function exercicio173() {
  const buscarDado1 = new Promise(resolve => setTimeout(() => resolve(\'Dado 1\"), 100));
  const buscarDado2 = new Promise(resolve => setTimeout(() => resolve(\'Dado 2\"), 150));

  try {
    const resultados = await Promise.all([buscarDado1, buscarDado2]);
    console.log(\'Resultados combinados: \' + resultados);
  } catch (error) {
    console.error(\'Erro ao buscar dados:\", error);
  }
}

// exercicio173();
```

---

### Exerc√≠cio 174: Geradores (Generators) - B√°sico

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o geradora `contadorSimples()` que produza os n√∫meros 1, 2 e 3. Use um loop `for...of` para iterar sobre o gerador e imprimir os valores.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
```
1
2
3
```

**Restri√ß√µes/Observa√ß√µes**: Utilize `function*` e `yield`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function* contadorSimples() {
  yield 1;
  yield 2;
  yield 3;
}

function exercicio174() {
  for (const valor of contadorSimples()) {
    console.log(valor);
  }
}

// exercicio174();
```

---

### Exerc√≠cio 175: Geradores (Generators) - Passando Valores

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o geradora que primeiro produz uma pergunta (`yield \'Qual o seu nome?\") e depois recebe uma resposta atrav√©s de `.next(resposta)` e a imprime.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
```
Pergunta: Qual o seu nome?
Resposta recebida: Gemini
```

**Restri√ß√µes/Observa√ß√µes**: Demonstre a comunica√ß√£o bidirecional com geradores.

**Solu√ß√£o (Esqueleto)**:
```javascript
function* dialogo() {
  const resposta = yield \'Qual o seu nome?\";
  console.log(\'Resposta recebida: \' + resposta);
}

function exercicio175() {
  const gen = dialogo();
  const pergunta = gen.next().value;
  console.log(\'Pergunta: \' + pergunta);
  gen.next(\'Gemini\');
}

// exercicio175();
```

---

### Exerc√≠cio 176: Iteradores e S√≠mbolo `Symbol.iterator`

**Descri√ß√£o do Problema**: Crie um objeto `meuIteravel` que implemente o protocolo de itera√ß√£o usando `Symbol.iterator`. Ele deve produzir os n√∫meros de 1 a 3 quando iterado com `for...of`.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
```
1
2
3
```

**Restri√ß√µes/Observa√ß√µes**: O objeto deve ter uma propriedade `[Symbol.iterator]` que √© uma fun√ß√£o geradora.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio176() {
  const meuIteravel = {
    *[Symbol.iterator]() {
      yield 1;
      yield 2;
      yield 3;
    }
  };

  for (const valor of meuIteravel) {
    console.log(valor);
  }
}

// exercicio176();
```

---

### Exerc√≠cio 177: `Map` - Estrutura de Dados

**Descri√ß√£o do Problema**: Crie um `Map` para armazenar informa√ß√µes de usu√°rios, onde a chave √© o ID do usu√°rio (n√∫mero) e o valor √© um objeto com nome e email. Adicione dois usu√°rios e depois recupere e imprima os dados de um deles.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
```javascript
{ nome: \'Ana\", email: \'ana@example.com\" }
```

**Restri√ß√µes/Observa√ß√µes**: Utilize os m√©todos `set()` e `get()` do `Map`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio177() {
  const usuarios = new Map();

  usuarios.set(1, { nome: \'Jo√£o\", email: \'joao@example.com\" });
  usuarios.set(2, { nome: \'Ana\", email: \'ana@example.com\" });

  console.log(usuarios.get(2));
  console.log(\'Tamanho do Map: \' + usuarios.size);
}

// exercicio177();
```

---

### Exerc√≠cio 178: `Set` - Estrutura de Dados

**Descri√ß√£o do Problema**: Crie um `Set` e adicione alguns n√∫meros, incluindo duplicatas. Imprima o tamanho do `Set` para mostrar que duplicatas s√£o ignoradas. Em seguida, verifique se um n√∫mero espec√≠fico existe no `Set`.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
```
Tamanho do Set: 3
O Set cont√©m o n√∫mero 5: true
```

**Restri√ß√µes/Observa√ß√µes**: Utilize os m√©todos `add()`, `has()` e a propriedade `size` do `Set`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio178() {
  const numeros = new Set();

  numeros.add(1);
  numeros.add(5);
  numeros.add(1); // Duplicata
  numeros.add(10);

  console.log(\'Tamanho do Set: \' + numeros.size);
  console.log(\'O Set cont√©m o n√∫mero 5: \' + numeros.has(5));
}

// exercicio178();
```

---

### Exerc√≠cio 179: `WeakMap` - Conceito

**Descri√ß√£o do Problema**: Demonstre o conceito de `WeakMap`. Crie um objeto e use-o como chave em um `WeakMap`. Em seguida, defina o objeto como `null` para mostrar que a chave pode ser coletada pelo garbage collector (embora n√£o seja poss√≠vel provar isso diretamente no c√≥digo).

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
```
WeakMap cont√©m a chave? true
(Ap√≥s a remo√ß√£o da refer√™ncia, a chave pode ser coletada pelo GC)
```

**Restri√ß√µes/Observa√ß√µes**: Apenas demonstre a cria√ß√£o e o uso.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio179() {
  const weakMap = new WeakMap();
  let chave = { id: 1 };

  weakMap.set(chave, \'Informa√ß√£o secreta\');

  console.log(\'WeakMap cont√©m a chave? \' + weakMap.has(chave));

  // Remover a √∫nica refer√™ncia forte √† chave
  chave = null;

  // Agora, a entrada no WeakMap pode ser coletada pelo garbage collector.
  // N√£o h√° como verificar isso programaticamente de forma confi√°vel.
  console.log(\'(Ap√≥s a remo√ß√£o da refer√™ncia, a chave pode ser coletada pelo GC)\");
}

// exercicio179();
```

---

### Exerc√≠cio 180: `WeakSet` - Conceito

**Descri√ß√£o do Problema**: Demonstre o conceito de `WeakSet`. Crie um objeto, adicione-o a um `WeakSet`. Em seguida, defina o objeto como `null` para mostrar que ele pode ser coletado pelo garbage collector.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
```
WeakSet cont√©m o objeto? true
(Ap√≥s a remo√ß√£o da refer√™ncia, o objeto pode ser coletado pelo GC)
```

**Restri√ß√µes/Observa√ß√µes**: Apenas demonstre a cria√ß√£o e o uso.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio180() {
  const weakSet = new WeakSet();
  let obj = { valor: 100 };

  weakSet.add(obj);

  console.log(\'WeakSet cont√©m o objeto? \' + weakSet.has(obj));

  // Remover a √∫nica refer√™ncia forte ao objeto
  obj = null;

  // Agora, o objeto no WeakSet pode ser coletado pelo garbage collector.
  console.log(\'(Ap√≥s a remo√ß√£o da refer√™ncia, o objeto pode ser coletado pelo GC)\");
}

// exercicio180();
```

---

### Exerc√≠cio 181: `Proxy` - Interceptando Acessos (get)

**Descri√ß√£o do Problema**: Crie um `Proxy` para um objeto que, ao tentar acessar uma propriedade inexistente, retorne uma mensagem padr√£o em vez de `undefined`.

**Entrada (Input)**:
```javascript
proxy.nome
proxy.idade
```

**Sa√≠da Esperada (Output)**:
```
Jo√£o
Propriedade \'idade\' n√£o existe.
```

**Restri√ß√µes/Observa√ß√µes**: Implemente o handler `get` para o `Proxy`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio181() {
  const alvo = { nome: \'Jo√£o\" };
  const handler = {
    get(target, prop) {
      return prop in target ? target[prop] : `Propriedade \'${prop}\' n√£o existe.`;
    }
  };

  const proxy = new Proxy(alvo, handler);

  console.log(proxy.nome);
  console.log(proxy.idade);
}

// exercicio181();
```

---

### Exerc√≠cio 182: `Proxy` - Validando Atribui√ß√µes (set)

**Descri√ß√£o do Problema**: Crie um `Proxy` para um objeto que, ao tentar atribuir um valor a uma propriedade, valide se o valor √© do tipo esperado. Por exemplo, a propriedade `idade` s√≥ pode aceitar n√∫meros.

**Entrada (Input)**:
```javascript
proxy.idade = 25
proxy.idade = \'vinte e cinco\"
```

**Sa√≠da Esperada (Output)**:
```
Idade atribu√≠da: 25
Erro: A propriedade \'idade\' s√≥ aceita n√∫meros.
Idade atual: 25
```

**Restri√ß√µes/Observa√ß√µes**: Implemente o handler `set` para o `Proxy`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio182() {
  const alvo = { nome: \'Maria\" };
  const handler = {
    set(target, prop, value) {
      if (prop === \'idade\') {
        if (typeof value !== \'number\') {
          console.error(`Erro: A propriedade \'${prop}\' s√≥ aceita n√∫meros.`);
          return false;
        } else {
          console.log(`Idade atribu√≠da: ${value}`);
        }
      }
      target[prop] = value;
      return true;
    }
  };

  const proxy = new Proxy(alvo, handler);

  proxy.idade = 25;
  proxy.idade = \'vinte e cinco\';
  console.log(\'Idade atual: \' + proxy.idade);
}

// exercicio182();
```

---

### Exerc√≠cio 183: `Reflect` API - Acessando Propriedades

**Descri√ß√£o do Problema**: Use `Reflect.get()` e `Reflect.has()` para acessar uma propriedade de um objeto e verificar se ela existe. Compare com o acesso direto.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
```
Valor com Reflect.get: 10
Existe com Reflect.has: true
N√£o existe com Reflect.has: false
```

**Restri√ß√µes/Observa√ß√µes**: Demonstre o uso b√°sico de `Reflect`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio183() {
  const obj = { a: 10 };

  console.log(\'Valor com Reflect.get: \' + Reflect.get(obj, \'a\'));
  console.log(\'Existe com Reflect.has: \' + Reflect.has(obj, \'a\'));
  console.log(\'N√£o existe com Reflect.has: \' + Reflect.has(obj, \'b\'));
}

// exercicio183();
```

---

### Exerc√≠cio 184: `Reflect` API - Modificando Propriedades

**Descri√ß√£o do Problema**: Use `Reflect.set()` e `Reflect.defineProperty()` para modificar e definir propriedades de um objeto. Imprima o objeto resultante.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
```javascript
{ a: 20, b: 30 }
```

**Restri√ß√µes/Observa√ß√µes**: Demonstre o uso de `Reflect` para modifica√ß√£o.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio184() {
  const obj = { a: 10 };

  Reflect.set(obj, \'a\', 20);
  Reflect.defineProperty(obj, \'b\', { value: 30, writable: true, enumerable: true });

  console.log(obj);
}

// exercicio184();
```

---

### Exerc√≠cio 185: `EventEmitter` do Node.js - B√°sico

**Descri√ß√£o do Problema**: Crie uma inst√¢ncia de `EventEmitter`. Registre um listener para um evento `meuEvento` que imprima uma mensagem. Emita o evento e veja a mensagem ser impressa.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
```
Meu evento foi acionado!
```

**Restri√ß√µes/Observa√ß√µes**: Requer o m√≥dulo `events` do Node.js.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio185() {
  const EventEmitter = require(\'events\');
  const meuEmissor = new EventEmitter();

  meuEmissor.on(\'meuEvento\", () => {
    console.log(\'Meu evento foi acionado!\');
  });

  meuEmissor.emit(\'meuEvento\');
}

// exercicio185();
```

---

### Exerc√≠cio 186: `EventEmitter` - Passando Dados

**Descri√ß√£o do Problema**: Modifique o exerc√≠cio anterior para que o evento `meuEvento` seja emitido com dados (ex: um objeto). O listener deve receber e imprimir esses dados.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
```javascript
Evento recebido com dados: { tipo: \'notifica√ß√£o\", mensagem: \'Ol√° Mundo\" }
```

**Restri√ß√µes/Observa√ß√µes**: Passe argumentos para o m√©todo `emit()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio186() {
  const EventEmitter = require(\'events\');
  const meuEmissor = new EventEmitter();

  meuEmissor.on(\'meuEvento\", (dados) => {
    console.log(\'Evento recebido com dados: \' + JSON.stringify(dados));
  });

  meuEmissor.emit(\'meuEvento\', { tipo: \'notifica√ß√£o\", mensagem: \'Ol√° Mundo\" });
}

// exercicio186();
```

---

### Exerc√≠cio 187: `EventEmitter` - `once()`

**Descri√ß√£o do Problema**: Use o m√©todo `once()` para registrar um listener que s√≥ ser√° executado uma vez, mesmo que o evento seja emitido v√°rias vezes.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
```
Este evento s√≥ acontece uma vez.
```

**Restri√ß√µes/Observa√ß√µes**: Emita o evento duas vezes para provar que o listener s√≥ roda na primeira.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio187() {
  const EventEmitter = require(\'events\');
  const meuEmissor = new EventEmitter();

  meuEmissor.once(\'eventoUnico\", () => {
    console.log(\'Este evento s√≥ acontece uma vez.\');
  });

  meuEmissor.emit(\'eventoUnico\');
  meuEmissor.emit(\'eventoUnico\'); // Esta emiss√£o n√£o far√° nada
}

// exercicio187();
```

---

### Exerc√≠cio 188: Streams - Leitura de Arquivo Grande

**Descri√ß√£o do Problema**: Crie um arquivo de texto grande. Use `fs.createReadStream` para ler o arquivo em chunks e imprimir uma mensagem para cada chunk recebido, sem armazenar o arquivo inteiro na mem√≥ria.

**Entrada (Input)**:
(Arquivo `grande.txt` criado previamente)

**Sa√≠da Esperada (Output)**:
```
Recebido chunk de dados...
Recebido chunk de dados...
(v√°rias vezes)
Leitura do arquivo conclu√≠da.
```

**Restri√ß√µes/Observa√ß√µes**: Requer o m√≥dulo `fs`.

**Solu√ß√£o (Esqueleto)**:
```javascript
// Para simular, crie um arquivo grande primeiro:
// shell.exec(\'node -e "require(\'fs\').writeFileSync(\'grande.txt\', \'a\".repeat(1024 * 1024))\"\");

function exercicio188() {
  const fs = require(\'fs\');
  const readStream = fs.createReadStream(\'grande.txt\");

  readStream.on(\'data\", (chunk) => {
    console.log(\'Recebido chunk de dados... Tamanho: \' + chunk.length);
  });

  readStream.on(\'end\", () => {
    console.log(\'Leitura do arquivo conclu√≠da.\');
  });

  readStream.on(\'error\", (err) => {
    console.error(\'Erro na stream de leitura:\", err);
  });
}

// exercicio188();
```

---

### Exerc√≠cio 189: Streams - Escrita de Arquivo

**Descri√ß√£o do Problema**: Use `fs.createWriteStream` para escrever dados em um arquivo `stream_saida.txt`. Escreva m√∫ltiplos peda√ßos de dados usando `writeStream.write()`.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
```
Escrita no arquivo conclu√≠da.
```

**Restri√ß√µes/Observa√ß√µes**: Use o evento `finish` para saber quando a escrita terminou.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio189() {
  const fs = require(\'fs\');
  const writeStream = fs.createWriteStream(\'stream_saida.txt\');

  writeStream.write(\'Primeira linha.\n\');
  writeStream.write(\'Segunda linha.\n\');
  writeStream.end(); // Finaliza a stream

  writeStream.on(\'finish\", () => {
    console.log(\'Escrita no arquivo conclu√≠da.\');
  });

  writeStream.on(\'error\", (err) => {
    console.error(\'Erro na stream de escrita:\", err);
  });
}

// exercicio189();
```

---

### Exerc√≠cio 190: Streams - `pipe()`

**Descri√ß√£o do Problema**: Use o m√©todo `pipe()` para conectar uma `ReadStream` (lendo um arquivo) a uma `WriteStream` (escrevendo em outro arquivo), efetivamente copiando o arquivo de forma eficiente.

**Entrada (Input)**:
(Arquivo `origem.txt` criado previamente)

**Sa√≠da Esperada (Output)**:
```
Arquivo copiado com sucesso via pipe().
```

**Restri√ß√µes/Observa√ß√µes**: O `pipe` gerencia o fluxo de dados automaticamente.

**Solu√ß√£o (Esqueleto)**:
```javascript
// Crie o arquivo de origem primeiro:
// shell.exec(\'echo "Conte√∫do para ser copiado." > origem.txt\");

function exercicio190() {
  const fs = require(\'fs\');
  const readStream = fs.createReadStream(\'origem.txt\');
  const writeStream = fs.createWriteStream(\'destino.txt\');

  readStream.pipe(writeStream);

  writeStream.on(\'finish\", () => {
    console.log(\'Arquivo copiado com sucesso via pipe().\');
  });

  readStream.on(\'error\", (err) => console.error(\'Erro na leitura:\", err));
  writeStream.on(\'error\", (err) => console.error(\'Erro na escrita:\", err));
}

// exercicio190();
```

---

### Exerc√≠cio 191: Streams - Transform (Ex: Gzip)

**Descri√ß√£o do Problema**: Use `pipe()` para conectar uma `ReadStream`, uma `Transform Stream` (como `zlib.createGzip()`) e uma `WriteStream` para ler um arquivo, comprimi-lo e salvar o resultado em um arquivo `.gz`.

**Entrada (Input)**:
(Arquivo `arquivo_para_comprimir.txt` criado previamente)

**Sa√≠da Esperada (Output)**:
```
Arquivo comprimido com sucesso!
```

**Restri√ß√µes/Observa√ß√µes**: Requer os m√≥dulos `fs` e `zlib`.

**Solu√ß√£o (Esqueleto)**:
```javascript
// Crie o arquivo primeiro:
// shell.exec(\'echo "Este √© um texto para ser comprimido." > arquivo_para_comprimir.txt\");

function exercicio191() {
  const fs = require(\'fs\');
  const zlib = require(\'zlib\');

  const readStream = fs.createReadStream(\'arquivo_para_comprimir.txt\');
  const gzip = zlib.createGzip();
  const writeStream = fs.createWriteStream(\'arquivo_comprimido.txt.gz\');

  readStream.pipe(gzip).pipe(writeStream);

  writeStream.on(\'finish\", () => {
    console.log(\'Arquivo comprimido com sucesso!\');
  });
}

// exercicio191();
```

---

### Exerc√≠cio 192: `Buffer` - Cria√ß√£o e Manipula√ß√£o

**Descri√ß√£o do Problema**: Crie um `Buffer` a partir de uma string. Imprima o conte√∫do do buffer em formato de string e em formato hexadecimal.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
```
String: Ol√° Buffer
Hex: 4f6c6120427566666572
```

**Restri√ß√µes/Observa√ß√µes**: Use `Buffer.from()` e `buf.toString()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio192() {
  const buf = Buffer.from(\'Ol√° Buffer\", \'utf8\');

  console.log(\'String: \' + buf.toString(\'utf8\'));
  console.log(\'Hex: \' + buf.toString(\'hex\'));
}

// exercicio192();
```

---

### Exerc√≠cio 193: `Buffer` - Concatena√ß√£o

**Descri√ß√£o do Problema**: Crie dois `Buffer`s e use `Buffer.concat()` para uni-los em um √∫nico `Buffer`. Imprima a string resultante.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
```
Buffer concatenado: Ol√° Mundo
```

**Restri√ß√µes/Observa√ß√µes**: `Buffer.concat()` recebe um array de buffers.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio193() {
  const buf1 = Buffer.from(\'Ol√° \');
  const buf2 = Buffer.from(\'Mundo\');
  const bufConcatenado = Buffer.concat([buf1, buf2]);

  console.log(\'Buffer concatenado: \' + bufConcatenado.toString());
}

// exercicio193();
```

---

### Exerc√≠cio 194: `worker_threads` - B√°sico

**Descri√ß√£o do Problema**: Crie um worker thread que receba um n√∫mero, calcule seu quadrado e envie o resultado de volta para a thread principal. A thread principal deve imprimir o resultado.

**Entrada (Input)**:
(Dois arquivos: `main.js` e `worker.js`)

**Sa√≠da Esperada (Output)**:
```
Resultado do worker: 81
```

**Restri√ß√µes/Observa√ß√µes**: Requer o m√≥dulo `worker_threads`.

**Solu√ß√£o (Esqueleto)**:
```javascript
// worker.js
/*
const { parentPort } = require(\'worker_threads\');
parentPort.on(\'message\", (numero) => {
  const resultado = numero * numero;
  parentPort.postMessage(resultado);
});
*/

// main.js
/*
const { Worker } = require(\'worker_threads\');
const worker = new Worker(\'./worker.js\');

worker.on(\'message\", (resultado) => {
  console.log(\'Resultado do worker: \' + resultado);
});

worker.postMessage(9);
*/

// Simula√ß√£o:
function exercicio194() {
  console.log(\'Este exerc√≠cio requer a execu√ß√£o de dois arquivos separados.\");
}

// exercicio194();
```

---

### Exerc√≠cio 195: `child_process` - `exec()`

**Descri√ß√£o do Problema**: Use `child_process.exec()` para executar um comando do sistema operacional (ex: `ls -l` no Linux/macOS ou `dir` no Windows) e imprima a sa√≠da (stdout) no console.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
(A listagem de arquivos do diret√≥rio atual)

**Restri√ß√µes/Observa√ß√µes**: Requer o m√≥dulo `child_process`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio195() {
  const { exec } = require(\'child_process\');
  const comando = process.platform === \'win32\" ? \'dir\" : \'ls -l\";

  exec(comando, (error, stdout, stderr) => {
    if (error) {
      console.error(`Erro ao executar comando: ${error.message}`);
      return;
    }
    if (stderr) {
      console.error(`Stderr: ${stderr}`);
      return;
    }
    console.log(`Stdout:\n${stdout}`);
  });
}

// exercicio195();
```

---

### Exerc√≠cio 196: `child_process` - `spawn()`

**Descri√ß√£o do Problema**: Use `child_process.spawn()` para executar um comando que gera muita sa√≠da (ex: `find /` no Linux). Ou√ßa os eventos `data` do stdout do processo filho e imprima os dados √† medida que chegam.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
(Um fluxo cont√≠nuo de nomes de arquivos e diret√≥rios)

**Restri√ß√µes/Observa√ß√µes**: `spawn` √© mais adequado para processos de longa dura√ß√£o ou com muita sa√≠da.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio196() {
  const { spawn } = require(\'child_process\');
  // Use um comando que gere bastante sa√≠da. Cuidado com `find /` em sistemas reais.
  // Usaremos `ls -R` como um exemplo mais seguro.
  const ls = spawn(\'ls\", [\'-R\", \'./\']);

  ls.stdout.on(\'data\", (data) => {
    console.log(`stdout: ${data}`);
  });

  ls.stderr.on(\'data\", (data) => {
    console.error(`stderr: ${data}`);
  });

  ls.on(\'close\", (code) => {
    console.log(`Processo filho terminou com c√≥digo ${code}`);
  });
}

// exercicio196();
```

---

### Exerc√≠cio 197: `crypto` - Criar Hash SHA256

**Descri√ß√£o do Problema**: Use o m√≥dulo `crypto` do Node.js para criar um hash SHA256 de uma string. Imprima o hash resultante em formato hexadecimal.

**Entrada (Input)**:
```
texto = \'minha senha secreta\"
```

**Sa√≠da Esperada (Output)**:
(Um hash SHA256 de 64 caracteres hexadecimais)

**Restri√ß√µes/Observa√ß√µes**: Requer o m√≥dulo `crypto`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio197(texto) {
  const crypto = require(\'crypto\');
  const hash = crypto.createHash(\'sha256\');
  hash.update(texto);
  return hash.digest(\'hex\');
}

// console.log(exercicio197(\'minha senha secreta\'));
```

---

### Exerc√≠cio 198: `crypto` - Criptografia Sim√©trica (AES)

**Descri√ß√£o do Problema**: Crie fun√ß√µes para criptografar e descriptografar um texto usando o algoritmo AES-256-CBC. Demonstre criptografando um texto e depois descriptografando-o de volta ao original.

**Entrada (Input)**:
```
texto = \'Mensagem super secreta.\"
```

**Sa√≠da Esperada (Output)**:
```
Texto criptografado: (string hexadecimal)
Texto descriptografado: Mensagem super secreta.
```

**Restri√ß√µes/Observa√ß√µes**: Requer uma chave de 32 bytes e um IV (vetor de inicializa√ß√£o) de 16 bytes.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio198() {
  const crypto = require(\'crypto\');
  const algorithm = \'aes-256-cbc\";
  const key = crypto.randomBytes(32); // Chave de 32 bytes
  const iv = crypto.randomBytes(16);  // IV de 16 bytes

  function encrypt(text) {
    let cipher = crypto.createCipheriv(algorithm, Buffer.from(key), iv);
    let encrypted = cipher.update(text);
    encrypted = Buffer.concat([encrypted, cipher.final()]);
    return encrypted.toString(\'hex\');
  }

  function decrypt(text) {
    let encryptedText = Buffer.from(text, \'hex\');
    let decipher = crypto.createDecipheriv(algorithm, Buffer.from(key), iv);
    let decrypted = decipher.update(encryptedText);
    decrypted = Buffer.concat([decrypted, decipher.final()]);
    return decrypted.toString();
  }

  const textoOriginal = \'Mensagem super secreta.\';
  const textoCriptografado = encrypt(textoOriginal);
  const textoDescriptografado = decrypt(textoCriptografado);

  console.log(\'Texto criptografado: \' + textoCriptografado);
  console.log(\'Texto descriptografado: \' + textoDescriptografado);
}

// exercicio198();
```

---

### Exerc√≠cio 199: Memoiza√ß√£o (Memoization) para Otimiza√ß√£o

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o `memoize(fn)` que receba uma fun√ß√£o e retorne uma vers√£o memoizada dela. Demonstre com uma fun√ß√£o de c√°lculo pesado (ex: fatorial recursivo) para mostrar que os resultados s√£o cacheados.

**Entrada (Input)**:
```javascript
fatorialMemoizado(30)
fatorialMemoizado(30) // Segunda chamada
```

**Sa√≠da Esperada (Output)**:
```
Calculando fatorial para 30...
(Resultado grande)
(Resultado grande) // (sem a mensagem de c√°lculo)
```

**Restri√ß√µes/Observa√ß√µes**: A fun√ß√£o memoizada deve armazenar os resultados em um cache.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio199() {
  function memoize(fn) {
    const cache = {};
    return function(...args) {
      const key = JSON.stringify(args);
      if (cache[key]) {
        return cache[key];
      }
      console.log(`Calculando ${fn.name} para ${args}...`);
      const result = fn(...args);
      cache[key] = result;
      return result;
    };
  }

  function fatorial(n) {
    if (n <= 1) return 1;
    return n * fatorial(n - 1);
  }

  const fatorialMemoizado = memoize(fatorial);

  console.log(fatorialMemoizado(10));
  console.log(fatorialMemoizado(10)); // Esta chamada deve ser instant√¢nea
  console.log(fatorialMemoizado(12));
}

// exercicio199();
```

---

### Exerc√≠cio 200: Testes Unit√°rios - `assert` do Node.js

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o simples `somar(a, b)`. Escreva um pequeno teste para ela usando o m√≥dulo `assert` do Node.js, verificando se `somar(2, 3)` √© igual a `5`.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
```
Testes passaram!
```
(Ou um `AssertionError` se o teste falhar)

**Restri√ß√µes/Observa√ß√µes**: Requer o m√≥dulo `assert`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio200() {
  const assert = require(\'assert\');

  function somar(a, b) {
    return a + b;
  }

  try {
    assert.strictEqual(somar(2, 3), 5, \'2 + 3 deve ser 5\');
    assert.strictEqual(somar(-1, 1), 0, \'-1 + 1 deve ser 0\');
    console.log(\'Testes passaram!\');
  } catch (error) {
    console.error(\'Teste falhou: \' + error.message);
  }
}

// exercicio200();
```

---

### Exerc√≠cio 201: Algoritmo de Dijkstra (Conceito)

**Descri√ß√£o do Problema**: Implemente uma vers√£o simplificada do algoritmo de Dijkstra para encontrar o caminho mais curto em um grafo ponderado. O grafo pode ser representado por um objeto.

**Entrada (Input)**:
```javascript
grafo = {
  A: { B: 1, C: 4 },
  B: { A: 1, C: 2, D: 5 },
  C: { A: 4, B: 2, D: 1 },
  D: { B: 5, C: 1 }
}
inicio = \'A\'
fim = \'D\'
```

**Sa√≠da Esperada (Output)**:
```
Caminho mais curto: 3, via: [ \'A\", \'B\", \'C\", \'D\" ]
```

**Restri√ß√µes/Observa√ß√µes**: Esta √© uma implementa√ß√£o complexa. Uma vers√£o simplificada √© suficiente.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio201(graph, startNode, endNode) {
  // Implementa√ß√£o simplificada de Dijkstra
  const distances = {};
  const visited = new Set();
  const paths = {};

  Object.keys(graph).forEach(node => {
    distances[node] = Infinity;
    paths[node] = null;
  });
  distances[startNode] = 0;

  let currentNode = startNode;
  while (currentNode) {
    const neighbors = graph[currentNode];
    const currentDistance = distances[currentNode];

    for (const neighbor in neighbors) {
      const newDist = currentDistance + neighbors[neighbor];
      if (newDist < distances[neighbor]) {
        distances[neighbor] = newDist;
        paths[neighbor] = currentNode;
      }
    }

    visited.add(currentNode);

    currentNode = Object.keys(distances).reduce((minNode, node) => {
      if (!visited.has(node) && (!minNode || distances[node] < distances[minNode])) {
        return node;
      }
      return minNode;
    }, null);
  }

  // Reconstruir o caminho
  const shortestPath = [];
  let pathNode = endNode;
  while (pathNode) {
    shortestPath.unshift(pathNode);
    pathNode = paths[pathNode];
  }

  return {
    distance: distances[endNode],
    path: shortestPath
  };
}

// const graph = {
//   A: { B: 1, C: 4 },
//   B: { A: 1, C: 2, D: 5 },
//   C: { A: 4, B: 2, D: 1 },
//   D: { B: 5, C: 1 }
// };
// const result = exercicio201(graph, \'A\", \'D\');
// console.log(`Caminho mais curto: ${result.distance}, via: [ ${result.path.join(\", \'")} ]`);
```

---

### Exerc√≠cio 202: √Årvore Bin√°ria de Busca (BST) - Busca

**Descri√ß√£o do Problema**: Adicione um m√©todo `search(valor)` √† sua classe `BST` do exerc√≠cio 144. O m√©todo deve retornar `true` se o valor existir na √°rvore e `false` caso contr√°rio.

**Entrada (Input)**:
```javascript
bst.search(15)
bst.search(99)
```

**Sa√≠da Esperada (Output)**:
```
true
false
```

**Restri√ß√µes/Observa√ß√µes**: A busca deve ser recursiva ou iterativa.

**Solu√ß√£o (Esqueleto)**:
```javascript
// Reutilizando e estendendo a classe BST do exerc√≠cio 144
class Node {
  constructor(valor) { this.valor = valor; this.left = null; this.right = null; }
}
class BST {
  constructor() { this.root = null; }
  insert(valor) { /* ... implementa√ß√£o do ex 144 ... */
    const newNode = new Node(valor);
    if (this.root === null) { this.root = newNode; } else { this.insertNode(this.root, newNode); }
  }
  insertNode(node, newNode) {
    if (newNode.valor < node.valor) {
      if (node.left === null) { node.left = newNode; } else { this.insertNode(node.left, newNode); }
    } else {
      if (node.right === null) { node.right = newNode; } else { this.insertNode(node.right, newNode); }
    }
  }

  // Novo m√©todo
  search(valor) {
    return this.searchNode(this.root, valor);
  }

  searchNode(node, valor) {
    if (node === null) return false;
    if (valor < node.valor) return this.searchNode(node.left, valor);
    if (valor > node.valor) return this.searchNode(node.right, valor);
    return true; // valor === node.valor
  }
}

function exercicio202() {
  const bst = new BST();
  [10, 5, 15, 3, 7].forEach(v => bst.insert(v));
  console.log(bst.search(15)); // true
  console.log(bst.search(99)); // false
}

// exercicio202();
```

---

### Exerc√≠cio 203: √Årvore Bin√°ria de Busca (BST) - Travessia (In-Order)

**Descri√ß√£o do Problema**: Adicione um m√©todo `inOrderTraverse()` √† sua classe `BST` que retorne um array com os valores da √°rvore em ordem crescente.

**Entrada (Input)**:
```javascript
bst.inOrderTraverse()
```

**Sa√≠da Esperada (Output)**:
```
[3, 5, 7, 10, 15]
```

**Restri√ß√µes/Observa√ß√µes**: A travessia in-order visita a sub-√°rvore esquerda, o n√≥ e depois a sub-√°rvore direita.

**Solu√ß√£o (Esqueleto)**:
```javascript
// Estendendo a classe BST novamente
class BST_Ex203 extends BST {
  inOrderTraverse() {
    const result = [];
    this.traverse(this.root, result);
    return result;
  }

  traverse(node, result) {
    if (node !== null) {
      this.traverse(node.left, result);
      result.push(node.valor);
      this.traverse(node.right, result);
    }
  }
}

function exercicio203() {
  const bst = new BST_Ex203();
  [10, 5, 15, 3, 7].forEach(v => bst.insert(v));
  console.log(bst.inOrderTraverse());
}

// exercicio203();
```

---

### Exerc√≠cio 204: Lista Encadeada - Remover Elemento

**Descri√ß√£o do Problema**: Adicione um m√©todo `remove(valor)` √† sua classe `LinkedList` do exerc√≠cio 143. O m√©todo deve remover o primeiro n√≥ que cont√©m o valor especificado.

**Entrada (Input)**:
```javascript
lista.remove(2)
```

**Sa√≠da Esperada (Output)**:
```
1 -> 3 -> null
```

**Restri√ß√µes/Observa√ß√µes**: Lide com os casos de remo√ß√£o da cabe√ßa (head) e de um n√≥ no meio/fim.

**Solu√ß√£o (Esqueleto)**:
```javascript
// Estendendo a classe LinkedList do exerc√≠cio 143
class Node_Ex204 { constructor(valor) { this.valor = valor; this.proximo = null; } }
class LinkedList_Ex204 {
  constructor() { this.head = null; this.size = 0; }
  add(valor) { /* ... implementa√ß√£o do ex 143 ... */
    const newNode = new Node_Ex204(valor);
    if (!this.head) { this.head = newNode; } else { let c = this.head; while (c.proximo) { c = c.proximo; } c.proximo = newNode; }
    this.size++;
  }
  printList() { /* ... implementa√ß√£o do ex 143 ... */
    let c = this.head; let r = \'\"; while (c) { r += `${c.valor} -> `; c = c.proximo; } r += \'null\"; console.log(r);
  }

  // Novo m√©todo
  remove(valor) {
    if (!this.head) return;

    if (this.head.valor === valor) {
      this.head = this.head.proximo;
      this.size--;
      return;
    }

    let current = this.head;
    while (current.proximo && current.proximo.valor !== valor) {
      current = current.proximo;
    }

    if (current.proximo) {
      current.proximo = current.proximo.proximo;
      this.size--;
    }
  }
}

function exercicio204() {
  const lista = new LinkedList_Ex204();
  [1, 2, 3].forEach(v => lista.add(v));
  lista.remove(2);
  lista.printList();
}

// exercicio204();
```

---

### Exerc√≠cio 205: Design Pattern Decorator (Conceito)

**Descri√ß√£o do Problema**: Implemente o padr√£o Decorator. Crie uma classe base `Cafe` com um m√©todo `custo()`. Crie classes decoradoras como `ComLeite` e `ComAcucar` que adicionam custo ao caf√© original.

**Entrada (Input)**:
```javascript
meuCafe = new Cafe()
meuCafe = new ComLeite(meuCafe)
meuCafe = new ComAcucar(meuCafe)
```

**Sa√≠da Esperada (Output)**:
```
Custo total: 7
```

**Restri√ß√µes/Observa√ß√µes**: Os decoradores devem "envolver" o objeto original.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio205() {
  class Cafe {
    custo() { return 5; }
  }

  class ComLeite {
    constructor(cafe) {
      this.cafe = cafe;
    }
    custo() {
      return this.cafe.custo() + 1.5;
    }
  }

  class ComAcucar {
    constructor(cafe) {
      this.cafe = cafe;
    }
    custo() {
      return this.cafe.custo() + 0.5;
    }
  }

  let meuCafe = new Cafe();
  meuCafe = new ComLeite(meuCafe);
  meuCafe = new ComAcucar(meuCafe);

  console.log(`Custo total: ${meuCafe.custo()}`); // 5 + 1.5 + 0.5 = 7
}

// exercicio205();
```

---

### Exerc√≠cio 206: Design Pattern Strategy (Conceito)

**Descri√ß√£o do Problema**: Implemente o padr√£o Strategy. Crie um `Contexto` (ex: `CalculadoraDeFrete`) que use diferentes estrat√©gias de c√°lculo (`FreteNormal`, `FreteExpresso`). O cliente deve poder trocar a estrat√©gia em tempo de execu√ß√£o.

**Entrada (Input)**:
```javascript
calculadora.setStrategy(new FreteNormal())
calculadora.calcular(10)
calculadora.setStrategy(new FreteExpresso())
calculadora.calcular(10)
```

**Sa√≠da Esperada (Output)**:
```
Frete Normal: 10
Frete Expresso: 25
```

**Restri√ß√µes/Observa√ß√µes**: O contexto delega o c√°lculo para a estrat√©gia atual.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio206() {
  class FreteNormal {
    calcular(peso) { return peso * 1; }
  }

  class FreteExpresso {
    calcular(peso) { return peso * 2.5; }
  }

  class CalculadoraDeFrete {
    constructor() { this.strategy = null; }
    setStrategy(strategy) { this.strategy = strategy; }
    calcular(peso) {
      if (!this.strategy) throw new Error(\'Estrat√©gia n√£o definida\");
      return this.strategy.calcular(peso);
    }
  }

  const calculadora = new CalculadoraDeFrete();

  calculadora.setStrategy(new FreteNormal());
  console.log(\'Frete Normal: \' + calculadora.calcular(10));

  calculadora.setStrategy(new FreteExpresso());
  console.log(\'Frete Expresso: \' + calculadora.calcular(10));
}

// exercicio206();
```

---

### Exerc√≠cio 207: `BigInt` - Opera√ß√µes B√°sicas

**Descri√ß√£o do Problema**: Demonstre o uso de `BigInt` para realizar uma opera√ß√£o matem√°tica que excederia `Number.MAX_SAFE_INTEGER`. Some dois `BigInt`s grandes.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
(Um n√∫mero `BigInt` muito grande)

**Restri√ß√µes/Observa√ß√µes**: Use o sufixo `n` para criar `BigInt`s.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio207() {
  const numMaxSeguro = BigInt(Number.MAX_SAFE_INTEGER);
  console.log(\'N√∫mero m√°ximo seguro: \' + numMaxSeguro);

  const numGrande1 = numMaxSeguro + 10n;
  const numGrande2 = numMaxSeguro + 20n;

  const soma = numGrande1 + numGrande2;
  console.log(\'Soma de BigInts: \' + soma);
}

// exercicio207();
```

---

### Exerc√≠cio 208: Operador de Coalesc√™ncia Nula (`??`)

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba uma vari√°vel que pode ser `null` ou `undefined`. Use o operador de coalesc√™ncia nula para fornecer um valor padr√£o "Padr√£o" apenas para esses casos, mas n√£o para `0` ou `\"\"` (string vazia).

**Entrada (Input)**:
```javascript
valor1 = null
valor2 = 0
valor3 = \"\"
```

**Sa√≠da Esperada (Output)**:
```
Resultado para null: Padr√£o
Resultado para 0: 0
Resultado para \"\": 
```

**Restri√ß√µes/Observa√ß√µes**: Compare o resultado com o operador `||`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio208(valor) {
  return valor ?? \'Padr√£o\";
}

// console.log(\'Resultado para null: \' + exercicio208(null));
// console.log(\'Resultado para undefined: \' + exercicio208(undefined));
// console.log(\'Resultado para 0: \' + exercicio208(0));
// console.log(\'Resultado para \"\": \' + exercicio208(\""));
```

---

### Exerc√≠cio 209: Operador de Encadeamento Opcional (`?.`)

**Descri√ß√£o do Problema**: Crie um objeto aninhado `usuario` que pode ou n√£o ter a propriedade `endereco`, que por sua vez pode ou n√£o ter a propriedade `rua`. Use o operador de encadeamento opcional para acessar `usuario.endereco.rua` sem causar um erro.

**Entrada (Input)**:
```javascript
usuario1 = { endereco: { rua: \'Rua A\" } }
usuario2 = { nome: \'Ana\" }
```

**Sa√≠da Esperada (Output)**:
```
Rua do usu√°rio 1: Rua A
Rua do usu√°rio 2: undefined
```

**Restri√ß√µes/Observa√ß√µes**: Demonstre o acesso seguro a propriedades aninhadas.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio209() {
  const usuario1 = { endereco: { rua: \'Rua A\" } };
  const usuario2 = { nome: \'Ana\" };

  const rua1 = usuario1?.endereco?.rua;
  const rua2 = usuario2?.endereco?.rua;

  console.log(\'Rua do usu√°rio 1: \' + rua1);
  console.log(\'Rua do usu√°rio 2: \' + rua2);
}

// exercicio209();
```

---

### Exerc√≠cio 210: `Atomics` e `SharedArrayBuffer` (Conceito)

**Descri√ß√£o do Problema**: Demonstre o conceito de `SharedArrayBuffer` e `Atomics` para opera√ß√µes at√¥micas entre a thread principal e um worker. Crie um worker que incrementa um valor em um `SharedArrayBuffer` usando `Atomics.add()`.

**Entrada (Input)**:
(Dois arquivos: `main.js` e `worker.js`)

**Sa√≠da Esperada (Output)**:
```
Valor inicial: 0
Valor final (ap√≥s worker): 1
```

**Restri√ß√µes/Observa√ß√µes**: Este √© um conceito avan√ßado, focado na demonstra√ß√£o da API.

**Solu√ß√£o (Esqueleto)**:
```javascript
// worker.js
/*
const { parentPort } = require(\'worker_threads\');
parentPort.on(\'message\", (sab) => {
  const int32Array = new Int32Array(sab);
  Atomics.add(int32Array, 0, 1);
});
*/

// main.js
/*
const { Worker } = require(\'worker_threads\');
const sab = new SharedArrayBuffer(4); // 4 bytes para um Int32
const int32Array = new Int32Array(sab);

console.log(\'Valor inicial: \' + Atomics.load(int32Array, 0));

const worker = new Worker(\'./worker.js\');
worker.postMessage(sab);

worker.on(\'exit\", () => {
  console.log(\'Valor final (ap√≥s worker): \' + Atomics.load(int32Array, 0));
});
*/

// Simula√ß√£o:
function exercicio210() {
  console.log(\'Este exerc√≠cio requer a execu√ß√£o de dois arquivos separados e √© conceitual.\");
}

// exercicio210();
```

---

### Exerc√≠cio 211: Internacionaliza√ß√£o - `Intl.DateTimeFormat`

**Descri√ß√£o do Problema**: Use `Intl.DateTimeFormat` para formatar uma data para os locales `pt-BR` e `en-US`, mostrando o nome do m√™s por extenso.

**Entrada (Input)**:
```javascript
data = new Date(2025, 9, 5) // 05 de Outubro de 2025
```

**Sa√≠da Esperada (Output)**:
```
pt-BR: 5 de outubro de 2025
en-US: October 5, 2025
```

**Restri√ß√µes/Observa√ß√µes**: Use as op√ß√µes do construtor `Intl.DateTimeFormat`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio211() {
  const data = new Date(2025, 9, 5);
  const options = { year: \'numeric\', month: \'long\', day: \'numeric\' };

  const formatadorBR = new Intl.DateTimeFormat(\'pt-BR\", options);
  const formatadorUS = new Intl.DateTimeFormat(\'en-US\", options);

  console.log(\'pt-BR: \' + formatadorBR.format(data));
  console.log(\'en-US: \' + formatadorUS.format(data));
}

// exercicio211();
```

---

### Exerc√≠cio 212: Internacionaliza√ß√£o - `Intl.NumberFormat`

**Descri√ß√£o do Problema**: Use `Intl.NumberFormat` para formatar um n√∫mero como moeda para os locales `pt-BR` (Real) e `de-DE` (Euro).

**Entrada (Input)**:
```javascript
numero = 123456.789
```

**Sa√≠da Esperada (Output)**:
```
pt-BR: R$ 123.456,79
de-DE: 123.456,79 ‚Ç¨
```

**Restri√ß√µes/Observa√ß√µes**: Especifique `style: \'currency\'` e a moeda correspondente.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio212() {
  const numero = 123456.789;

  const formatadorBR = new Intl.NumberFormat(\'pt-BR\", { style: \'currency\', currency: \'BRL\' });
  const formatadorDE = new Intl.NumberFormat(\'de-DE\", { style: \'currency\', currency: \'EUR\' });

  console.log(\'pt-BR: \' + formatadorBR.format(numero));
  console.log(\'de-DE: \' + formatadorDE.format(numero));
}

// exercicio212();
```

---

### Exerc√≠cio 213: Internacionaliza√ß√£o - `Intl.Collator`

**Descri√ß√£o do Problema**: Use `Intl.Collator` para ordenar um array de strings que contenham acentos, de acordo com as regras do locale `pt-BR`.

**Entrada (Input)**:
```javascript
palavras = [\'√≠m√£\", \'avi√£o\", \'elefante\"]
```

**Sa√≠da Esperada (Output)**:
```
[ \'avi√£o\", \'elefante\", \'√≠m√£\" ]
```

**Restri√ß√µes/Observa√ß√µes**: Use o m√©todo `compare` do colator dentro de `Array.sort()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio213() {
  const palavras = [\'√≠m√£\", \'avi√£o\", \'elefante\"];
  const collator = new Intl.Collator(\'pt-BR\');

  palavras.sort(collator.compare);

  console.log(palavras);
}

// exercicio213();
```

---

### Exerc√≠cio 214: Express√£o Regular - Lookbehind Positivo

**Descri√ß√£o do Problema**: Use uma express√£o regular com lookbehind positivo (`(?<=...)`) para encontrar n√∫meros que s√£o precedidos pelo s√≠mbolo de d√≥lar (`$`).

**Entrada (Input)**:
```
texto = \'O pre√ßo √© $100, mas o custo √© 50.\"
```

**Sa√≠da Esperada (Output)**:
```
[ \'100\" ]
```

**Restri√ß√µes/Observa√ß√µes**: O lookbehind verifica o que vem antes sem incluir no match.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio214(texto) {
  const regex = /(?<=\$)\d+/g;
  return texto.match(regex);
}

// console.log(exercicio214(\'O pre√ßo √© $100, mas o custo √© 50.\'));
```

---

### Exerc√≠cio 215: Express√£o Regular - Lookbehind Negativo

**Descri√ß√£o do Problema**: Use uma express√£o regular com lookbehind negativo (`(?<!...)`) para encontrar n√∫meros que **n√£o** s√£o precedidos pelo s√≠mbolo de d√≥lar (`$`).

**Entrada (Input)**:
```
texto = \'O pre√ßo √© $100, mas o custo √© 50.\"
```

**Sa√≠da Esperada (Output)**:
```
[ \'50\" ]
```

**Restri√ß√µes/Observa√ß√µes**: O lookbehind negativo garante que o padr√£o anterior n√£o exista.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio215(texto) {
  // Adiciona um espa√ßo antes para garantir que o lookbehind funcione no in√≠cio da string
  const regex = /(?<!\$)\b\d+\b/g;
  return (\' \' + texto).match(regex);
}

// console.log(exercicio215(\'O pre√ßo √© $100, mas o custo √© 50.\'));
```

---

### Exerc√≠cio 216: Express√£o Regular - Grupos de Captura Nomeados

**Descri√ß√£o do Problema**: Use grupos de captura nomeados para extrair o ano, m√™s e dia de uma data no formato `YYYY-MM-DD`. Imprima o objeto `groups` do resultado.

**Entrada (Input)**:
```
data = \'2025-10-05\"
```

**Sa√≠da Esperada (Output)**:
```javascript
{ ano: \'2025\", mes: \'10\", dia: \'05\" }
```

**Restri√ß√µes/Observa√ß√µes**: Use a sintaxe `(?<nome>...)`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio216(data) {
  const regex = /(?<ano>\d{4})-(?<mes>\d{2})-(?<dia>\d{2})/;
  const resultado = data.match(regex);
  return resultado.groups;
}

// console.log(exercicio216(\'2025-10-05\'));
```

---

### Exerc√≠cio 217: `Array.prototype.flatMap()`

**Descri√ß√£o do Problema**: Dado um array de frases, use `flatMap()` para primeiro dividir cada frase em palavras e depois achatar o resultado em um √∫nico array de palavras.

**Entrada (Input)**:
```javascript
frases = [\'Ol√° mundo\", \'JavaScript √© incr√≠vel\"]
```

**Sa√≠da Esperada (Output)**:
```
[ \'Ol√°\", \'mundo\", \'JavaScript\", \'√©\", \'incr√≠vel\" ]
```

**Restri√ß√µes/Observa√ß√µes**: `flatMap` √© equivalente a `map` seguido de `flat` com profundidade 1.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio217(frases) {
  return frases.flatMap(frase => frase.split(\' \'));
}

// console.log(exercicio217([\'Ol√° mundo\", \'JavaScript √© incr√≠vel\"]));
```

---

### Exerc√≠cio 218: `Object.fromEntries()`

**Descri√ß√£o do Problema**: Dado um `Map`, converta-o de volta para um objeto usando `Object.fromEntries()`.

**Entrada (Input)**:
```javascript
map = new Map([ [\'a\", 1], [\'b\", 2] ])
```

**Sa√≠da Esperada (Output)**:
```javascript
{ a: 1, b: 2 }
```

**Restri√ß√µes/Observa√ß√µes**: `Object.fromEntries` √© o inverso de `Object.entries`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio218(map) {
  return Object.fromEntries(map);
}

// const map = new Map([ [\'a\", 1], [\'b\", 2] ]);
// console.log(exercicio218(map));
```

---

### Exerc√≠cio 219: `String.prototype.matchAll()`

**Descri√ß√£o do Problema**: Use `matchAll()` para encontrar todas as ocorr√™ncias de uma palavra em uma string, incluindo seus √≠ndices. Itere sobre o resultado e imprima cada match.

**Entrada (Input)**:
```
texto = \'teste aqui, teste ali, teste em todo lugar.\"
palavra = /teste/g
```

**Sa√≠da Esperada (Output)**:
```
Encontrado \'teste\' no √≠ndice 0
Encontrado \'teste\' no √≠ndice 12
Encontrado \'teste\' no √≠ndice 23
```

**Restri√ß√µes/Observa√ß√µes**: `matchAll` retorna um iterador.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio219(texto, regex) {
  const matches = texto.matchAll(regex);
  for (const match of matches) {
    console.log(`Encontrado \'${match[0]}\' no √≠ndice ${match.index}`);
  }
}

// exercicio219(\'teste aqui, teste ali, teste em todo lugar.\', /teste/g);
```

---

### Exerc√≠cio 220: `globalThis`

**Descri√ß√£o do Problema**: Escreva uma fun√ß√£o que imprima o objeto global do ambiente (seja `window` no navegador, `global` no Node.js antigo, ou o objeto global em um Worker) de forma agn√≥stica, usando `globalThis`.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
```
O objeto global √© igual a globalThis? true
```

**Restri√ß√µes/Observa√ß√µes**: Demonstre que `globalThis` aponta para o objeto global correto no ambiente Node.js.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio220() {
  // No Node.js, o objeto global principal √© `global`
  console.log(\'O objeto global √© igual a globalThis? \' + (global === globalThis));
}

// exercicio220();
```

---

### Exerc√≠cio 221: Valida√ß√£o de Senha Forte com Regex

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que use uma √∫nica express√£o regular para validar se uma senha √© forte. Crit√©rios: m√≠nimo 8 caracteres, pelo menos uma letra mai√∫scula, uma min√∫scula, um n√∫mero e um caractere especial.

**Entrada (Input)**:
```
- \'Senha@123\"
- \'senhafraca\"
- \'Senha123\"
```

**Sa√≠da Esperada (Output)**:
```
true
false
false
```

**Restri√ß√µes/Observa√ß√µes**: Use lookaheads positivos para verificar a presen√ßa de cada tipo de caractere.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio221(senha) {
  const regex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
  return regex.test(senha);
}

// console.log(exercicio221(\'Senha@123\'));
// console.log(exercicio221(\'senhafraca\'));
// console.log(exercicio221(\'Senha123\'));
```

---

### Exerc√≠cio 222: Recurs√£o de Cauda (Tail Call Optimization) - Conceito

**Descri√ß√£o do Problema**: Reescreva a fun√ß√£o fatorial de forma que a chamada recursiva seja a √∫ltima opera√ß√£o (recurs√£o de cauda). Embora o Node.js n√£o otimize isso por padr√£o, √© um conceito importante.

**Entrada (Input)**:
```
fatorialDeCauda(5)
```

**Sa√≠da Esperada (Output)**:
```
120
```

**Restri√ß√µes/Observa√ß√µes**: A fun√ß√£o deve usar um acumulador como par√¢metro.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio222(n, acumulador = 1) {
  if (n === 0) {
    return acumulador;
  }
  return exercicio222(n - 1, n * acumulador);
}

// console.log(exercicio222(5));
// console.log(exercicio222(10));
```

---

### Exerc√≠cio 223: Composi√ß√£o de Fun√ß√µes

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o `compose` que receba duas ou mais fun√ß√µes e retorne uma nova fun√ß√£o que √© a composi√ß√£o delas (ex: `compose(f, g)` √© `x => f(g(x))`).

**Entrada (Input)**:
```javascript
dobrar = x => x * 2
somar1 = x => x + 1
funcaoComposta = compose(dobrar, somar1)
funcaoComposta(5) // dobrar(somar1(5)) = dobrar(6) = 12
```

**Sa√≠da Esperada (Output)**:
```
12
```

**Restri√ß√µes/Observa√ß√µes**: Use `reduce()` para compor as fun√ß√µes.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio223(...fns) {
  return function(x) {
    return fns.reduceRight((acc, fn) => fn(acc), x);
  };
}

// const dobrar = x => x * 2;
// const somar1 = x => x + 1;
// const funcaoComposta = exercicio223(dobrar, somar1);
// console.log(funcaoComposta(5));
```

---

### Exerc√≠cio 224: `Top-level await` (Conceito)

**Descri√ß√£o do Problema**: Demonstre o conceito de `top-level await`. Crie um arquivo `.mjs` que use `await` fora de uma fun√ß√£o `async` para buscar um dado e depois o utilize.

**Entrada (Input)**:
(Arquivo `app.mjs`)

**Sa√≠da Esperada (Output)**:
```
Dado buscado: { id: 1, nome: \'Exemplo\" }
```

**Restri√ß√µes/Observa√ß√µes**: Requer um m√≥dulo ES (`.mjs`) e uma Promise para aguardar.

**Solu√ß√£o (Esqueleto)**:
```javascript
// app.mjs
/*
const buscarDado = new Promise(resolve => {
  setTimeout(() => resolve({ id: 1, nome: \'Exemplo\" }), 100);
});

console.log(\'Buscando dado...\');
const dado = await buscarDado;
console.log(\'Dado buscado: \' + JSON.stringify(dado));
*/

// Simula√ß√£o:
function exercicio224() {
  console.log(\'Este exerc√≠cio requer a execu√ß√£o em um arquivo .mjs separado.\");
}

// exercicio224();
```

---

### Exerc√≠cio 225: Criar um Servidor HTTP B√°sico (Node.js)

**Descri√ß√£o do Problema**: Use o m√≥dulo `http` do Node.js para criar um servidor web simples que escute na porta 3000 e responda a todas as requisi√ß√µes com "Ol√°, Mundo!".

**Entrada (Input)**:
(Executar o script e acessar `http://localhost:3000`)

**Sa√≠da Esperada (Output)**:
(Servidor rodando no console)

**Restri√ß√µes/Observa√ß√µes**: Requer o m√≥dulo `http`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio225() {
  const http = require(\'http\');

  const server = http.createServer((req, res) => {
    res.writeHead(200, { \'Content-Type\': \'text/plain\' });
    res.end(\'Ol√°, Mundo!\');
  });

  server.listen(3000, () => {
    console.log(\'Servidor rodando em http://localhost:3000/\');
  });

  // Para parar o servidor ap√≥s um tempo em um ambiente de teste:
  // setTimeout(() => server.close(), 1000);
}

// exercicio225();
```

---

### Exerc√≠cio 226: Servidor HTTP com Rotas Simples

**Descri√ß√£o do Problema**: Melhore o servidor anterior para responder de forma diferente com base na URL da requisi√ß√£o. Se a URL for `/`, responda "P√°gina Inicial". Se for `/sobre`, responda "P√°gina Sobre". Para outras, responda "P√°gina n√£o encontrada".

**Entrada (Input)**:
(Acessar `/` e `/sobre`)

**Sa√≠da Esperada (Output)**:
(Respostas diferentes no navegador/cliente)

**Restri√ß√µes/Observa√ß√µes**: Verifique `req.url`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio226() {
  const http = require(\'http\');

  const server = http.createServer((req, res) => {
    res.writeHead(200, { \'Content-Type\': \'text/plain\' });
    if (req.url === \'/\') {
      res.end(\'P√°gina Inicial\');
    } else if (req.url === \'/sobre\') {
      res.end(\'P√°gina Sobre\');
    } else {
      res.writeHead(404);
      res.end(\'P√°gina n√£o encontrada\');
    }
  });

  server.listen(3001, () => {
    console.log(\'Servidor com rotas rodando em http://localhost:3001/\');
  });

  // setTimeout(() => server.close(), 1000);
}

// exercicio226();
```

---

### Exerc√≠cio 227: Servidor HTTP que Serve JSON

**Descri√ß√£o do Problema**: Crie um servidor HTTP que, ao receber uma requisi√ß√£o em `/api/usuario`, responda com um objeto JSON `{ id: 1, nome: \'Usu√°rio Teste\" }`.

**Entrada (Input)**:
(Acessar `/api/usuario`)

**Sa√≠da Esperada (Output)**:
(Resposta JSON no cliente)

**Restri√ß√µes/Observa√ß√µes**: Defina o `Content-Type` para `application/json`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio227() {
  const http = require(\'http\');

  const server = http.createServer((req, res) => {
    if (req.url === \'/api/usuario\') {
      res.writeHead(200, { \'Content-Type\': \'application/json\' });
      const usuario = { id: 1, nome: \'Usu√°rio Teste\" };
      res.end(JSON.stringify(usuario));
    } else {
      res.writeHead(404);
      res.end(\'Endpoint n√£o encontrado\');
    }
  });

  server.listen(3002, () => {
    console.log(\'Servidor JSON rodando em http://localhost:3002/\');
  });

  // setTimeout(() => server.close(), 1000);
}

// exercicio227();
```

---

### Exerc√≠cio 228: Cliente HTTP - `http.get`

**Descri√ß√£o do Problema**: Use `http.get` para fazer uma requisi√ß√£o a uma API p√∫blica (ex: `http://jsonplaceholder.typicode.com/todos/1`) e imprima o corpo da resposta no console.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
(O corpo da resposta JSON da API)

**Restri√ß√µes/Observa√ß√µes**: A resposta chega em chunks, ent√£o √© preciso concaten√°-los.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio228() {
  const http = require(\'http\');

  http.get(\'http://jsonplaceholder.typicode.com/todos/1\", (res) => {
    let data = \'\";
    res.on(\'data\", (chunk) => { data += chunk; });
    res.on(\'end\", () => {
      console.log(JSON.parse(data));
    });
  }).on(\'error\", (err) => {
    console.error(\'Erro: \' + err.message);
  });
}

// exercicio228();
```

---

### Exerc√≠cio 229: Cliente HTTP - `http.request` (POST)

**Descri√ß√£o do Problema**: Use `http.request` para fazer uma requisi√ß√£o POST para uma API de teste (ex: `jsonplaceholder.typicode.com/posts`), enviando um objeto JSON no corpo. Imprima a resposta.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
(A resposta da API, geralmente o objeto criado com um novo ID)

**Restri√ß√µes/Observa√ß√µes**: Configure os `options` (m√©todo, headers) e escreva os dados no corpo da requisi√ß√£o.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio229() {
  const http = require(\'http\');

  const postData = JSON.stringify({
    title: \'foo\",
    body: \'bar\",
    userId: 1,
  });

  const options = {
    hostname: \'jsonplaceholder.typicode.com\",
    port: 80,
    path: \'/posts\",
    method: \'POST\",
    headers: {
      \'Content-Type\': \'application/json\",
      \'Content-Length\': Buffer.byteLength(postData),
    },
  };

  const req = http.request(options, (res) => {
    let data = \'\";
    res.on(\'data\", (chunk) => { data += chunk; });
    res.on(\'end\", () => {
      console.log(\'Resposta do POST: \' + data);
    });
  });

  req.on(\'error\", (e) => console.error(`Problema com a requisi√ß√£o: ${e.message}`));
  req.write(postData);
  req.end();
}

// exercicio229();
```

---

### Exerc√≠cio 230: `URLSearchParams`

**Descri√ß√£o do Problema**: Crie um objeto `URLSearchParams` a partir de uma string de query `?id=123&categoria=livros`. Modifique um par√¢metro, adicione um novo e imprima a string de query resultante.

**Entrada (Input)**:
```
query = \'id=123&categoria=livros\"
```

**Sa√≠da Esperada (Output)**:
```
Query final: id=123&categoria=tecnologia&pagina=1
```

**Restri√ß√µes/Observa√ß√µes**: Use os m√©todos `set()`, `append()` e `toString()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio230() {
  const params = new URLSearchParams(\'id=123&categoria=livros\');
  params.set(\'categoria\", \'tecnologia\');
  params.append(\'pagina\", \'1\');
  console.log(\'Query final: \' + params.toString());
}

// exercicio230();
```

---

### Exerc√≠cio 231: `URL` API

**Descri√ß√£o do Problema**: Crie um objeto `URL` a partir de uma string de URL completa. Acesse e imprima diferentes partes da URL, como `protocol`, `hostname`, `pathname` e `searchParams`.

**Entrada (Input)**:
```
urlString = \'https://www.exemplo.com/caminho?id=123#secao\"
```

**Sa√≠da Esperada (Output)**:
```
Protocolo: https:
Hostname: www.exemplo.com
Pathname: /caminho
Search Param \'id\': 123
```

**Restri√ß√µes/Observa√ß√µes**: O objeto `URL` parseia a string em componentes.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio231() {
  const myURL = new URL(\'https://www.exemplo.com/caminho?id=123#secao\');

  console.log(\'Protocolo: \' + myURL.protocol);
  console.log(\'Hostname: \' + myURL.hostname);
  console.log(\'Pathname: \' + myURL.pathname);
  console.log(\'Search Param \'id\': \' + myURL.searchParams.get(\'id\'));
}

// exercicio231();
```

---

### Exerc√≠cio 232: `console.time` e `console.timeEnd`

**Descri√ß√£o do Problema**: Use `console.time()` e `console.timeEnd()` para medir o tempo de execu√ß√£o de um loop que executa 1 milh√£o de vezes.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
```
Loop: X.XXXms
```
(O tempo exato ir√° variar)

**Restri√ß√µes/Observa√ß√µes**: Use o mesmo r√≥tulo para `time` e `timeEnd`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio232() {
  console.time(\'Loop\');
  for (let i = 0; i < 1000000; i++) {
    // Opera√ß√£o vazia para medir o tempo do loop
  }
  console.timeEnd(\'Loop\');
}

// exercicio232();
```

---

### Exerc√≠cio 233: `console.table`

**Descri√ß√£o do Problema**: Crie um array de objetos (representando usu√°rios) e use `console.table()` para exibi-los em um formato de tabela no console.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
(Uma tabela bem formatada no console)

**Restri√ß√µes/Observa√ß√µes**: `console.table` √© √≥timo para visualizar arrays de objetos ou objetos.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio233() {
  const usuarios = [
    { id: 1, nome: \'Alice\', email: \'alice@email.com\" },
    { id: 2, nome: \'Bob\', email: \'bob@email.com\" },
    { id: 3, nome: \'Charlie\', email: \'charlie@email.com\" },
  ];
  console.table(usuarios);
}

// exercicio233();
```

---

### Exerc√≠cio 234: `console.trace`

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o aninhada que chame outra. Na fun√ß√£o mais interna, use `console.trace()` para imprimir a pilha de chamadas (stack trace) at√© aquele ponto.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
(Uma pilha de chamadas mostrando a sequ√™ncia de fun√ß√µes chamadas)

**Restri√ß√µes/Observa√ß√µes**: √ötil para depurar de onde uma fun√ß√£o est√° sendo chamada.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio234() {
  function funcaoA() {
    funcaoB();
  }

  function funcaoB() {
    funcaoC();
  }

  function funcaoC() {
    console.trace(\'Rastreando a chamada\');
  }

  funcaoA();
}

// exercicio234();
```

---

### Exerc√≠cio 235: `process.argv`

**Descri√ß√£o do Problema**: Escreva um script Node.js que leia argumentos da linha de comando usando `process.argv` e os imprima. Demonstre como execut√°-lo com argumentos.

**Entrada (Input)**:
(Linha de comando: `node meu_script.js arg1 arg2`)

**Sa√≠da Esperada (Output)**:
```
Argumentos: [ \'arg1\", \'arg2\" ]
```

**Restri√ß√µes/Observa√ß√µes**: `process.argv` inclui o caminho do node e do script nos dois primeiros elementos.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio235() {
  // process.argv[0] √© o execut√°vel do Node
  // process.argv[1] √© o caminho para o script
  const args = process.argv.slice(2);
  console.log(\'Argumentos: \' + JSON.stringify(args));
}

// Para testar, execute no terminal: node -e \'(${exercicio235.toString()})()\' arg1 arg2
// exercicio235();
```

---

### Exerc√≠cio 236: `process.env`

**Descri√ß√£o do Problema**: Escreva um script Node.js que leia uma vari√°vel de ambiente (ex: `USUARIO`) e a imprima. Se n√£o estiver definida, imprima um valor padr√£o.

**Entrada (Input)**:
(Linha de comando: `USUARIO=Gemini node meu_script.js`)

**Sa√≠da Esperada (Output)**:
```
Ol√°, Gemini!
```

**Restri√ß√µes/Observa√ß√µes**: As vari√°veis de ambiente s√£o acessadas atrav√©s de `process.env`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio236() {
  const nomeUsuario = process.env.USUARIO || \'Visitante\";
  console.log(`Ol√°, ${nomeUsuario}!`);
}

// Para testar, execute no terminal: USUARIO=Gemini node -e \'(${exercicio236.toString()})()\'
// exercicio236();
```

---

### Exerc√≠cio 237: `process.exit()`

**Descri√ß√£o do Problema**: Escreva um script que execute uma tarefa e, se um erro ocorrer, saia do processo com um c√≥digo de status de erro (1). Se for bem-sucedido, saia com c√≥digo 0.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
(O processo termina com um c√≥digo de status espec√≠fico)

**Restri√ß√µes/Observa√ß√µes**: Use `process.exit(code)`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio237(deveFalhar) {
  console.log(\'Iniciando tarefa...\');
  if (deveFalhar) {
    console.error(\'Ocorreu um erro! Saindo...\');
    process.exit(1);
  } else {
    console.log(\'Tarefa conclu√≠da com sucesso!\');
    process.exit(0);
  }
}

// Para testar, execute no terminal:
// node -e \'(${exercicio237.toString()})(false)\'
// node -e \'(${exercicio237.toString()})(true)\'
```

---

### Exerc√≠cio 238: `os` Module - Informa√ß√µes do Sistema

**Descri√ß√£o do Problema**: Use o m√≥dulo `os` do Node.js para obter e imprimir o tipo de sistema operacional, a mem√≥ria total em GB e o n√∫mero de CPUs.

**Entrada (Input)**:
N√£o h√° entrada direta.

**Sa√≠da Esperada (Output)**:
```
Tipo de SO: (ex: Linux)
Mem√≥ria Total (GB): (ex: 15.5)
N√∫mero de CPUs: (ex: 8)
```

**Restri√ß√µes/Observa√ß√µes**: Requer o m√≥dulo `os`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio238() {
  const os = require(\'os\');

  console.log(\'Tipo de SO: \' + os.type());
  const memTotalGB = os.totalmem() / 1024 / 1024 / 1024;
  console.log(\'Mem√≥ria Total (GB): \' + memTotalGB.toFixed(1));
  console.log(\'N√∫mero de CPUs: \' + os.cpus().length);
}

// exercicio238();
```

---

### Exerc√≠cio 239: `path` Module - Manipula√ß√£o de Caminhos

**Descri√ß√£o do Problema**: Use o m√≥dulo `path` para juntar segmentos de um caminho, extrair o nome do arquivo e a extens√£o de um caminho completo.

**Entrada (Input)**:
```
caminho = \'/home/usuario/documentos/relatorio.pdf\"
```

**Sa√≠da Esperada (Output)**:
```
Caminho completo: /home/usuario/documentos/relatorio.pdf
Nome do arquivo: relatorio.pdf
Extens√£o: .pdf
```

**Restri√ß√µes/Observa√ß√µes**: Requer o m√≥dulo `path`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio239() {
  const path = require(\'path\');

  const caminhoCompleto = path.join(\'/home\", \'usuario\", \'documentos\", \'relatorio.pdf\');
  console.log(\'Caminho completo: \' + caminhoCompleto);

  const nomeArquivo = path.basename(caminhoCompleto);
  console.log(\'Nome do arquivo: \' + nomeArquivo);

  const extensao = path.extname(caminhoCompleto);
  console.log(\'Extens√£o: \' + extensao);
}

// exercicio239();
```

---

### Exerc√≠cio 240: `fs.promises` API

**Descri√ß√£o do Problema**: Reescreva o exerc√≠cio de leitura de arquivo ass√≠ncrona (Exerc√≠cio 132) usando a API de Promises do `fs` (`fs.promises`) com `async/await`.

**Entrada (Input)**:
(Arquivo `dados_promise.txt` criado previamente)

**Sa√≠da Esperada (Output)**:
```
Conte√∫do do arquivo (Promise): Conte√∫do para promises.
```

**Restri√ß√µes/Observa√ß√µes**: Use `require(\'fs\').promises`.

**Solu√ß√£o (Esqueleto)**:
```javascript
// Crie o arquivo primeiro:
// shell.exec(\'echo "Conte√∫do para promises." > dados_promise.txt\");

async function exercicio240() {
  const fs = require(\'fs\').promises;
  try {
    const data = await fs.readFile(\'dados_promise.txt\", \'utf8\');
    console.log(\'Conte√∫do do arquivo (Promise): \' + data);
  } catch (err) {
    console.error(\'Erro ao ler arquivo com promises:\", err);
  }
}

// exercicio240();
```

---

### Exerc√≠cio 241: Remover Duplicatas de Array de Objetos

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array de objetos e uma chave. A fun√ß√£o deve retornar um novo array contendo apenas os objetos √∫nicos com base no valor daquela chave.

**Entrada (Input)**:
```javascript
array = [{id: 1, nome: \'A\"}, {id: 2, nome: \'B\"}, {id: 1, nome: \'C\"}]
chave = \'id\"
```

**Sa√≠da Esperada (Output)**:
```javascript
[{id: 1, nome: \'A\"}, {id: 2, nome: \'B\"}]
```

**Restri√ß√µes/Observa√ß√µes**: A primeira ocorr√™ncia do objeto deve ser mantida.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio241(array, chave) {
  const vistos = new Set();
  return array.filter(obj => {
    const valor = obj[chave];
    if (vistos.has(valor)) {
      return false;
    } else {
      vistos.add(valor);
      return true;
    }
  });
}

// const array = [{id: 1, nome: \'A\"}, {id: 2, nome: \'B\"}, {id: 1, nome: \'C\"}];
// console.log(exercicio241(array, \'id\'));
```

---

### Exerc√≠cio 242: Agrupar Array de Objetos por Chave

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um array de objetos e uma chave, e agrupe os objetos em um novo objeto com base nos valores da chave especificada.

**Entrada (Input)**:
```javascript
array = [{cat: \'A\", val: 1}, {cat: \'B\", val: 2}, {cat: \'A\", val: 3}]
chave = \'cat\"
```

**Sa√≠da Esperada (Output)**:
```javascript
{
  A: [{cat: \'A\", val: 1}, {cat: \'A\", val: 3}],
  B: [{cat: \'B\", val: 2}]
}
```

**Restri√ß√µes/Observa√ß√µes**: Use `reduce()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio242(array, chave) {
  return array.reduce((acc, obj) => {
    const grupo = obj[chave];
    if (!acc[grupo]) {
      acc[grupo] = [];
    }
    acc[grupo].push(obj);
    return acc;
  }, {});
}

// const array = [{cat: \'A\", val: 1}, {cat: \'B\", val: 2}, {cat: \'A\", val: 3}];
// console.log(exercicio242(array, \'cat\'));
```

---

### Exerc√≠cio 243: Debounce de Fun√ß√£o

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o `debounce(fn, delay)` que receba uma fun√ß√£o e um atraso. A fun√ß√£o retornada s√≥ deve ser executada ap√≥s o atraso ter passado desde a √∫ltima chamada.

**Entrada (Input)**:
(Chamadas r√°pidas e sucessivas da fun√ß√£o debounced)

**Sa√≠da Esperada (Output)**:
(A fun√ß√£o original √© executada apenas uma vez, ap√≥s a √∫ltima chamada)

**Restri√ß√µes/Observa√ß√µes**: Use `setTimeout` e `clearTimeout`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function debounce(fn, delay) {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

// Exemplo de uso:
// const minhaFuncao = () => console.log(\'Fun√ß√£o executada!\');
// const funcaoDebounced = debounce(minhaFuncao, 1000);
// funcaoDebounced();
// funcaoDebounced(); // Esta chamada reinicia o timer
```

---

### Exerc√≠cio 244: Throttle de Fun√ß√£o

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o `throttle(fn, limit)` que receba uma fun√ß√£o e um limite de tempo. A fun√ß√£o retornada s√≥ poder√° ser executada uma vez dentro do per√≠odo de tempo especificado.

**Entrada (Input)**:
(Chamadas r√°pidas e sucessivas da fun√ß√£o throttled)

**Sa√≠da Esperada (Output)**:
(A fun√ß√£o original √© executada no m√°ximo uma vez a cada `limit` ms)

**Restri√ß√µes/Observa√ß√µes**: √ötil para controlar a taxa de eventos como scroll ou resize.

**Solu√ß√£o (Esqueleto)**:
```javascript
function throttle(fn, limit) {
  let emThrottle;
  return function(...args) {
    if (!emThrottle) {
      fn.apply(this, args);
      emThrottle = true;
      setTimeout(() => (emThrottle = false), limit);
    }
  };
}

// Exemplo de uso:
// const minhaFuncao = () => console.log(\'Fun√ß√£o executada!\');
// const funcaoThrottled = throttle(minhaFuncao, 1000);
// setInterval(funcaoThrottled, 100); // Tenta chamar a cada 100ms
```

---

### Exerc√≠cio 245: Valida√ß√£o de CNPJ (Formato)

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que use express√£o regular para validar se uma string est√° no formato de CNPJ (`XX.XXX.XXX/XXXX-XX`).

**Entrada (Input)**:
```
- \'12.345.678/0001-90\"
- \'12345678000190\"
```

**Sa√≠da Esperada (Output)**:
```
true
false
```

**Restri√ß√µes/Observa√ß√µes**: A valida√ß√£o √© apenas do formato, n√£o dos d√≠gitos verificadores.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio245(cnpj) {
  const regex = /^\d{2}\.\d{3}\.\d{3}\/\d{4}-\d{2}$/;
  return regex.test(cnpj);
}

// console.log(exercicio245(\'12.345.678/0001-90\'));
// console.log(exercicio245(\'12345678000190\'));
```

---

### Exerc√≠cio 246: Inverter Chaves e Valores de um Objeto

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um objeto e retorne um novo objeto com as chaves e valores invertidos. Assuma que todos os valores s√£o strings √∫nicas.

**Entrada (Input)**:
```javascript
objeto = { a: \'1\", b: \'2\" }
```

**Sa√≠da Esperada (Output)**:
```javascript
{ \'1\": \'a\", \'2\": \'b\" }
```

**Restri√ß√µes/Observa√ß√µes**: Use `Object.entries()` e `reduce()` ou `Object.fromEntries()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio246(obj) {
  return Object.entries(obj).reduce((acc, [key, value]) => {
    acc[value] = key;
    return acc;
  }, {});
}

// console.log(exercicio246({ a: \'1\", b: \'2\" }));
```

---

### Exerc√≠cio 247: Verificar se um Objeto est√° Vazio

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o que receba um objeto e retorne `true` se ele n√£o tiver nenhuma propriedade pr√≥pria, e `false` caso contr√°rio.

**Entrada (Input)**:
```
- {}
- { a: 1 }
```

**Sa√≠da Esperada (Output)**:
```
true
false
```

**Restri√ß√µes/Observa√ß√µes**: Use `Object.keys()`.

**Solu√ß√£o (Esqueleto)**:
```javascript
function exercicio247(obj) {
  return Object.keys(obj).length === 0;
}

// console.log(exercicio247({}));
// console.log(exercicio247({ a: 1 }));
```

---

### Exerc√≠cio 248: Implementar `Array.prototype.meuMap`

**Descri√ß√£o do Problema**: Estenda o prot√≥tipo de `Array` com uma fun√ß√£o `meuMap` que se comporte como o m√©todo `map` original.

**Entrada (Input)**:
```javascript
[1, 2, 3].meuMap(x => x * 2)
```

**Sa√≠da Esperada (Output)**:
```
[2, 4, 6]
```

**Restri√ß√µes/Observa√ß√µes**: N√£o use o m√©todo `map` original na sua implementa√ß√£o. Modificar prot√≥tipos de objetos nativos n√£o √© uma boa pr√°tica em produ√ß√£o.

**Solu√ß√£o (Esqueleto)**:
```javascript
Array.prototype.meuMap = function(callback) {
  const resultado = [];
  for (let i = 0; i < this.length; i++) {
    resultado.push(callback(this[i], i, this));
  }
  return resultado;
};

function exercicio248() {
  const arr = [1, 2, 3];
  console.log(arr.meuMap(x => x * 2));
}

// exercicio248();
```

---

### Exerc√≠cio 249: Implementar `Array.prototype.meuFilter`

**Descri√ß√£o do Problema**: Estenda o prot√≥tipo de `Array` com uma fun√ß√£o `meuFilter` que se comporte como o m√©todo `filter` original.

**Entrada (Input)**:
```javascript
[1, 2, 3, 4].meuFilter(x => x % 2 === 0)
```

**Sa√≠da Esperada (Output)**:
```
[2, 4]
```

**Restri√ß√µes/Observa√ß√µes**: N√£o use o m√©todo `filter` original na sua implementa√ß√£o.

**Solu√ß√£o (Esqueleto)**:
```javascript
Array.prototype.meuFilter = function(callback) {
  const resultado = [];
  for (let i = 0; i < this.length; i++) {
    if (callback(this[i], i, this)) {
      resultado.push(this[i]);
    }
  }
  return resultado;
};

function exercicio249() {
  const arr = [1, 2, 3, 4];
  console.log(arr.meuFilter(x => x % 2 === 0));
}

// exercicio249();
```

---

### Exerc√≠cio 250: Implementar `Promise.all`

**Descri√ß√£o do Problema**: Crie uma fun√ß√£o `meuPromiseAll` que receba um array de promises e se comporte como `Promise.all`.

**Entrada (Input)**:
```javascript
meuPromiseAll([p1, p2])
```

**Sa√≠da Esperada (Output)**:
(Uma promise que resolve com um array de resultados)

**Restri√ß√µes/Observa√ß√µes**: Lide com o caso de sucesso (todas resolvem) e de falha (qualquer uma rejeita).

**Solu√ß√£o (Esqueleto)**:
```javascript
function meuPromiseAll(promises) {
  return new Promise((resolve, reject) => {
    const resultados = [];
    let promisesConcluidas = 0;
    const totalPromises = promises.length;

    if (totalPromises === 0) {
      resolve(resultados);
      return;
    }

    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then(valor => {
          resultados[index] = valor;
          promisesConcluidas++;
          if (promisesConcluidas === totalPromises) {
            resolve(resultados);
          }
        })
        .catch(reject); // Rejeita assim que a primeira promise falhar
    });
  });
}

// Exemplo de uso:
// const p1 = Promise.resolve(1);
// const p2 = new Promise(resolve => setTimeout(() => resolve(2), 100));
// meuPromiseAll([p1, p2]).then(console.log); // [1, 2]
```

---



# Conclus√£o

Esta cole√ß√£o de 250 exerc√≠cios de JavaScript foi projetada para fornecer uma jornada de aprendizado abrangente e progressiva, desde os conceitos mais b√°sicos at√© os t√≥picos mais avan√ßados da linguagem. Ao trabalhar atrav√©s destes exerc√≠cios, voc√™ ter√° a oportunidade de solidificar seu conhecimento em manipula√ß√£o de dados, programa√ß√£o funcional, orienta√ß√£o a objetos, algoritmos, estruturas de dados, programa√ß√£o ass√≠ncrona e muito mais, tudo dentro de um ambiente Node.js puro, sem a necessidade de um navegador.

Esperamos que este material sirva como uma ferramenta valiosa para estudo, pr√°tica e aprimoramento de suas habilidades em JavaScript. Continue explorando, construindo e desafiando a si mesmo para se tornar um desenvolvedor cada vez mais proficiente.

Bons estudos!


Lista 1 - Express√µes, entrada e sa√≠da de dados
Leia dois n√∫meros inteiros e escreva o resultado de sua soma.
Leia dois n√∫meros inteiros e escreva o resultado de sua subtra√ß√£o.
Leia dois n√∫meros inteiros e escreva o resultado de sua multiplica√ß√£o.
Leia dois n√∫meros inteiros (a e b) e escreva o resultado da divis√£o a / b.
Leia dois n√∫meros inteiros (a e b) e escreva o resultado do resto da divis√£o a % b.
Leia dois n√∫meros reais e escreva o resultado de sua soma.
Leia o nome de uma pessoa e escreva uma frase de sauda√ß√£o, como: Ol√°, Fulano.
A m√©dia aritm√©tica de dois ou mais termos √© o quociente do resultado da divis√£o da soma dos n√∫meros dados pela quantidade de n√∫meros somados. Elabore um algoritmo que leia as 4 notas de um aluno e escreva sua m√©dia aritm√©tica.
A autonomia de um ve√≠culo √© baseada em quantos quil√¥metros ele consegue percorrer a cada litro de combust√≠vel consumido. Por exemplo, √© comum afirmar que tal carro √© capaz de fazer 15 quil√¥metros por litro de combust√≠vel. Com base nisso, elabore um algoritmo que leia uma dist√¢ncia percorrida em quil√¥metros e uma quantidade de litros de combust√≠vel consumidos, e informe quantos quil√¥metros este ve√≠culo pode percorrer com cada litro.
A velocidade m√©dia de um ve√≠culo pode ser calculada se tivermos os seguintes valores: a dist√¢ncia percorrida e o tempo gasto para percorrer esta dist√¢ncia. Com base nisso, elabore um algoritmo que leia uma dist√¢ncia percorrida em quil√¥metros e o tempo gasto em horas, e informe a velocidade m√©dia desse ve√≠culo.
Alguns pa√≠ses de l√≠ngua inglesa, como os EUA, utilizam da unidade de medida grau Fahrenheit como escala de temperatura. Para converter uma temperatura de Celsius para Fahrenheit, podemos aplicar a f√≥rmula F=(9*C+160)/5 ou a f√≥rmula F=C*1.8+32, onde F √© a temperatura em Fahrenheit e C a temperatura em Celsius. Elabore um algoritmo que leia uma temperatura em graus Celsius e a escreva convertida em graus Fahrenheit.
Para auxiliar uma loja que deseja parcelar o valor das compras de seus clientes, elabore um algoritmo que leia o valor de uma compra e o n√∫mero de presta√ß√µes desejadas, e escreva o valor das presta√ß√µes.
No com√©rcio, os pre√ßos dos produtos geralmente s√£o definidos com base em uma margem percentual de lucro. Considere um produto adquirido por uma loja pelo valor de R$ 100,00. Se esta loja aplicar a este produto um percentual de 15% de lucro, o produto ser√° revendido pelo valor de R$ 115,00. Elabore um algoritmo que leia o valor de compra de um produto e o percentual de lucro desejado, e escreva o valor de revenda deste produto.
Voc√™ foi encarregado de realizar uma pesquisa sobre Inclus√£o Digital. A sua pesquisa dever√° apresentar o percentual de alunos da sua escola que possuem acesso √† internet. Para isso, elabore um algoritmo que leia o n√∫mero total de alunos da sua escola e o n√∫mero de alunos que possuem acesso √† internet, por fim, com base nestes dados, escreva o percentual de alunos com acesso √† internet. Ex.: Em uma escola com 200 alunos, apenas 50 alunos possuem acesso √† internet, o que equivale a 25% destes 200 alunos.
Em uma pequena loja de eletr√¥nica s√£o vendidos resistores, diodos e transistores. Seus pre√ßos s√£o R$ 0.70, R$ 0.80 e R$ 0.95, respectivamente. T√™m-se os pre√ßos unit√°rios de cada tipo de pe√ßa e sabe-se que sobre estes pre√ßos incidem descontos de 5% para resistores, 6% para diodos e 9% para transistores. Elabore um programa que leia o nome do cliente e as quantidades de cada item comprado; e escreva o valor total de desconto e o valor l√≠quido a ser pago pela compra.
Lista 2 - Estruturas de decis√£o: Se/Sen√£o
Leia um n√∫mero inteiro e informe se este n√∫mero √© par ou √≠mpar.
Leia a idade de uma pessoa e informe se ela j√° chegou √† maioridade. Se ela ainda n√£o chegou, informe quantos anos faltam para a maioridade.
Construa um algoritmo que leia um n√∫mero inteiro A e um n√∫mero inteiro B. Verifique qual dos dois n√∫meros √© maior e o escreva.
Considerando uma pista em que a velocidade m√°xima permitida √© de 110 km/h, leia a velocidade de um ve√≠culo e informe se ele excedeu ou n√£o a velocidade m√°xima permitida.
Considerando que a temperatura m√©dia ideal do corpo humano varia entre 36¬∞ C e 36,7¬∞ C, elabore um algoritmo que, dada uma temperatura lida, informe se esta pessoa est√° com febre.
Complemente o algoritmo anterior, adicionando a ele a capacidade de informar se a pessoa est√° com hipotermia (abaixo da temperatura m√©dia ideal); dentro da temperatura m√©dia ideal ou com febre.
Elabore um algoritmo que leia um n√∫mero inteiro e informe se este n√∫mero √© um m√∫ltiplo de 7.
Leia um n√∫mero inteiro e informe se este n√∫mero √© par e tamb√©m divis√≠vel por 3.
Para auxiliar um cliente a escolher o produto mais barato em um conjunto de 3 produtos, crie um programa que leia os pre√ßos de 3 produtos e informe qual deles √© o mais barato.
Construa um programa que leia um caractere e informe se este caractere √© uma vogal.
Leia dois n√∫meros inteiros x e y, e informe se x √© divis√≠vel por y.
Considerando que no Brasil √© poss√≠vel votar a partir dos 16 anos de idade, leia o ano de nascimento de uma pessoa e informe se ela poder√° votar no ano atual. Ignore m√™s e dia de nascimento.
Considerando que o ano possui 12 meses, leia um n√∫mero inteiro de 1 a 12 e informe o m√™s que corresponde a este n√∫mero.
Leia dois n√∫meros inteiros x e y e escreva dentre as seguintes hip√≥teses a verdadeira: 1. x e y s√£o pares; 2. x e y s√£o √≠mpares; 3. x √© par e y √© √≠mpar; 4. x √© √≠mpar e y √© par.
Para auxiliar a definir os per√≠odos mais quente e mais frio do dia, elabore um algoritmo que leia a temperatura do per√≠odo matutino, a temperatura do per√≠odo vespertino e a temperatura do per√≠odo noturno, ao fim escreva qual destes per√≠odos foi o mais frio e qual foi o mais quente.
Construa um algoritmo que leia as medidas dos lados de um tri√¢ngulo e informe se este tri√¢ngulo √© equil√°tero, is√≥sceles ou escaleno.
Construa um algoritmo que leia um n√∫mero real e, se ele for maior do que 5, ent√£o escreva a metade deste n√∫mero. Ex.: se leio o n√∫mero 12, 12 √© maior que 5; a metade de 12 √© 6; devo escrever 6.
Construa um algoritmo que leia um n√∫mero inteiro e, se ele for positivo, escreva uma mensagem que informe se este n√∫mero √© ou n√£o divis√≠vel por 2.
Construa um algoritmo que leia dois n√∫meros inteiros diferentes e escreva-os em ordem crescente.
Construa um algoritmo que leia tr√™s n√∫meros inteiros e escreva-os em ordem decrescente.
Crie um algoritmo que leia dois n√∫meros inteiros e escreva uma mensagem dizendo se estes n√∫meros s√£o iguais ou diferentes.
O IMC (√çndice de Massa Corporal) √© uma unidade de medida internacional usada para calcular se uma pessoa est√° no seu peso ideal. A f√≥rmula mais gen√©rica de c√°lculo de IMC √© imc = peso / (altura * altura), onde o peso √© dado em quilos e a altura em metros. H√° uma tabela que define uma classifica√ß√£o para cada faixa de IMC. Segundo esta tabela, pessoas com IMC menor ou igual a 18.5 est√£o abaixo do peso; pessoas com IMC maior que 18.5 e menor que 25 est√£o no peso ideal; j√° as pessoas com IMC maior ou igual a 25 est√£o acima do peso. Elabore um algoritmo que leia peso e altura de uma pessoa, informe seu IMC e tamb√©m se ela est√° abaixo do peso, no peso ideal ou acima do peso.
Lista 3 - Estruturas de decis√£o: Escolha/Caso
Elabore um programa que leia uma letra e informe se esta letra √© uma vogal ou uma consoante.
Elabore um programa que funcione como uma calculadora simples. Seu programa dever√° come√ßar mostrando uma mensagem de apresenta√ß√£o, depois solicitar que o usu√°rio entre com dois n√∫meros reais (a e b) e finalmente ler os dois n√∫meros reais digitados. Logo ap√≥s, o programa dever√° solicitar ao usu√°rio que escolha uma das seguintes op√ß√µes: somar, subtrair, multiplicar ou dividir. Com base na escolha do usu√°rio, exiba o resultado da opera√ß√£o escolhida envolvendo a e b.
Considerando que o ano possui 12 meses, leia um n√∫mero inteiro entre 1 e 12 e, com o uso da estrutura de controle escolha/caso, informe o nome do m√™s que corresponde a este n√∫mero.
Verificar a quantidade de combust√≠vel que ser√° gasta em uma viagem √© de grande import√¢ncia para o condutor. Considerando que um carro do tipo A √© capaz de percorrer 12 quil√¥metros a cada litro de combust√≠vel gasto, um do tipo B percorre 9 quil√¥metros a cada litro e um do tipo C, 8 quil√¥metros por litro, elabore um programa que leia a dist√¢ncia a ser viajada e o tipo de carro, e com base nestes dados informe quantos litros de combust√≠vel ser√£o gastos.
Construa um programa que funcione como um menu para uma lanchonete. Seu programa dever√° iniciar mostrando o nome da sua lanchonete. Em seguida, seu programa dever√° pedir o nome do usu√°rio e, ap√≥s l√™-lo, exibir uma mensagem de boas-vindas. Ap√≥s isso, seu programa dever√° mostrar as op√ß√µes de lanches dispon√≠veis e seus pre√ßos: mostre pelo menos 6 op√ß√µes de lanches diferentes. Permita que o usu√°rio escolha uma das op√ß√µes de lanches e, ap√≥s a escolha, mostre a ele uma mensagem informando a op√ß√£o que ele escolheu e quanto seu pedido ir√° custar. Lembre-se de avisar ao usu√°rio caso ele escolha uma op√ß√£o inexistente.
Construa um programa que leia a primeira letra do m√™s de nascimento de uma pessoa e informe em quais meses essa pessoa pode ter nascido. Caso n√£o exista um m√™s que comece com a letra lida, informe ao usu√°rio que ele se enganou.
Meses
Lista 4 - La√ßos de Repeti√ß√£o: Enquanto e Fa√ßa/Enquanto
Elabore um algoritmo que escreva todos os n√∫meros inteiros de 1 a 100.
Elabore um algoritmo que escreva apenas os n√∫meros pares de 1 a 100.
Elabore um algoritmo que escreva apenas os n√∫meros √≠mpares de 1 a 100.
Elabore um algoritmo que escreva todos os n√∫meros inteiros de 200 a 400.
Elabore um algoritmo que escreva apenas os n√∫meros pares de 300 a 600.
Elabore um algoritmo que escreva apenas os n√∫meros √≠mpares de 750 a 1500.
Construa um programa que leia um n√∫mero inteiro e escreva todos os n√∫meros inteiros de 1 at√© o n√∫mero lido.
Construa um programa que leia um n√∫mero inteiro, verifique se ele √© par ou √≠mpar. Se o n√∫mero for √≠mpar, escreva todos os n√∫meros √≠mpares menores que ele em ordem crescente. Se o n√∫mero for par, escreva todos os n√∫meros pares menores que ele em ordem crescente.
Repita a quest√£o anterior, desta vez imprimindo os n√∫meros em ordem decrescente, desde o n√∫mero lido.
Construa um programa que comece lendo um n√∫mero inteiro qualquer. Este n√∫mero ser√° chamado de piso. Ap√≥s isso, seu programa dever√° ler um outro n√∫mero inteiro (que poder√° ser chamado de proximo) enquanto proximo for maior ou igual a piso.
Elabore um algoritmo que leia dois n√∫meros inteiros diferentes: ini e fim, sendo que ini deve ser menor que fim. Escreva em ordem crescente todos os n√∫meros inteiros entre ini e fim, inclusive eles mesmos.
Repita a quest√£o anterior, desta vez presumindo que ini pode ou n√£o ser maior que fim. Se ini for maior que fim, siga a ordem decrescente.
Construa um programa que repita a tarefa de ler um n√∫mero inteiro, enquanto o n√∫mero lido for maior que 1. Ao t√©rmino das repeti√ß√µes, escreva o resultado da soma de todos os n√∫meros lidos.
Construa um algoritmo que leia dois n√∫meros inteiros diferentes: ini e fim, sendo que ini deve ser menor que fim. Em seguida, escreva o resultado da soma de todos os n√∫meros inteiros entre ini e fim, contando com eles mesmos.
Construa um programa que calcule as m√©dias aritm√©ticas de todos os alunos de uma turma. Seu programa dever√° funcionar da seguinte maneira: leia o nome do aluno; leia as notas dos 4 bimestres; mostre a m√©dia aritm√©tica do aluno; pergunte se o usu√°rio deseja continuar; se o usu√°rio desejar continuar, repita todo o processo, sen√£o, pare.
Lista 5 - La√ßos de Repeti√ß√£o: Para
Elabore um algoritmo que escreva todos os n√∫meros inteiros de 1 a 100.
Elabore um algoritmo que escreva apenas os n√∫meros pares de 1 a 100.
Elabore um algoritmo que escreva apenas os n√∫meros √≠mpares de 1 a 100.
Elabore um algoritmo que escreva todos os n√∫meros inteiros de 200 a 400.
Elabore um algoritmo que escreva apenas os n√∫meros pares de 300 a 600.
Elabore um algoritmo que escreva apenas os n√∫meros √≠mpares de 750 a 1500.
Lista 6 - Desafios com La√ßos de Repeti√ß√£o
Voc√™ recebeu a tarefa de elaborar um programa que calcule o IMC m√©dio da sua turma. Sabendo que o IMC √© dado pela f√≥rmula imc = peso / (altura * altura), elabore um programa que seja capaz de calcular o IMC de quantos alunos for necess√°rio. A cada IMC calculado, o usu√°rio dever√° confirmar se deseja continuar. Quando o usu√°rio optar por n√£o continuar mais, exiba a m√©dia aritm√©tica dos IMCs calculados.
Construa um algoritmo que leia a idade de v√°rias pessoas e, ao fim da execu√ß√£o, escreva o total de pessoas com menos de 18 anos e o total de pessoas com mais de 65 anos. Seu algoritmo deve parar de ler idades quando o usu√°rio digitar uma idade menor que 1.
Na matem√°tica, o fatorial de um n√∫mero inteiro a, representado por a!, √© o produto de todos os inteiros positivos menores ou iguais a a. Por exemplo, 3! ou 3 fatorial √© dado por 3 * 2 * 1, que √© igual a 6. Construa um programa que seja capaz de ler um n√∫mero inteiro e apresentar seu fatorial.
A Sequ√™ncia de Fibonacci √© uma sequ√™ncia de n√∫meros inteiros, come√ßando normalmente por 0 e 1, na qual, cada termo subsequente corresponde √† soma dos dois anteriores. Os 10 primeiros termos desta sequ√™ncia s√£o 0, 1, 1, 2, 3, 5, 8, 13, 21, 34. Construa um programa que escreva todos os termos da sequ√™ncia de Fibonacci menores que 10000.
Dado o problema anterior, construa um programa que leia um n√∫mero inteiro N e escreva apenas N termos da sequ√™ncia de Fibonacci.
Ainda baseado no problema da sequ√™ncia de Fibonacci, construa um programa que leia um n√∫mero inteiro N e escreva a soma dos N primeiros termos da sequ√™ncia de Fibonacci.
Um n√∫mero primo √© um n√∫mero inteiro n√£o negativo, maior que 1, e divis√≠vel apenas por 1 e por ele mesmo. Construa um programa que leia um n√∫mero inteiro N e informe se este √© ou n√£o √© um n√∫mero primo.
O M√°ximo Divisor Comum (MDC) entre dois n√∫meros naturais (n√∫meros inteiros positivos) √© o maior n√∫mero natural que divide ambos. Desenvolva um programa que leia dois n√∫meros inteiros positivos X e Y e escreva seu MDC.
Um n√∫mero perfeito √© um n√∫mero natural (inteiro positivo {1,2,3,4...}) cujo valor √© igual √† soma de seus divisores naturais, sem contar com ele mesmo. Ex.: 6 √© um n√∫mero perfeito porque a soma de seus divisores √© igual a ele mesmo: 1 + 2 + 3 = 6. Construa um programa que leia um n√∫mero natural e informe se este √© um n√∫mero perfeito.
Lista 7 - Vetores
Com um vetor, leia 5 n√∫meros inteiros e imprima-os.
Com um vetor, leia 5 nomes e imprima-os.
Com um vetor, leia 5 n√∫meros inteiros e imprima-os em ordem inversa. Ex.: 5,1,4,8,0 ‚Äì 0,8,4,1,5.
Com um vetor, leia 10 n√∫meros reais. Imprima os n√∫meros lidos, multiplicando os n√∫meros de posi√ß√µes √≠mpares por 1.05, e os de posi√ß√µes pares por 1.02.
Com um vetor, leia 5 n√∫meros reais, imprima-os na ordem lida e na ordem inversa.
Declare dois vetores, preencha o primeiro com 10 n√∫meros inteiros lidos, copie o conte√∫do do primeiro para o segundo, depois imprima os dois vetores lado a lado.
Em um vetor que cont√©m as m√©dias de uma turma de 10 alunos, calcule a m√©dia da turma e conte quantos alunos obtiveram nota acima da m√©dia da turma. Escreva a m√©dia da turma e o total de alunos acima da m√©dia.
Declare um vetor com 5 nomes de pessoas diferentes. Em seguida, permita que o usu√°rio digite um nome. Se este nome estiver no vetor, informe que tal pessoa foi encontrada. Sen√£o, informe que tal pessoa n√£o foi encontrada.
Declare tr√™s vetores. Preencha o primeiro e depois o segundo, cada um com 5 n√∫meros inteiros lidos. Por fim, percorra os tr√™s vetores simultaneamente, preenchendo o terceiro com as somas dos outros dois. Imprima os tr√™s lado a lado.
Vetores
Lista 8 - Matrizes
Na presente lista de exerc√≠cios, quando o enunciado disser "Gere uma matriz", voc√™ dever√° declarar a matriz vazia e utilizar estruturas de repeti√ß√£o para percorr√™-la e atribuir valores automaticamente. Nesse caso, os valores n√£o ser√£o informados pelo usu√°rio; exceto o tamanho da matriz, quando especificado. Por exemplo, poder√≠amos atribuir um n√∫mero inteiro aleat√≥rio, entre 1 e 100, √† vari√°vel x da seguinte maneira:

let x = parseInt(Math.random() * 100 + 1);
Quando se disser "Leia uma matriz", entenda que todos os elementos da matriz dever√£o ser lidos; ou seja, informados pelo usu√°rio.

1. Leia e armazene nome, idade e sal√°rio de 5 pessoas em uma √∫nica matriz. Ao fim, exiba a matriz em formato tabular. Ex.:

Jos√©        30      3000.00
Maria       28      3200.00
Carlos      41      9500.00
Joaquim     56      12000.00
Silvia      32      10000.00
2. Leia uma matriz 3 x 3 de inteiros. Ao fim, exiba a matriz em formato tabular e tamb√©m o elemento do centro. Ex.:


1   2   3
4   5   6
7   8   9

Elemento do centro: 5
3. Leia uma matriz quadrada N x N de inteiros, onde N √© um inteiro informado pelo usu√°rio. Exiba a matriz em formato tabular.

4. Leia uma matriz N x M de inteiros, onde N e M s√£o inteiros informados pelo usu√°rio. Exiba a matriz em formato tabular.

5. Gere uma matriz 4 x 4 de inteiros. Ao fim, exiba a matriz em formato tabular e tamb√©m os elementos dos cantos. Ex.:

1   7   5   3
5   2   0   9
3   4   8   1
2   5   3   9

Elementos dos cantos: 1, 3, 2 e 9
6. Gere uma matriz 3 x 3 de inteiros aleat√≥rios. Exiba a matriz em formato tabular e tamb√©m os resultados das somas dos elementos da diagonal principal e da diagonal secund√°ria. Ex.:

5   3   2
8   5   4
7   2   3

Soma da diagonal principal: 13
Soma da diagonal secund√°ria: 14
7. Gere uma matriz 10 x 10 de inteiros, onde o valor de cada elemento √© dado pela soma de seus √≠ndices. Exiba a matriz em formato tabular. Ex.:

0   1   2   3   4   5   6   7   8   9
1   2   3   4   5   6   7   8   9   10
2   3   4   5   6   7   8   9   10  11
...
9   10  11  12  13  14  15  16  17  18
8. Gere uma matriz identidade N x N, onde N √© um inteiro informado pelo usu√°rio. Uma matriz identidade √© uma matriz quadrada em que os elementos de sua diagonal principal s√£o todos iguais a 1 e os demais elementos iguais a 0. Exiba a matriz identidade em formato tabular. Ex.:

1   0   0   0
0   1   0   0
0   0   1   0
0   0   0   1
9. Gere uma matriz 3 x 3 inteiros aleat√≥rios, exiba a matriz em formato tabular, depois escreva os elementos pares e os √≠mpares dessa matriz, separados e na ordem em que aparecem. Ex.:

8   1   3
5   6   7
3   4   2

Pares: 8, 6, 4, 2
√çmpares: 1, 3, 5, 7, 3
10. Leia uma matriz 2 x 3 de inteiros e exiba essa matriz em formato tabular. Logo ap√≥s, leia um inteiro D e escreva os elementos dessa matriz que sejam divis√≠veis por D.

11. Gere duas matrizes 4 x 2 de inteiros aleat√≥rios, A e B. Em seguida, gere uma matriz resultante de A + B e exiba as tr√™s em formato tabular.

12. Considerando que N √© um inteiro >= 3 informado pelo usu√°rio, gere uma matriz quadrada N x N, em que os elementos √†s margens da matriz sejam iguais a 1 e os internos sejam iguais a 0. Ao fim, exiba a matriz em formato tabular. Ex.:

1   1   1       1   1   1   1       1   1   1   1   1
1   0   1       1   0   0   1       1   0   0   0   1
1   1   1       1   0   0   1       1   0   0   0   1
                1   1   1   1       1   0   0   0   1
                                    1   1   1   1   1
13. Considerando que N e M s√£o inteiros informados pelo usu√°rio, leia uma matriz N x M de inteiros, e gere uma matriz transposta a partir dela. Exiba a matriz original e a matriz transposta em formato tabular. Ex.:

Matriz original:
1   2   3
4   5   6

Matriz transposta:
1   4
2   5
3   6
14. Considerando que N e M s√£o inteiros informados pelo usu√°rio, leia uma matriz N x M de inteiros, e gere uma matriz rotacionada em 90 graus em sentido hor√°rio a partir dela. Exiba a matriz original e a matriz rotacionada em formato tabular. Ex.:

Matriz original:
1   2
3   4
5   6

Matriz rotacionada:
5   3   1
6   4   2
15. Utilizando uma matriz de 3 x 3, construa um Jogo da Velha que possa ser jogado por duas pessoas. Ao fim do jogo, informe quem venceu ou se houve empate.

Lista 9 - Fun√ß√µes
Crie uma fun√ß√£o escreva(texto) que receba um texto como par√¢metro e exiba esse texto no console.
Crie uma fun√ß√£o soma(x, y) que receba dois n√∫meros como par√¢metros e retorne sua soma.
Crie uma fun√ß√£o hora() que retorne o hor√°rio atual do sistema no formato horas:minutos:segundos.
Crie uma fun√ß√£o mostrarHora() que escreva no console o hor√°rio atual do sistema no formato horas:minutos:segundos.
Crie uma fun√ß√£o quadrado(num) que receba um n√∫mero como par√¢metro e retorne o seu quadrado.
Crie uma fun√ß√£o cubo(num) que receba um n√∫mero como par√¢metro e retorne o seu cubo.
Crie uma fun√ß√£o potencia(num, expoente) que receba como par√¢metros um n√∫mero (num) e um expoente, e retorne a potencia√ß√£o/exponencia√ß√£o de num elevado a expoente.
Crie uma fun√ß√£o recursiva potencia(num, expoente) que receba como par√¢metros um n√∫mero (num) e um expoente, e retorne a potencia√ß√£o/exponencia√ß√£o de num elevado a expoente. Nesta fun√ß√£o n√£o s√£o permitidas estruturas de repeti√ß√£o.
Crie uma fun√ß√£o imc(peso, altura) que receba os par√¢metros peso e altura, e retorne o √çndice de Massa Corporal resultante.
Crie uma fun√ß√£o calculaAreaQuadrado(lado) que calcule e retorne a √°rea de um quadrado com base na medida de seu lado.
Crie uma fun√ß√£o calculaAreaRetangulo(largura, altura) que calcule e retorne a √°rea de um ret√¢ngulo com base em sua largura e altura.
Crie uma fun√ß√£o calculaAreaCirculo(raio) que calcule e retorne a √°rea de um c√≠rculo com base em seu raio.
Crie uma fun√ß√£o mostrarLista(lista) que receba um array como par√¢metro, percorra cada uma de suas posi√ß√µes e as escreva separadamente no console.
Crie uma fun√ß√£o matrizNula(matriz) que receba uma matriz como par√¢metro, retorne true caso a matriz seja nula e false caso contr√°rio.
Crie uma fun√ß√£o matrizQuadrada(matriz) que receba uma matriz como par√¢metro, retorne true caso a matriz seja quadrada e false caso contr√°rio.
Crie uma fun√ß√£o matrizDiagonal(matriz) que receba uma matriz como par√¢metro, retorne true caso a matriz seja diagonal e false caso contr√°rio. Utilize a fun√ß√£o matrizQuadrada(matriz) para verificar se a matriz √© quadrada antes de verificar se √© uma matriz diagonal.
Crie uma fun√ß√£o soma(...termos) que retorne o resultado da soma de um n√∫mero indefinido de termos.
Crie uma fun√ß√£o escreva(...valores) que funcione exatamente como a console.log(): escreva um n√∫mero indefinido de valores no console.
Crie uma fun√ß√£o mediaAritmetica(...termos) que receba como par√¢metro um n√∫mero indefinido de termos e retorne sua m√©dia aritm√©tica.
Crie uma fun√ß√£o ehPrimo(numero) que receba um n√∫mero natural como par√¢metro e retorne true caso o n√∫mero seja primo ou false caso contr√°rio.
Crie uma fun√ß√£o ehPerfeito(numero) que receba um n√∫mero natural como par√¢metro e retorne true caso o n√∫mero seja perfeito ou false caso contr√°rio. Um n√∫mero √© perfeito quando √© igual √† soma dos seus divisores sem contar com ele mesmo. Ex.: 6 √© perfeito porque 1 + 2 + 3 = 6.
Lista 10 - Objetos
Construa uma classe Pessoa, contendo algumas propriedades, como nome, idade e sexo e um m√©todo apresenta(), que exiba uma mensagem de apresenta√ß√£o com os dados desta pessoa.
Construa uma classe Retangulo, contendo as propriedades altura e largura, e um m√©todo area() ou calculaArea(). A √°rea de um ret√¢ngulo √© dada pela seguinte f√≥rmula: A = b * h, onde A representa √°rea, b representa base e h representa altura.
Construa uma classe Cubo, contendo a propriedade aresta e um m√©todo volume() ou calculaVolume(). Um cubo possui medidas iguais em todas as suas arestas, o que resulta em seus lados todos iguais. O volume de um cubo √© dado pela f√≥rmula V = a ** 3, onde V representa o volume e a a medida da aresta.
Construa uma classe Carro, contendo as propriedades modelo, marca, cor, portas, ano, anoModelo, ligado, farolLigado velocidade, e os m√©todos ligaDesliga(), acelera(), freia() e ligaDesligaFarol(). Os m√©todos devem interagir com as propriedades do objeto. Seja criativo.


Perfeito, Flame! Vou te organizar **100 exerc√≠cios de Programa√ß√£o Orientada a Objetos (POO) em Python**, divididos por n√≠veis de dificuldade: iniciante, intermedi√°rio e avan√ßado. Vou fazer de forma que voc√™ possa praticar conceitos como **classes, objetos, atributos, m√©todos, heran√ßa, polimorfismo, encapsulamento, e muito mais**.

---

## **Exerc√≠cios Iniciais (1‚Äì30)**

1. Crie uma classe `Pessoa` com atributos `nome` e `idade`. Crie um m√©todo `apresentar()` que imprime os dados da pessoa.
2. Crie uma classe `Carro` com atributos `marca`, `modelo` e `ano`. Adicione m√©todo `detalhes()` que imprime suas informa√ß√µes.
3. Crie uma classe `Retangulo` com atributos `largura` e `altura`. Crie m√©todos para calcular `√°rea` e `per√≠metro`.
4. Crie uma classe `ContaBancaria` com atributos `titular` e `saldo`. Adicione m√©todos `depositar` e `sacar`.
5. Crie uma classe `Aluno` com atributos `nome` e `notas` (uma lista). Crie m√©todo `media()` que retorna a m√©dia das notas.
6. Crie uma classe `Livro` com atributos `titulo`, `autor` e `ano`. Adicione m√©todo que retorna uma string descritiva.
7. Crie uma classe `Funcionario` com atributos `nome` e `salario`. Adicione m√©todo `aumentar_salario(percentual)`.
8. Crie uma classe `Lampada` com atributo `ligada` (booleano) e m√©todos `ligar()` e `desligar()`.
9. Crie uma classe `Telefone` com atributos `numero` e `mensagens` (lista). Adicione m√©todo para enviar mensagem.
10. Crie uma classe `Animal` com atributo `nome` e m√©todo `falar()`, que imprime algo gen√©rico.
11. Crie uma classe `Cachorro` que herda de `Animal` e sobrescreve `falar()` para imprimir "Au au!".
12. Crie uma classe `Gato` que herda de `Animal` e sobrescreve `falar()` para imprimir "Miau!".
13. Crie uma classe `Produto` com atributos `nome` e `preco`. Adicione m√©todo para aplicar desconto.
14. Crie uma classe `Pessoa` com m√©todo est√°tico `dizer_ola()` que imprime "Ol√°!".
15. Crie uma classe `Circulo` com atributo `raio` e m√©todo para calcular a `√°rea`.
16. Crie uma classe `ContaBancaria` com m√©todo de classe que retorna o n√∫mero total de contas criadas.
17. Crie uma classe `Temperatura` com atributo `celsius` e m√©todos para converter para `fahrenheit` e `kelvin`.
18. Crie uma classe `Aluno` com m√©todo `adicionar_nota(nota)`.
19. Crie uma classe `Carro` que registra o total de carros criados (atributo de classe).
20. Crie uma classe `Livro` que mant√©m um hist√≥rico de todos os t√≠tulos criados.
21. Crie uma classe `Pessoa` que impede a altera√ß√£o direta do atributo `idade` (encapsulamento).
22. Crie uma classe `Funcionario` com m√©todos privados para calcular b√¥nus.
23. Crie uma classe `Elevador` com atributos `andar_atual` e `total_andares` e m√©todos `subir()` e `descer()`.
24. Crie uma classe `Cafeteira` com m√©todo `preparar_cafe()` que imprime uma mensagem.
25. Crie uma classe `Relogio` com m√©todo que retorna a hora atual (use `datetime`).
26. Crie uma classe `Agenda` com m√©todos para adicionar e remover compromissos.
27. Crie uma classe `ContaPoupanca` que herda de `ContaBancaria` e adiciona m√©todo `render_juros()`.
28. Crie uma classe `Funcionario` com m√©todo `__str__()` para mostrar os dados formatados.
29. Crie uma classe `Carro` que calcula a velocidade m√©dia a partir de dist√¢ncia e tempo.
30. Crie uma classe `Aluno` que sobrescreve o m√©todo `__repr__()` para mostrar um resumo do aluno.

---

## **Exerc√≠cios Intermedi√°rios (31‚Äì70)**

31. Crie uma classe `Veiculo` com atributos gen√©ricos e m√©todos `ligar()` e `desligar()`.
32. Crie classes `Carro` e `Moto` que herdam de `Veiculo` e sobrescrevem um m√©todo.
33. Crie uma classe `Banco` que cont√©m v√°rias `ContaBancaria`.
34. Crie uma classe `Estudante` que mant√©m um hist√≥rico de notas em diferentes disciplinas.
35. Crie uma classe `Time` com m√©todo para adicionar jogadores (classe `Jogador`).
36. Crie uma classe `Quadrado` que herda de `Retangulo` e sobrescreve m√©todos de √°rea e per√≠metro.
37. Crie uma classe `Funcionario` com atributo `salario` protegido e m√©todo para acessar via `getter`.
38. Crie uma classe `Funcionario` com m√©todo `__eq__()` que compara funcion√°rios pelo sal√°rio.
39. Crie uma classe `ListaDeCompras` que mant√©m uma lista de itens √∫nicos.
40. Crie uma classe `Pedido` que calcula o total baseado em itens e pre√ßos.
41. Crie uma classe `Filme` com atributos `titulo`, `diretor`, `ano` e m√©todo que verifica se √© cl√°ssico (>20 anos).
42. Crie uma classe `Cliente` que registra hist√≥rico de compras.
43. Crie uma classe `Funcionario` que implementa polimorfismo com m√©todo `calcular_pagamento()`.
44. Crie uma classe `Animal` com m√©todo `alimentar()` que aceita quantidade de comida.
45. Crie uma classe `Gato` e `Cachorro` com comportamento diferente de `alimentar()`.
46. Crie uma classe `Livro` com m√©todo que retorna se o livro √© recente (<5 anos).
47. Crie uma classe `Pessoa` com m√©todo que calcula o IMC a partir de altura e peso.
48. Crie uma classe `Carro` com m√©todo para alterar combust√≠vel restante e verificar autonomia.
49. Crie uma classe `Banco` que realiza transfer√™ncias entre contas.
50. Crie uma classe `Agenda` que permite buscar compromissos por data.
51. Crie uma classe `Funcionario` com m√©todo que calcula imposto baseado no sal√°rio.
52. Crie uma classe `Aluno` que calcula nota final considerando peso das provas.
53. Crie uma classe `Curso` que mant√©m uma lista de alunos matriculados.
54. Crie uma classe `Pessoa` com m√©todo que verifica se √© maior de idade.
55. Crie uma classe `Funcionario` com m√©todo `promover()` que aumenta o cargo.
56. Crie uma classe `ContaBancaria` que gera extrato detalhado de todas transa√ß√µes.
57. Crie uma classe `Produto` que lan√ßa exce√ß√£o se o pre√ßo for negativo.
58. Crie uma classe `Carro` com m√©todo que calcula tempo de viagem baseado em velocidade m√©dia.
59. Crie uma classe `Funcionario` com m√©todo que retorna uma string resumida do funcion√°rio.
60. Crie uma classe `Estudante` que calcula a maior e menor nota.
61. Crie uma classe `Livro` que verifica se est√° dispon√≠vel (booleano).
62. Crie uma classe `Cliente` que registra hist√≥rico de pontos de fidelidade.
63. Crie uma classe `ContaBancaria` com m√©todo que impede saque maior que saldo.
64. Crie uma classe `Funcionario` com m√©todo `__lt__()` para comparar sal√°rios.
65. Crie uma classe `Animal` com atributo `idade` e m√©todo que calcula anos humanos (para cachorro ou gato).
66. Crie uma classe `Cachorro` que herda de `Animal` e adiciona m√©todo `correr()`.
67. Crie uma classe `Carro` com m√©todo que calcula consumo de combust√≠vel.
68. Crie uma classe `Funcionario` que gera um relat√≥rio de horas trabalhadas.
69. Crie uma classe `Aluno` que imprime boletim completo com notas e m√©dia.
70. Crie uma classe `Pedido` que calcula desconto dependendo do valor total.

---

## **Exerc√≠cios Avan√ßados (71‚Äì100)**

71. Crie uma classe abstrata `Forma` com m√©todos abstratos `area()` e `perimetro()`.
72. Crie classes `Triangulo` e `Quadrado` que implementam `Forma`.
73. Crie uma classe `Funcionario` com polimorfismo para calcular b√¥nus de acordo com tipo de funcion√°rio.
74. Crie uma classe `ContaBancaria` com transa√ß√µes salvas em arquivo (persist√™ncia).
75. Crie uma classe `Aluno` que mant√©m hist√≥rico em arquivo JSON.
76. Crie uma classe `Estoque` com m√©todos que lan√ßam exce√ß√£o se n√£o houver produto.
77. Crie uma classe `Veiculo` abstrata com m√©todo `mover()`.
78. Crie uma classe `Moto` que sobrescreve `mover()` com comportamento pr√≥prio.
79. Crie uma classe `Funcionario` com decoradores para validar sal√°rio e cargo.
80. Crie uma classe `Cliente` que valida CPF ou CNPJ ao criar o objeto.
81. Crie uma classe `Jogo` que gerencia jogadores (heran√ßa e polimorfismo).
82. Crie uma classe `ContaBancaria` que permite contas correntes e poupan√ßa com comportamento diferente.
83. Crie uma classe `Funcionario` que calcula aposentadoria considerando idade e tempo de servi√ßo.
84. Crie uma classe `Produto` que registra hist√≥rico de pre√ßo e quantidade em estoque.
85. Crie uma classe `Pedido` que registra hist√≥rico de status (pendente, enviado, entregue).
86. Crie uma classe `Banco` que valida transfer√™ncias (saldo, limites e exist√™ncia de contas).
87. Crie uma classe `Funcionario` que gera relat√≥rio completo em CSV.
88. Crie uma classe `Aluno` que permite calcular estat√≠sticas (m√©dia, mediana, moda).
89. Crie uma classe `Veiculo` que registra manuten√ß√£o e alertas autom√°ticos.
90. Crie uma classe `Carro` que implementa heran√ßa m√∫ltipla (por exemplo, Carro + VeiculoEletrico).
91. Crie uma classe `ContaBancaria` com m√©todo `__add__()` que soma saldos de duas contas.
92. Crie uma classe `Funcionario` com m√©todo `__mul__()` que calcula b√¥nus multiplicativo.
93. Crie uma classe `Pedido` com polimorfismo para calcular frete de acordo com tipo de produto.
94. Crie uma classe `Aluno` que valida notas para n√£o permitir valores negativos.
95. Crie uma classe `Cliente` que implementa compara√ß√£o pelo valor total gasto.
96. Crie uma classe `Funcionario` que valida entrada de dados usando `@property`.
97. Crie uma classe `ContaBancaria` que registra todas opera√ß√µes com carimbo de data/hora.
98. Crie uma classe `Produto` que gera alertas quando o estoque estiver baixo.
99. Crie uma classe `Biblioteca` que controla empr√©stimos e devolu√ß√µes de livros.
100. Crie uma aplica√ß√£o completa com classes `Aluno`, `Curso` e `Professor` e intera√ß√µes entre elas.

---

Se voc√™ quiser, posso **montar esses 100 exerc√≠cios j√° com exemplos de c√≥digo prontos para testar**, para voc√™ ir aprendendo POO de forma pr√°tica e acelerada.

Quer que eu fa√ßa isso?


# 100 Exerc√≠cios de Programa√ß√£o Orientada a Objetos em Python

## N√≠vel B√°sico (1-30)

### Classes e Objetos Simples
1. Crie uma classe `Pessoa` com atributos nome e idade
2. Crie uma classe `Cachorro` com atributos nome, ra√ßa e idade
3. Crie uma classe `Carro` com atributos marca, modelo e ano
4. Crie uma classe `Livro` com atributos t√≠tulo, autor e n√∫mero de p√°ginas
5. Crie uma classe `Retangulo` com atributos largura e altura

### M√©todos B√°sicos
6. Adicione um m√©todo `apresentar()` √† classe Pessoa que exiba as informa√ß√µes
7. Adicione um m√©todo `latir()` √† classe Cachorro que retorne "Au au!"
8. Adicione um m√©todo `acelerar()` √† classe Carro
9. Adicione um m√©todo `info()` √† classe Livro que retorne todas as informa√ß√µes
10. Adicione m√©todos `calcular_area()` e `calcular_perimetro()` √† classe Retangulo

### Construtores (__init__)
11. Crie uma classe `ContaBancaria` com saldo inicial no construtor
12. Crie uma classe `Produto` com nome, pre√ßo e quantidade no construtor
13. Crie uma classe `Aluno` com nome, matr√≠cula e notas no construtor
14. Crie uma classe `Funcionario` com nome, cargo e sal√°rio no construtor
15. Crie uma classe `Circulo` com raio no construtor

### M√©todos com L√≥gica
16. Adicione m√©todos `depositar()` e `sacar()` √† classe ContaBancaria
17. Adicione um m√©todo `aplicar_desconto()` √† classe Produto
18. Adicione um m√©todo `calcular_media()` √† classe Aluno
19. Adicione um m√©todo `dar_aumento()` √† classe Funcionario
20. Adicione m√©todos para calcular √°rea e circunfer√™ncia √† classe Circulo

### Encapsulamento B√°sico
21. Crie uma classe `Pessoa` com atributo privado `__cpf`
22. Crie getters e setters para o atributo privado de Pessoa
23. Crie uma classe `Senha` com atributo privado `__senha`
24. Adicione valida√ß√£o no setter da classe Senha
25. Crie uma classe `Email` com valida√ß√£o de formato

### M√©todos Especiais
26. Implemente `__str__()` na classe Pessoa
27. Implemente `__repr__()` na classe Produto
28. Implemente `__len__()` em uma classe `Lista`
29. Implemente `__eq__()` para comparar dois objetos Pessoa
30. Implemente `__add__()` para somar dois objetos ContaBancaria

## N√≠vel Intermedi√°rio (31-65)

### Heran√ßa Simples
31. Crie classes `Animal` e `Gato` (herda de Animal)
32. Crie classes `Veiculo` e `Moto` (herda de Veiculo)
33. Crie classes `FormaGeometrica` e `Triangulo` (herda de FormaGeometrica)
34. Crie classes `Funcionario` e `Gerente` (herda de Funcionario)
35. Crie classes `ContaBancaria` e `ContaPoupanca` (herda de ContaBancaria)

### Sobrescrita de M√©todos
36. Sobrescreva o m√©todo `fazer_som()` em diferentes classes de animais
37. Sobrescreva o m√©todo `calcular_salario()` em diferentes tipos de funcion√°rios
38. Sobrescreva o m√©todo `calcular_area()` em diferentes formas geom√©tricas
39. Sobrescreva o m√©todo `__str__()` em classes derivadas
40. Sobrescreva o m√©todo `acelerar()` em diferentes tipos de ve√≠culos

### Polimorfismo
41. Crie uma fun√ß√£o que receba diferentes animais e chame `fazer_som()`
42. Crie uma lista de formas geom√©tricas e calcule a √°rea total
43. Crie um sistema de pagamentos com diferentes m√©todos (PIX, cart√£o, boleto)
44. Crie diferentes tipos de notifica√ß√µes (Email, SMS, Push)
45. Crie diferentes estrat√©gias de desconto para produtos

### Heran√ßa M√∫ltipla
46. Crie classes `Nadador`, `Corredor` e `Triatleta` (herda das duas)
47. Crie classes `Voador`, `Nadador` e `Pato` (herda das duas)
48. Crie um sistema de permiss√µes com m√∫ltiplas interfaces
49. Resolva um problema de diamante na heran√ßa
50. Crie mixins para adicionar funcionalidades a classes

### Classes Abstratas
51. Crie uma classe abstrata `Forma` com m√©todo abstrato `calcular_area()`
52. Crie uma classe abstrata `Veiculo` com m√©todos abstratos
53. Crie uma interface `Pagavel` para diferentes tipos de pagamento
54. Crie uma classe abstrata `Animal` com m√©todos abstratos e concretos
55. Crie uma hierarquia de classes abstratas para um sistema de arquivos

### Composi√ß√£o
56. Crie uma classe `Motor` e use-a em `Carro`
57. Crie uma classe `Endereco` e use-a em `Pessoa`
58. Crie classes `Roda`, `Motor`, `Carro` com composi√ß√£o
59. Crie um sistema de pedidos com composi√ß√£o de produtos
60. Crie uma classe `Universidade` que cont√©m `Departamentos`

### Agrega√ß√£o
61. Crie classes `Professor` e `Turma` com agrega√ß√£o
62. Crie classes `Livro` e `Biblioteca` com agrega√ß√£o
63. Crie um sistema de times e jogadores
64. Crie um sistema de playlist e m√∫sicas
65. Crie um carrinho de compras com agrega√ß√£o de produtos

## N√≠vel Avan√ßado (66-100)

### Properties e Decoradores
66. Use `@property` para criar atributos calculados
67. Crie uma classe com `@property`, `@setter` e `@deleter`
68. Implemente valida√ß√£o usando properties
69. Crie atributos read-only usando `@property`
70. Use `@classmethod` para criar factory methods

### M√©todos Est√°ticos e de Classe
71. Crie m√©todos est√°ticos para valida√ß√µes
72. Use `@classmethod` para criar construtores alternativos
73. Crie um contador de inst√¢ncias usando atributos de classe
74. Implemente o padr√£o Singleton
75. Crie m√©todos utilit√°rios est√°ticos

### M√©todos M√°gicos Avan√ßados
76. Implemente `__getitem__()` e `__setitem__()`
77. Implemente `__iter__()` e `__next__()`
78. Implemente `__enter__()` e `__exit__()` (context manager)
79. Implemente `__call__()` para tornar objetos cham√°veis
80. Implemente operadores matem√°ticos (`__add__`, `__sub__`, etc.)

### Design Patterns
81. Implemente o padr√£o Factory
82. Implemente o padr√£o Builder
83. Implemente o padr√£o Observer
84. Implemente o padr√£o Strategy
85. Implemente o padr√£o Decorator

### Sistemas Complexos
86. Crie um sistema de gerenciamento de biblioteca completo
87. Crie um sistema de e-commerce com carrinho e pagamentos
88. Crie um sistema de gerenciamento escolar
89. Crie um jogo simples (RPG, card game, etc.)
90. Crie um sistema de reservas de hotel

### Metaclasses e Avan√ßado
91. Crie uma metaclass personalizada
92. Use `__new__()` para controlar cria√ß√£o de objetos
93. Implemente um sistema de plugins din√¢mico
94. Crie um ORM simples
95. Implemente descriptors personalizados

### Projetos Integradores
96. Sistema banc√°rio completo com diferentes tipos de contas e transa√ß√µes
97. Rede social simples com posts, coment√°rios e usu√°rios
98. Sistema de gerenciamento de tarefas (to-do list) avan√ßado
99. Simulador de ecossistema com diferentes animais e intera√ß√µes
100. Framework web minimalista com roteamento e middlewares

---

## Dicas para Resolver os Exerc√≠cios

- Comece pelos exerc√≠cios b√°sicos e v√° progredindo
- Teste cada classe criada com diferentes cen√°rios
- Use docstrings para documentar suas classes e m√©todos
- Aplique os princ√≠pios SOLID quando poss√≠vel
- Refatore seu c√≥digo para melhorar a qualidade
- Crie testes unit√°rios para suas classes

## Conceitos Importantes para Revisar

- **Encapsulamento**: Ocultar detalhes de implementa√ß√£o
- **Heran√ßa**: Reutiliza√ß√£o de c√≥digo atrav√©s de hierarquias
- **Polimorfismo**: Mesma interface, comportamentos diferentes
- **Abstra√ß√£o**: Simplificar sistemas complexos
- **Composi√ß√£o vs Heran√ßa**: Quando usar cada abordagem
- **SOLID Principles**: Boas pr√°ticas de design orientado a objetos


Escreva um programa que receba um n√∫mero inteiro n e calcule a soma dos quadrados dos n√∫meros at√© n. Exemplo: se n for igual a 3, seu programa deve dar o resultado da soma dos n√∫meros 1¬≤ (1) + 2¬≤ (4) + 3¬≤ (9).
Escreva um programa que gere o seguinte padr√£o usando la√ßos encaixados:
*
* *
* * *
* * * *
* * * * *
* * * *
* * *
* *
*


Escreva uma fun√ß√£o que dada uma nota entre 0.0 e 10.0 imprima na tela um
conceito entre ‚ÄòA‚Äô e ‚ÄòE‚Äô, segundo a tabela:
A ‚â• 9.0 9.0 > B ‚â• 8.0 8.0 > C ‚â• 7.0 7.0 > D ‚â• 5.0 E < 5.0
O que acontece com o seu programa se for digitada nota menor que zero ou maior
que dez?
